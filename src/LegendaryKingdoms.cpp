// Standard IO
#include <chrono>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <vector>
#include <filesystem>

namespace fs = std::filesystem;

// Using SDL
#include <SDL.h>
#include <SDL_image.h>
#include <SDL_mixer.h>
#include <SDL_ttf.h>

#if defined(_WIN32)

#include <windows.h>
#include <shlobj.h>

#else

#include <unistd.h>
#include <sys/types.h>
#include <pwd.h>

#endif

#include "nlohmann/json.hpp"

#include "constants.hpp"
#include "controls.hpp"
#include "engine.hpp"
#include "location.hpp"
#include "input.hpp"
#include "ship.hpp"
#include "sound.hpp"
#include "story.hpp"
#include "topic.hpp"

#include "color.hpp"

#include "book1.hpp"

// Forward declarations

// create textures, images
SDL_Surface *createHeaderButton(SDL_Window *window, const char *font, int font_size, const char *text, SDL_Color color, Uint32 bg, int w, int h, int x);
SDL_Surface *createImage(const char *image);
SDL_Surface *createImage(const char *image, int w, Uint32 bg);
SDL_Surface *createText(const char *text, const char *ttf, int font_size, SDL_Color textColor, int wrap, int style);
SDL_Surface *createTextAndImage(const char *text, const char *image, const char *ttf, int font_size, SDL_Color textColor, Uint32 bg, int wrap, int style);

// sdl helper functions
void clipValue(int &val, int min, int max);
void createWindow(Uint32 flags, SDL_Window **window, SDL_Renderer **renderer, const char *title, const char *icon);
void drawRect(SDL_Renderer *renderer, int w, int h, int x, int y, int color);
void fillRect(SDL_Renderer *renderer, int w, int h, int x, int y, int color);
void fillWindow(SDL_Renderer *renderer, Uint32 color);
void putHeader(SDL_Renderer *renderer, const char *text, TTF_Font *font, int space, SDL_Color fg, Uint32 bg, int style, int w, int h, int x, int y);
void putText(SDL_Renderer *renderer, const char *text, TTF_Font *font, int space, SDL_Color fg, Uint32 bg, int style, int w, int h, int x, int y);
void renderButtons(SDL_Renderer *renderer, std::vector<Button> controls, int current, int fg, int space, int pts);
void renderButtons(SDL_Renderer *renderer, std::vector<Button> controls, int current, int fg, int space, int pts, bool scroll_up, bool scroll_dn);
void renderCaption(SDL_Renderer *renderer, TTF_Font *font_caption, Button control);
void renderImage(SDL_Renderer *renderer, SDL_Surface *image, int x, int y);
void renderImage(SDL_Renderer *renderer, SDL_Surface *text, int x, int y, int bounds, int offset);
void renderText(SDL_Renderer *renderer, SDL_Surface *text, Uint32 bg, int x, int y, int bounds, int offset);
void renderTextButtons(SDL_Renderer *renderer, std::vector<TextButton> controls, const char *ttf, int selected, SDL_Color fg, Uint32 bg, Uint32 bgSelected, int fontsize, int style);
void renderTextButtons(SDL_Renderer *renderer, std::vector<TextButton> controls, const char *ttf, int selected, SDL_Color fg, Uint32 bg, Uint32 bgSelected, int fontsize, int offsetx, int scrolly, bool hide_scroll, int style);
void setWindowIcon(SDL_Window *window, const char *icon);
void stretchImage(SDL_Renderer *renderer, SDL_Surface *image, int x, int y, int w, int h);
void thickRect(SDL_Renderer *renderer, int w, int h, int x, int y, int color, int pts);

// attributes list
Attribute::Type selectAttribute(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Character::Base &character, int increase);

// game screens
bool armyScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Army::Base> army);
bool armyTransfer(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party);
bool assignTeams(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Engine::TeamAssignment> teams, int min_teams);
bool cargoScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Story::Base *harbour);
bool encyclopediaScreen(SDL_Window *window, SDL_Renderer *renderer, Book::Type bookID);
bool inventoryScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, Character::Base &character, int equipment_limit, bool InCombat);
bool harbourScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Story::Base *harbour);
bool introScreen(SDL_Window *window, SDL_Renderer *renderer);
bool loseItems(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Character::Type character, Team::Type team, std::vector<Equipment::Base> equipment, std::vector<Equipment::Class> exceptions, int LoseLimit, bool back_button);
bool mainScreen(SDL_Window *window, SDL_Renderer *renderer, Book::Type bookID, int storyID);
bool moraleCheck(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Army::Base &unit, int combatRound);
bool mapScreen(SDL_Window *window, SDL_Renderer *renderer, Book::Type book);
bool partyDetails(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party);
bool processStory(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Book::Type book, Story::Base *story);
bool rechargeSpells(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Character::Base &character);
bool recruitAdventurer(SDL_Window *window, SDL_Renderer *renderer, Book::Type bookID, Party::Base &party, int recruitmentPrice);
bool repairScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Story::Base *harbour);
bool restScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, int RestPrice, bool CanRecharge);
bool retreatArmy(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, int unit, Location::Type &location, int threshold, int rolls);
bool selectParty(SDL_Window *window, SDL_Renderer *renderer, Book::Type bookID, Party::Base &party);
bool selectTeam(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Character::Base &character, std::vector<Engine::TeamAssignment> teams);
bool shipScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Engine::ShipPrices> &shop, Story::Base *harbour);
bool shopScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Engine::EquipmentPrice> &shop, int character);
bool skillCheck(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, int team_size, Attribute::Type skill, int difficulty, int success, std::vector<int> &selection, bool useEquipment);
bool skillTestScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team_type, std::vector<int> team, Attribute::Type Skill, int difficulty, int success, bool useEquipment);
bool spellBook(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Character::Base &character, int spells_limit);
bool spellScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Spells::Base> spells, bool back_button);
bool storyScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Engine::Destination destination);
bool takeScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Equipment::Base> equipment, int TakeLimit, bool back_button);
bool testScreen(SDL_Window *window, SDL_Renderer *renderer, Book::Type bookID, int storyID);
bool vaultScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Character::Base &character);
bool viewParty(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, bool inCombat);

// Load / Save Game
Control::Type gameScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, bool save_button);

// render images
int fitImage(SDL_Renderer *renderer, SDL_Surface *image, int x, int y, int w, int h);
int fadeImage(SDL_Renderer *renderer, SDL_Surface *image, int x, int y, int w, int h, Uint8 alpha);

// attack, damage, armour saves screens
int armourSave(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Character::Base &character, int damage);
int assignDamage(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, int combat_damage);
int attackScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Monster::Base> &monsters, int combatant, int opponent, int direction, int combatRound, bool useEquipment);
int castCombatSpell(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Monster::Base> &monsters, std::vector<int> hasAttacked, int combatRound);
int castMassCombatSpell(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Army::Base> &enemyArmy, Location::Type battlefield, std::vector<int> castSpells, int combatRound);
int castSeaCombatSpell(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Ship::Base> &enemyFleet, std::vector<int> castSpells, int combatRound);
int gainAttributeScore(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Character::Base &character, Attribute::Type &attribute, int score, int rolls);
int magicAttackScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Monster::Base> &monsters, Spells::Base &spell, int combatant, int opponent, int fighting_score);
int seaAttackScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Ship::Base> &enemyFleet, int opponent, int direction);

// select single objects
int selectOpponent(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, std::vector<Ship::Base> &enemyFleet, std::vector<int> previousTargets, int combatRound);
int selectOpponent(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, int attacker, std::vector<Monster::Base> &monsters, std::vector<int> previousTargets, int combatRound, Control::Type mode);
int selectPartyMember(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, Equipment::Base equipment, Control::Type mode);
int selectShip(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, std::vector<Ship::Base> ships, Location::Type location, std::vector<Cargo::Type> cargo, Control::Type mode);

// combat screens
Engine::Combat combatScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Monster::Base> &monsters, std::vector<Allies::Type> &allies, bool storyFlee, int fleeRound, int roundLimit, bool useEquipment);
Engine::Combat deploymentScreen(SDL_Window *window, SDL_Renderer *renderer, Location::Type location, Party::Base &party, std::vector<Army::Base> &enemyArmy, std::vector<Engine::BattlefieldSpells> &enemySpells, std::vector<Engine::ArmyStatus> &enemyStatus);
Engine::Combat massCombatScreen(SDL_Window *window, SDL_Renderer *renderer, Location::Type location, Party::Base &party, std::vector<Army::Base> &enemyArmy, std::vector<Engine::BattlefieldSpells> &enemySpells, std::vector<Engine::ArmyStatus> &enemyStatus);
Engine::Combat seaCombatScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Ship::Base> &enemyFleet, bool storyFlee, int fleeRound, int roundLimit);

// get story sections
Story::Base *findStory(Engine::Destination destination);
Story::Base *processChoices(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Story::Base *story);
Story::Base *renderChoices(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Story::Base *story);

// description/string utilities
std::string characterText(Character::Base &character, bool compact);
std::string getSavePath();
std::string itemString(Equipment::Base &equipment);
std::string monsterString(Monster::Base &monster);
std::string miniPreview(std::string file_name);
std::string previewGame(std::string file_name);
std::string shipString(Ship::Base &ship, bool cargo);

// miscellaneous functions
bool IsValidTransfer(Party::Base &party, Location::Type src, Location::Type dst);
bool magicRound0(Character::Base &character, int combatRound);
int FIND_CONTROL(std::vector<Button> &controls, Control::Type control);
void addBye(Story::Base *story, std::string bye);

// other game/story helper functions
void renderArmy(SDL_Renderer *renderer, TTF_Font *font, std::vector<Army::Base> &army, int boxw, int army_boxh, int offsety, SDL_Color fg, Uint32 bg);
void resolveMassCombat(SDL_Window *window, SDL_Renderer *renderer, Location::Type location, Party::Base &party, std::vector<Army::Base> &enemyArmy, std::vector<Engine::BattlefieldSpells> &enemySpells, std::vector<Engine::ArmyStatus> &enemyStatus, Location::Zone zone, int combatRound);
void storyTransition(Party::Base &party, Story::Base *story, Story::Base *next);

// popup List Scroll controls
template <typename T>
void popupScrolls(std::vector<Button> &controls, std::vector<T> &list, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety, bool back_button);

// icon button controls
std::vector<Button> armyList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Army::Base> &army, int start, int last, int limit, int offsetx, int offsety, bool party_controls);
std::vector<Button> attributeList(SDL_Window *window, SDL_Renderer *renderer, Character::Base &character, std::vector<Attribute::Type> &attributes, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> buyCargo(SDL_Window *window, SDL_Renderer *renderer, std::vector<Engine::CargoPrices> &cargo, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> cargoList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Engine::CargoPrices> &cargo, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> cargoList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> combatantList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Character::Base> party, int start, int last, int limit, int offsetx, int offsety, bool confirm_button, bool back_button);
std::vector<Button> createChoices(SDL_Window *window, SDL_Renderer *renderer, std::vector<Choice::Base> choices, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> createFileList(SDL_Window *window, SDL_Renderer *renderer, std::vector<std::string> list, int start, int last, int limit, int offsetx, int offsety, bool save_button);
std::vector<Button> equipmentList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Equipment::Base> list, int start, int last, int limit, int offsety, int scrolly);
std::vector<Button> equipmentList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Equipment::Base> list, int start, int last, int limit, bool confirm_button, bool back_button);
std::vector<Button> harbourControls(SDL_Window *window, SDL_Renderer *renderer);
std::vector<Button> monsterList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Monster::Base> &monsters, int start, int last, int limit, int offsetx, int offsety, bool confirm_button, bool back_button);
std::vector<Button> monsterList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Monster::Base> &monsters, int start, int last, int limit, int offsetx, int offsety, Control::Type mode);
std::vector<Button> popupArmy(SDL_Window *window, SDL_Renderer *renderer, std::vector<Army::Base> &army, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety);
std::vector<Button> popupConfirm(int popupw, int popuph, int offsetx, int offsety);
std::vector<Button> popupList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Army::Base> &list, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety, bool back_button);
std::vector<Button> popupList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Location::Type> &list, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety);
std::vector<Button> popupList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Monster::Base> &list, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety);
std::vector<Button> popupList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &list, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety);
std::vector<Button> popupMoney(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, int popupw, int popuph, int infoh, int offsetx, int offsety);
std::vector<Button> restList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Character::Base> party, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> romanceList(SDL_Window *window, SDL_Renderer *renderer, std::map<Character::Romance, int> &hearts, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, int start, int last, int limit, int offsetx, int offsety, Control::Type mode);
std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, int start, int last, int limit, int offsetx, int offsety, bool cargo, bool confirm_button, bool back_button);
std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, std::vector<Engine::ShipPrices> &shop, int start, int last, int limit, int offsetx, int offsety, bool buy_button, bool sell_button);
std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Engine::ShipPrices> &ships, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Engine::ShipPrices> &ships, int start, int last, int limit, int offsetx, int offsety, bool buy_button, bool sell_button);
std::vector<Button> shopList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Engine::EquipmentPrice> &shop, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> shopList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Equipment::Base> &equipment, std::vector<Engine::EquipmentPrice> &shop, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> rechargeList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Spells::Base> &spells, int start, int last, int limit, int offsetx, int offsety, int scrolly);
std::vector<Button> repairList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> spellList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Spells::Base> &spells, int start, int last, int limit, int offsetx, int offsety, int scrolly);
std::vector<Button> spellList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Spells::Base> &spells, int start, int last, int limit, int offsetx, int offsety, int scrolly, bool confirm_button, bool back_button);
std::vector<Button> teamsList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Team::Type> &teams, int start, int last, int limit, int offsetx, int offsety);
std::vector<Button> topicsList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Topics::Base> &topics, int start, int last, int limit, int offsetx, int offsety, bool compact);
std::vector<Button> vaultList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Equipment::Base> list, int start, int last, int limit, int offsety, int scrolly);

// select multiple objects
std::vector<int> selectArmyUnits(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, std::vector<Army::Base> army, Location::Type garrison, int num_limit);
std::vector<int> selectArmyUnits(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Location::Type garrison, int num_limit);
std::vector<int> selectPartyMembers(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, int team_size, Control::Type mode);
std::vector<int> selectShips(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, std::vector<Ship::Base> ships, Location::Type harbour, int num_limit, bool back_button);
std::vector<int> selectSpell(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Character::Base &caster, std::vector<Spells::Base> &spells, int select_limit, Spells::Select mode);

// text button controls
std::vector<TextButton> createFixedTextButtons(const char **choices, int num, int text_buttonw, int text_buttonh, int textbutton_space, int text_x, int text_buttony);
std::vector<TextButton> createHTextButtons(const char **choices, int num, int text_buttonh, int text_x, int text_buttony);
std::vector<TextButton> createHTextButtons(const char **choices, int num, int text_buttonh, int text_x, int text_buttony, bool has_scrolls);

// json helpers
void followersJSON(nlohmann::json &json, std::vector<Follower::Base> followers);
void spellBookJSON(nlohmann::json &json, std::vector<Spells::Base> spells);
void attributesJSON(nlohmann::json &json, std::vector<Attribute::Base> attributes);
void equipmentJSON(nlohmann::json &json, std::vector<Equipment::Base> equipment);

// load/save games
Party::Base loadGame(std::string file_name);
void saveGame(Party::Base &party, const char *overwrite);

SDL_Surface *createImage(const char *image)
{
    auto surface = IMG_Load(image);

    if (!surface)
    {
        std::cerr << "Unable to load image " << image << "! SDL Error: " << SDL_GetError() << std::endl;
    }

    return surface;
}

SDL_Surface *createImage(const char *image, int wrap, Uint32 bg)
{
    SDL_Surface *surface = NULL;
    SDL_Surface *converted_surface = NULL;

    auto image_surface = createImage(image);

    if (image_surface)
    {
        auto image_h = image_surface->h;

        if (image_surface->w > wrap)
        {
            auto image_scale = (double)((double)wrap / image_surface->w);

            image_h = (int)(image_surface->h * image_scale);
        }

        Uint32 amask;

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
        amask = 0x000000ff;
#else
        amask = 0xff000000;
#endif

        surface = SDL_CreateRGBSurface(0, wrap, image_h, 32, 0, 0, 0, amask);

        SDL_Rect dst;

        dst.w = surface->w;
        dst.h = surface->h;
        dst.x = 0;
        dst.y = 0;

        SDL_FillRect(surface, NULL, bg);

        dst.h = image_h;

        if (image_surface->w > wrap)
        {
            dst.w = surface->w;
        }
        else
        {
            dst.w = image_surface->w;
            dst.h = image_surface->h;
            dst.x = (surface->w - image_surface->w) / 2;
        }

        converted_surface = SDL_ConvertSurface(image_surface, surface->format, 0);

        SDL_BlitScaled(converted_surface, NULL, surface, &dst);
    }

    if (image_surface)
    {
        SDL_FreeSurface(image_surface);

        image_surface = NULL;
    }

    if (converted_surface)
    {
        SDL_FreeSurface(converted_surface);

        converted_surface = NULL;
    }

    return surface;
}

void setWindowIcon(SDL_Window *window, const char *icon)
{
    auto surface = createImage(icon);

    if (surface)
    {
        SDL_SetWindowIcon(window, surface);

        SDL_FreeSurface(surface);

        surface = NULL;
    }
}

void createWindow(Uint32 flags, SDL_Window **window, SDL_Renderer **renderer, const char *title, const char *icon)
{
    // The window we'll be rendering to
    *window = NULL;
    *renderer = NULL;

    if (SDL_Init(flags) < 0)
    {
        std::cerr << "SDL could not initialize! SDL_Error: " << SDL_GetError() << std::endl;
    }
    else
    {
        SDL_DisplayMode mode;

        SDL_GetCurrentDisplayMode(0, &mode);

        SCREEN_WIDTH = (mode.w);

        SCREEN_HEIGHT = (mode.h);

        Recompute();

        SDL_CreateWindowAndRenderer(SCREEN_WIDTH, SCREEN_HEIGHT, (SDL_WINDOW_FULLSCREEN_DESKTOP | SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC), window, renderer);

        if (renderer)
        {
            SDL_SetRenderDrawBlendMode(*renderer, SDL_BLENDMODE_NONE);
        }

        if (!window || !renderer)
        {
            std::cerr << "Window could not be created! SDL_Error: " << SDL_GetError() << std::endl;
        }
        else if (window)
        {
            SDL_SetWindowTitle(*window, title);

            setWindowIcon(*window, icon);
        }

        //Initialize SDL_mixer
        if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0)
        {
            std::cerr << "SDL_mixer could not initialize! SDL_mixer Error: " << Mix_GetError() << std::endl;
        }
    }
}

void renderImage(SDL_Renderer *renderer, SDL_Surface *image, int x, int y)
{
    if (image && renderer)
    {
        SDL_Rect position;

        position.w = image->w;
        position.h = image->h;
        position.x = x;
        position.y = y;

        auto texture = SDL_CreateTextureFromSurface(renderer, image);

        if (texture)
        {
            SDL_Rect src;

            src.w = image->w;
            src.h = image->h;
            src.x = 0;
            src.y = 0;

            SDL_RenderCopy(renderer, texture, &src, &position);

            SDL_DestroyTexture(texture);

            texture = NULL;
        }
    }
}

int fitImage(SDL_Renderer *renderer, SDL_Surface *image, int x, int y, int w, int h)
{
    auto splash_h = image->h;
    auto splash_w = w;

    if (image && renderer)
    {
        SDL_Rect position;

        if (w != image->w)
        {
            splash_h = (int)((double)w / image->w * image->h);
            splash_w = w;

            if (splash_h > h)
            {
                splash_h = h;
                splash_w = (int)((double)h / image->h * image->w);
            }
        }

        position.w = splash_w;
        position.h = splash_h;
        position.x = x;
        position.y = y;

        auto texture = SDL_CreateTextureFromSurface(renderer, image);

        if (texture)
        {
            SDL_Rect src;

            src.w = image->w;
            src.h = image->h;
            src.x = 0;
            src.y = 0;

            SDL_RenderCopy(renderer, texture, &src, &position);

            SDL_DestroyTexture(texture);

            texture = NULL;
        }
    }

    return splash_h;
}

int fadeImage(SDL_Renderer *renderer, SDL_Surface *image, int x, int y, int w, int h, Uint8 alpha)
{
    auto splash_h = image->h;
    auto splash_w = w;

    if (image && renderer)
    {
        SDL_Rect position;

        if (w != image->w)
        {
            splash_h = (int)((double)w / image->w * image->h);
            splash_w = w;

            if (splash_h > h)
            {
                splash_h = h;
                splash_w = (int)((double)h / image->h * image->w);
            }
        }

        position.w = splash_w;
        position.h = splash_h;
        position.x = x;
        position.y = y;

        auto texture = SDL_CreateTextureFromSurface(renderer, image);

        SDL_SetTextureAlphaMod(texture, alpha);

        if (texture)
        {
            SDL_Rect src;

            src.w = image->w;
            src.h = image->h;
            src.x = 0;
            src.y = 0;

            SDL_RenderCopy(renderer, texture, &src, &position);

            SDL_DestroyTexture(texture);

            texture = NULL;
        }
    }

    return splash_h;
}

void stretchImage(SDL_Renderer *renderer, SDL_Surface *image, int x, int y, int w, int h)
{
    if (image && renderer)
    {
        SDL_Rect position;

        position.w = w;
        position.h = h;
        position.x = x;
        position.y = y;

        auto texture = SDL_CreateTextureFromSurface(renderer, image);

        if (texture)
        {
            SDL_Rect src;

            src.w = image->w;
            src.h = image->h;
            src.x = 0;
            src.y = 0;

            SDL_RenderCopy(renderer, texture, &src, &position);

            SDL_DestroyTexture(texture);

            texture = NULL;
        }
    }
}

// Render a portion of the text (image) on bounded surface within the specified window
void renderText(SDL_Renderer *renderer, SDL_Surface *text, Uint32 bg, int x, int y, int bounds, int offset)
{
    if (renderer)
    {
        if (text && renderer)
        {
            SDL_Rect dst;
            SDL_Rect src;

            src.w = text->w;
            src.h = text->h < bounds ? text->h : bounds;
            src.y = offset;
            src.x = 0;

            dst.w = text->w;
            dst.h = text->h < bounds ? text->h : bounds;
            dst.x = x;
            dst.y = y;

            if (bg != 0)
            {
                SDL_SetRenderDrawColor(renderer, R(bg), G(bg), B(bg), A(bg));
                SDL_RenderFillRect(renderer, &dst);
            }

            auto texture = SDL_CreateTextureFromSurface(renderer, text);

            if (texture)
            {
                SDL_RenderCopy(renderer, texture, &src, &dst);

                SDL_DestroyTexture(texture);

                texture = NULL;
            }
        }
    }
}

// Render a portion of the image on bounded surface within the specified window
void renderImage(SDL_Renderer *renderer, SDL_Surface *text, int x, int y, int bounds, int offset)
{
    if (renderer)
    {
        if (text && renderer)
        {
            SDL_Rect dst;
            SDL_Rect src;

            src.w = text->w;
            src.h = text->h < bounds ? text->h : bounds;
            src.y = offset;
            src.x = 0;

            dst.w = text->w;
            dst.h = text->h < bounds ? text->h : bounds;
            dst.x = x;
            dst.y = y;

            auto texture = SDL_CreateTextureFromSurface(renderer, text);

            if (texture)
            {
                SDL_RenderCopy(renderer, texture, &src, &dst);

                SDL_DestroyTexture(texture);

                texture = NULL;
            }
        }
    }
}

// create text image with line wrap limit
SDL_Surface *createText(const char *text, const char *ttf, int font_size, SDL_Color textColor, int wrap, int style)
{
    SDL_Surface *surface = NULL;

    TTF_Init();

    auto font = TTF_OpenFont(ttf, font_size);

    if (font)
    {
        if (std::strcmp(ttf, FONT_DARK11) == 0)
        {
            TTF_SetFontKerning(font, 0);
        }
    }

    if (font)
    {
        TTF_SetFontStyle(font, style);

        surface = TTF_RenderText_Blended_Wrapped(font, text, textColor, wrap);

        TTF_CloseFont(font);

        font = NULL;
    }

    TTF_Quit();

    return surface;
}

// create text and image with line wrap limit
SDL_Surface *createTextAndImage(const char *text, const char *image, const char *ttf, int font_size, SDL_Color textColor, Uint32 bg, int wrap, int style)
{
    SDL_Surface *surface = NULL;
    SDL_Surface *converted_surface = NULL;

    auto image_surface = createImage(image);
    auto text_surface = createText(text, ttf, font_size, textColor, wrap, style);

    if (image_surface && text_surface)
    {
        auto image_h = image_surface->h;

        if (image_surface->w > wrap)
        {
            auto image_scale = (double)((double)wrap / image_surface->w);

            image_h = (int)(image_surface->h * image_scale);
        }

        Uint32 amask;

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
        amask = 0x000000ff;
#else
        amask = 0xff000000;
#endif

        surface = SDL_CreateRGBSurface(0, wrap, image_h + text_space + text_surface->h, 32, 0, 0, 0, amask);

        SDL_Rect dst;

        dst.w = surface->w;
        dst.h = surface->h;
        dst.x = 0;
        dst.y = 0;

        SDL_Rect text_dst;

        text_dst.w = surface->w;
        text_dst.h = surface->h;
        text_dst.x = 0;
        text_dst.y = image_h + text_space;

        SDL_FillRect(surface, NULL, bg);

        dst.h = image_h;

        if (image_surface->w > wrap)
        {
            dst.w = surface->w;
        }
        else
        {
            dst.w = image_surface->w;
            dst.h = image_surface->h;
            dst.x = (surface->w - image_surface->w) / 2;
        }

        converted_surface = SDL_ConvertSurface(image_surface, surface->format, 0);

        SDL_BlitScaled(converted_surface, NULL, surface, &dst);

        SDL_BlitSurface(text_surface, NULL, surface, &text_dst);
    }

    if (image_surface)
    {
        SDL_FreeSurface(image_surface);

        image_surface = NULL;
    }

    if (text_surface)
    {
        SDL_FreeSurface(text_surface);

        text_surface = NULL;
    }

    if (converted_surface)
    {
        SDL_FreeSurface(converted_surface);

        converted_surface = NULL;
    }

    return surface;
}

void fillRect(SDL_Renderer *renderer, int w, int h, int x, int y, int color)
{
    SDL_Rect rect;

    rect.w = w;
    rect.h = h;
    rect.x = x;
    rect.y = y;

    SDL_SetRenderDrawColor(renderer, R(color), G(color), B(color), A(color));
    SDL_RenderFillRect(renderer, &rect);
}

void drawRect(SDL_Renderer *renderer, int w, int h, int x, int y, int color)
{
    SDL_Rect rect;

    rect.w = w;
    rect.h = h;
    rect.x = x;
    rect.y = y;

    SDL_SetRenderDrawColor(renderer, R(color), G(color), B(color), A(color));
    SDL_RenderDrawRect(renderer, &rect);
}

void thickRect(SDL_Renderer *renderer, int w, int h, int x, int y, int color, int pts)
{
    SDL_Rect rect;

    auto space = 2 * pts;

    for (auto size = pts; size >= 0; size--)
    {
        rect.w = w + 2 * (space - size);
        rect.h = h + 2 * (space - size);
        rect.x = x - space + size;
        rect.y = y - space + size;

        SDL_SetRenderDrawColor(renderer, R(color), G(color), B(color), A(color));
        SDL_RenderDrawRect(renderer, &rect);
    }
}

void putHeader(SDL_Renderer *renderer, const char *text, TTF_Font *font, int space, SDL_Color fg, Uint32 bg, int style, int w, int h, int x, int y)
{
    if (renderer)
    {
        TTF_SetFontStyle(font, style);

        auto surface = TTF_RenderText_Blended_Wrapped(font, text, fg, w - 2 * space);

        if (surface)
        {
            auto height = (surface->h + 2 * space) < h ? h : (surface->h + 2 * space);

            if (x < 0)
            {
                fillRect(renderer, w, height, (SCREEN_WIDTH - w) / 2, (SCREEN_HEIGHT - height) / 2, bg);
            }
            else
            {
                fillRect(renderer, w, height, x, y, bg);
            }

            if (space > 0)
            {
                if (x < 0)
                {
                    renderText(renderer, surface, 0, (SCREEN_WIDTH - surface->w) / 2 + space, y + (SCREEN_HEIGHT - surface->h) / 2, height - 2 * space, 0);
                }
                else
                {
                    renderText(renderer, surface, 0, x + space, y + (h - surface->h) / 2, height - 2 * space, 0);
                }
            }
            else
            {
                if (x < 0)
                {
                    renderText(renderer, surface, 0, (SCREEN_WIDTH - surface->w) / 2, y + (SCREEN_HEIGHT - surface->h) / 2, height - 2 * space, 0);
                }
                else
                {
                    renderText(renderer, surface, 0, x + (w - surface->w) / 2, y + (h - surface->h) / 2, height - 2 * space, 0);
                }
            }

            SDL_FreeSurface(surface);

            surface = NULL;
        }
    }
}

void putText(SDL_Renderer *renderer, const char *text, TTF_Font *font, int space, SDL_Color fg, Uint32 bg, int style, int w, int h, int x, int y)
{
    if (renderer)
    {
        TTF_SetFontStyle(font, style);

        auto surface = TTF_RenderText_Blended_Wrapped(font, text, fg, w - 2 * space);

        if (surface)
        {
            auto height = (surface->h + 2 * space) < h ? h : (surface->h + 2 * space);

            if (x < 0)
            {
                fillRect(renderer, w, height, (SCREEN_WIDTH - w) / 2, (SCREEN_HEIGHT - height) / 2, bg);
            }
            else
            {
                fillRect(renderer, w, height, x, y, bg);
            }

            if (space > 0)
            {
                if (x < 0)
                {
                    renderText(renderer, surface, 0, (SCREEN_WIDTH - surface->w) / 2 + space, (SCREEN_HEIGHT - height) / 2 + space, height - 2 * space, 0);
                }
                else
                {
                    renderText(renderer, surface, 0, x + space, y + space, height - 2 * space, 0);
                }
            }
            else
            {
                if (x < 0)
                {
                    renderText(renderer, surface, 0, (SCREEN_WIDTH - surface->w) / 2 + (w - surface->w), (SCREEN_HEIGHT - surface->h) / 2 + (h - surface->h) / 2, height, 0);
                }
                else
                {
                    renderText(renderer, surface, 0, x + (w - surface->w) / 2, y + (h - surface->h) / 2, height, 0);
                }
            }

            SDL_FreeSurface(surface);

            surface = NULL;
        }
    }
}

void fillWindow(SDL_Renderer *renderer, Uint32 color)
{
    SDL_SetRenderDrawColor(renderer, R(color), G(color), B(color), A(color));
    SDL_RenderClear(renderer);
}

void renderTextButtons(SDL_Renderer *renderer, std::vector<TextButton> controls, const char *ttf, int selected, SDL_Color fg, Uint32 bg, Uint32 bgSelected, int fontsize, int style)
{
    if (controls.size() > 0)
    {
        for (auto i = 0; i < controls.size(); i++)
        {
            auto text = createText(controls[i].Text, ttf, fontsize, fg, controls[i].W, style);

            auto x = controls[i].X + (controls[i].W - text->w) / 2;
            auto y = controls[i].Y + (controls[i].H - text->h) / 2;

            SDL_Rect rect;

            rect.w = controls[i].W;
            rect.h = controls[i].H;
            rect.x = controls[i].X;
            rect.y = controls[i].Y;

            if (i == selected)
            {
                SDL_SetRenderDrawColor(renderer, R(bgSelected), G(bgSelected), B(bgSelected), A(bgSelected));
            }
            else
            {
                SDL_SetRenderDrawColor(renderer, R(bg), G(bg), B(bg), A(bg));
            }

            SDL_RenderFillRect(renderer, &rect);

            if (i == selected)
            {
                renderText(renderer, text, bgSelected, x, y, 2 * fontsize, 0);
            }
            else
            {
                renderText(renderer, text, bg, x, y, 2 * fontsize, 0);
            }

            SDL_FreeSurface(text);

            text = NULL;
        }
    }
}

void renderTextButtons(SDL_Renderer *renderer, std::vector<TextButton> controls, const char *ttf, int selected, SDL_Color fg, Uint32 bg, Uint32 bgSelected, int fontsize, int offsetx, int scrolly, bool hide_scroll, int style)
{
    if (controls.size() > 0)
    {
        for (auto i = 0; i < controls.size(); i++)
        {
            if (!hide_scroll && (controls[i].Type == Control::Type::SCROLL_UP || controls[i].Type == Control::Type::SCROLL_DOWN))
            {
                auto space = 8;
                auto pts = 4;

                SDL_Surface *button_surface = NULL;

                if (controls[i].Type == Control::Type::SCROLL_UP)
                {
                    button_surface = createImage("icons/up-arrow.png");

                    if (button_surface)
                    {
                        renderImage(renderer, button_surface, offsetx, texty + border_space);
                    }
                }
                else
                {
                    button_surface = createImage("icons/down-arrow.png");

                    if (button_surface)
                    {
                        renderImage(renderer, button_surface, offsetx, scrolly);
                    }
                }

                if (i == selected)
                {
                    for (auto size = pts; size >= 0; size--)
                    {
                        if (i == selected)
                        {
                            SDL_Rect rect;

                            rect.w = controls[i].W + 2 * (space - size);
                            rect.h = controls[i].H + 2 * (space - size);
                            rect.x = controls[i].X - space + size;
                            rect.y = controls[i].Y - space + size;

                            SDL_SetRenderDrawColor(renderer, R(bgSelected), G(bgSelected), B(bgSelected), A(bgSelected));
                            SDL_RenderDrawRect(renderer, &rect);
                        }
                    }
                }

                if (button_surface)
                {
                    SDL_FreeSurface(button_surface);

                    button_surface = NULL;
                }
            }
            else if (controls[i].Type != Control::Type::SCROLL_UP && controls[i].Type != Control::Type::SCROLL_DOWN)
            {
                auto text = createText(controls[i].Text, ttf, fontsize, fg, controls[i].W, style);

                auto x = controls[i].X + (controls[i].W - text->w) / 2;
                auto y = controls[i].Y + (controls[i].H - text->h) / 2;

                SDL_Rect rect;

                rect.w = controls[i].W;
                rect.h = controls[i].H;
                rect.x = controls[i].X;
                rect.y = controls[i].Y;

                if (i == selected)
                {
                    SDL_SetRenderDrawColor(renderer, R(bgSelected), G(bgSelected), B(bgSelected), A(bgSelected));
                }
                else
                {
                    SDL_SetRenderDrawColor(renderer, R(bg), G(bg), B(bg), A(bg));
                }

                SDL_RenderFillRect(renderer, &rect);

                if (i == selected)
                {
                    renderText(renderer, text, bgSelected, x, y, 2 * fontsize, 0);
                }
                else
                {
                    renderText(renderer, text, bg, x, y, 2 * fontsize, 0);
                }

                SDL_FreeSurface(text);

                text = NULL;
            }
        }
    }
}

void renderButtons(SDL_Renderer *renderer, std::vector<Button> controls, int current, int fg, int space, int pts)
{
    if (controls.size() > 0)
    {
        for (auto i = 0; i < controls.size(); i++)
        {
            SDL_Rect rect;

            renderImage(renderer, controls[i].Surface, controls[i].X, controls[i].Y);

            if (i == current)
            {
                for (auto size = pts; size >= 0; size--)
                {
                    rect.w = controls[i].W + 2 * (space - size);
                    rect.h = controls[i].H + 2 * (space - size);
                    rect.x = controls[i].X - space + size;
                    rect.y = controls[i].Y - space + size;

                    SDL_SetRenderDrawColor(renderer, R(fg), G(fg), B(fg), A(fg));
                    SDL_RenderDrawRect(renderer, &rect);
                }
            }
        }
    }
}

void renderButtons(SDL_Renderer *renderer, std::vector<Button> controls, int current, int fg, int space, int pts, bool scroll_up, bool scroll_dn)
{
    if (controls.size() > 0)
    {
        for (auto i = 0; i < controls.size(); i++)
        {
            SDL_Rect rect;

            if ((controls[i].Type == Control::Type::SCROLL_UP && scroll_up) || (controls[i].Type == Control::Type::SCROLL_DOWN && scroll_dn) || (controls[i].Type != Control::Type::SCROLL_UP && controls[i].Type != Control::Type::SCROLL_DOWN))
            {
                if (controls[i].Type == Control::Type::SCROLL_UP || controls[i].Type == Control::Type::SCROLL_DOWN)
                {
                    fillRect(renderer, controls[i].W + 2 * border_space, controls[i].H + 2 * border_space, controls[i].X - border_space, controls[i].Y - border_space, intWH);
                }

                renderImage(renderer, controls[i].Surface, controls[i].X, controls[i].Y);
            }

            if (i == current)
            {
                if ((controls[i].Type == Control::Type::SCROLL_UP && scroll_up) || (controls[i].Type == Control::Type::SCROLL_DOWN && scroll_dn) || (controls[i].Type != Control::Type::SCROLL_UP && controls[i].Type != Control::Type::SCROLL_DOWN))
                {
                    for (auto size = pts; size >= 0; size--)
                    {
                        rect.w = controls[i].W + 2 * (space - size);
                        rect.h = controls[i].H + 2 * (space - size);
                        rect.x = controls[i].X - space + size;
                        rect.y = controls[i].Y - space + size;

                        SDL_SetRenderDrawColor(renderer, R(fg), G(fg), B(fg), A(fg));
                        SDL_RenderDrawRect(renderer, &rect);
                    }
                }
            }
        }
    }
}

std::vector<TextButton> createHTextButtons(const char **choices, int num, int text_buttonh, int text_x, int text_buttony)
{
    auto controls = std::vector<TextButton>();

    if (num > 0)
    {
        auto margin2 = (2.0 * Margin);
        auto marginleft = (1.0 - margin2);

        auto pixels = (int)(SCREEN_WIDTH * Margin) / 2;
        auto width = (int)(SCREEN_WIDTH * marginleft);

        auto text_spacew = width / num;
        auto htext_buttonw = text_spacew - pixels;
        auto text_space = pixels / 2;

        for (auto i = 0; i < num; i++)
        {
            auto left = i > 0 ? i - 1 : i;
            auto right = i < num - 1 ? i + 1 : i;
            auto up = i;
            auto down = i;

            auto x = text_x + i * (htext_buttonw + text_space * 2) + text_space;

            auto button = TextButton(i, choices[i], left, right, up, down, x, text_buttony, htext_buttonw, text_buttonh);

            controls.push_back(button);
        }
    }

    return controls;
}

std::vector<TextButton> createHTextButtons(const char **choices, int num, int text_buttonh, int text_x, int text_buttony, bool has_scrolls)
{
    if (!has_scrolls)
    {
        return createHTextButtons(choices, num, text_buttonh, text_x, text_buttony);
    }

    auto controls = std::vector<TextButton>();

    if (num > 0)
    {
        auto margin2 = (2.0 * Margin);
        auto marginleft = (1.0 - margin2);

        auto pixels = (int)(SCREEN_WIDTH * Margin) / 2;
        auto width = (int)(SCREEN_WIDTH * marginleft);

        auto text_spacew = width / num;
        auto htext_buttonw = text_spacew - pixels;
        auto text_space = pixels / 2;

        controls.push_back(TextButton(0, "", 0, 0, 0, 1, -1, -1, 32, 32, Control::Type::SCROLL_UP));
        controls.push_back(TextButton(1, "", 1, 1, 0, 2, -1, -1, 32, 32, Control::Type::SCROLL_DOWN));

        for (auto i = 0; i < num; i++)
        {
            auto left = i > 0 ? i + 1 : i + 2;
            auto right = i < num - 1 ? i + 3 : i + 2;
            auto up = 1;
            auto down = i + 2;

            auto x = text_x + i * (htext_buttonw + text_space * 2) + text_space;

            auto button = TextButton(i + 2, choices[i], left, right, up, down, x, text_buttony, htext_buttonw, text_buttonh);

            controls.push_back(button);
        }
    }

    return controls;
}

std::vector<TextButton> createFixedTextButtons(const char **choices, int num, int text_buttonw, int text_buttonh, int textbutton_space, int text_x, int text_buttony)
{
    auto controls = std::vector<TextButton>();

    if (num > 0)
    {
        for (auto i = 0; i < num; i++)
        {
            auto left = i > 0 ? i - 1 : i;
            auto right = i < num - 1 ? i + 1 : i;
            auto up = i;
            auto down = i;

            auto x = text_x + i * (text_buttonw + textbutton_space);

            auto button = TextButton(i, choices[i], left, right, up, down, x, text_buttony, text_buttonw, text_buttonh);

            controls.push_back(button);
        }
    }

    return controls;
}

SDL_Surface *createHeaderButton(SDL_Window *window, const char *font, int font_size, const char *text, SDL_Color color, Uint32 bg, int w, int h, int x)
{
    Uint32 amask;

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
    amask = 0x000000ff;
#else
    amask = 0xff000000;
#endif

    auto button = SDL_CreateRGBSurface(0, w, h, 32, 0, 0, 0, amask);
    auto text_surface = createText(text, font, font_size, color, w, TTF_STYLE_NORMAL);

    if (button && text_surface)
    {
        SDL_Rect dst;

        dst.w = button->w;
        dst.h = button->h;
        dst.x = 0;
        dst.y = 0;

        SDL_FillRect(button, NULL, bg);

        dst.x = x < 0 ? (button->w - text_surface->w) / 2 : x;
        dst.y = (button->h - text_surface->h) / 2;

        SDL_BlitSurface(text_surface, NULL, button, &dst);
    }

    if (text_surface)
    {
        SDL_FreeSurface(text_surface);

        text_surface = NULL;
    }

    return button;
}

int FIND_CONTROL(std::vector<Button> &controls, Control::Type control)
{
    auto found = -1;

    for (auto i = 0; i < controls.size(); i++)
    {
        if (controls[i].Type == control)
        {
            found = i;

            break;
        }
    }

    return found;
}

void clipValue(int &val, int min, int max)
{
    if (val < min)
    {
        val = min;
    }

    if (val > max)
    {
        val = max;
    }
}

bool introScreen(SDL_Window *window, SDL_Renderer *renderer)
{
    auto splashLogo = "images/legendary-kingdoms.png";

    auto splashImage = createImage(splashLogo);

    if (window && renderer && splashImage)
    {
#if !defined(__arm__)
        SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);

        for (Uint8 i = 0; i < (Uint8)255; i += (Uint8)1)
        {
            fillWindow(renderer, intBK);

            fadeImage(renderer, splashImage, (SCREEN_WIDTH - 800) / 2, (SCREEN_HEIGHT - 350) / 2, 800, 350, i);

            SDL_RenderPresent(renderer);

            SDL_Delay(5);
        }

        SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);
#endif

        fillWindow(renderer, intBK);

        fitImage(renderer, splashImage, (SCREEN_WIDTH - 800) / 2, (SCREEN_HEIGHT - 350) / 2, 800, 350);

        SDL_RenderPresent(renderer);

        SDL_Delay(3000);

        SDL_FreeSurface(splashImage);

        splashImage = NULL;
    }

    return false;
}

std::string characterText(Character::Base &character, bool compact)
{
    std::string character_text = "";

    if (!compact)
    {
        character_text = character.Background;
    }
    else
    {
        character_text = character.Name;

        if (character.Team != Team::Type::NONE)
        {
            if (!Engine::IS_CHARACTER(character.Team))
            {
                character_text += ", Team: " + std::string(Team::Descriptions[character.Team]);
            }
        }

        if (character.SpellCaster)
        {
            character_text += ", SpellCaster";
        }
    }

    if (!compact)
    {
        character_text += "\n";
    }

    character_text += "\n";

    for (auto i = 0; i < character.Attributes.size(); i++)
    {
        if (i > 0)
        {
            character_text += ", ";
        }

        auto raw_score = Engine::RAW_SCORE(character, character.Attributes[i].Type, true);

        auto mod_score = 0;

        character_text += std::string(Attribute::Descriptions[character.Attributes[i].Type]) + ": ";

        if (character.Attributes[i].Type == Attribute::Type::FIGHTING)
        {
            mod_score = Engine::FIGHTING_SCORE(character);
        }
        else
        {
            mod_score = Engine::SCORE(character, character.Attributes[i].Type);
        }

        if (!compact)
        {
            character_text += std::to_string(raw_score);

            if (mod_score != raw_score)
            {
                character_text += "(" + std::to_string(mod_score) + ")";
            }
        }
        else
        {
            if (raw_score > mod_score)
            {
                character_text += std::to_string(raw_score);
            }
            else
            {
                character_text += std::to_string(mod_score);
            }
        }
    }

    auto raw_health = character.Health;

    auto mod_health = Engine::HEALTH(character);

    character_text += ", Health: ";

    if (!compact)
    {
        character_text += std::to_string(raw_health);

        if (raw_health != mod_health)
        {
            character_text += "(" + std::to_string(mod_health) + ")";
        }
    }
    else
    {
        if (raw_health > mod_health)
        {
            character_text += std::to_string(raw_health);
        }
        else
        {
            character_text += std::to_string(mod_health);
        }
    }

    if (!compact && character.SpellCaster)
    {
        character_text += "\n\nSpellcaster";
    }

    return character_text;
};

std::vector<Button> attributeList(SDL_Window *window, SDL_Renderer *renderer, Character::Base &character, std::vector<Attribute::Type> &attributes, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (attributes.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            std::string attributes_string = std::string(Attribute::Descriptions[attributes[index]]);

            if (character.Type != Character::Type::NONE)
            {
                attributes_string += ": " + std::to_string(Engine::SCORE(character, attributes[index]));
            }

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 28, attributes_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (attributes.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (attributes.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/yes.png", idx, idx, attributes.size() > 0 ? (last - start) - 1 : idx, idx, textx, buttony, Control::Type::CONFIRM));

    return controls;
}

std::vector<Button> armyList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Army::Base> &army, int start, int last, int limit, int offsetx, int offsety, bool party_controls)
{
    auto controls = std::vector<Button>();

    if (army.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto unit = army[index];

            std::string army_string = "[" + unit.Name + "] Strength: " + std::to_string(unit.Strength) + ", Morale: " + std::to_string(unit.Morale);

            army_string += "\nPosition: " + std::string(Location::BattleFieldDescription[unit.Position]) + ", Garrison: " + std::string(Location::Description[unit.Garrison]);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, army_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (army.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (army.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    if (party_controls)
    {
        controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "ARMY", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, army.size() > 0 ? (last - start) - 1 : idx, idx, startx, text_buttony, Control::Type::ARMY));
        controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "FLEET", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, army.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::FLEET));
        controls.push_back(Button(idx + 2, createHeaderButton(window, FONT_DARK11, 22, "ROMANCE", clrWH, intDB, text_buttonw, 48, -1), idx + 1, idx + 3, army.size() > 0 ? (last - start) - 1 : idx + 2, idx + 2, startx + 2 * text_gridsize, text_buttony, Control::Type::ROMANCE));
        controls.push_back(Button(idx + 3, createHeaderButton(window, FONT_DARK11, 22, "BACK", clrWH, intDB, text_buttonw, 48, -1), idx + 2, idx + 3, army.size() > 0 ? (last - start) - 1 : idx + 3, idx + 3, startx + 3 * text_gridsize, text_buttony, Control::Type::BACK));
    }
    else
    {
        controls.push_back(Button(idx, "icons/yes.png", idx, idx + 1, army.size() > 0 ? (last - start) - 1 : idx, idx, textx, buttony, Control::Type::CONFIRM));
        controls.push_back(Button(idx + 1, "icons/back-button.png", idx, idx + 1, army.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, lastx, buttony, Control::Type::BACK));
    }

    return controls;
}

std::vector<Button> armyList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Army::Base> &army, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (army.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto unit = army[index];

            std::string army_string = "[" + unit.Name + "] Strength: " + std::to_string(unit.Strength) + ", Morale: " + std::to_string(unit.Morale);

            army_string += "\nPosition: " + std::string(Location::BattleFieldDescription[unit.Position]) + ", Garrison: " + std::string(Location::Description[unit.Garrison]);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, army_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (army.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (army.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/back-button.png", idx, idx, army.size() > 0 ? (last - start) - 1 : idx, idx, lastx, buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (ships.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto ship_string = shipString(ships[index], true);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, ship_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (ships.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (ships.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "ARMY", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, ships.size() > 0 ? (last - start) - 1 : idx, idx, startx, text_buttony, Control::Type::ARMY));
    controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "FLEET", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, ships.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::FLEET));
    controls.push_back(Button(idx + 2, createHeaderButton(window, FONT_DARK11, 22, "ROMANCE", clrWH, intDB, text_buttonw, 48, -1), idx + 1, idx + 3, ships.size() > 0 ? (last - start) - 1 : idx + 2, idx + 2, startx + 2 * text_gridsize, text_buttony, Control::Type::ROMANCE));
    controls.push_back(Button(idx + 3, createHeaderButton(window, FONT_DARK11, 22, "BACK", clrWH, intDB, text_buttonw, 48, -1), idx + 2, idx + 3, ships.size() > 0 ? (last - start) - 1 : idx + 3, idx + 3, startx + 3 * text_gridsize, text_buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> romanceList(SDL_Window *window, SDL_Renderer *renderer, std::map<Character::Romance, int> &hearts, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (hearts.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto heart = hearts.begin();

            std::advance(heart, index);

            Character::Romance romance = heart->first;

            auto from = Character::ALL[Engine::FIND_CHARACTER(Character::ALL, romance.first)];
            auto to = Character::ALL[Engine::FIND_CHARACTER(Character::ALL, romance.second)];

            auto count = heart->second;

            std::string ship_string = from.Name + " has " + std::to_string(count) + " heart";

            if (count > 1)
            {
                ship_string += "s";
            }

            ship_string += " for " + to.Name + ".";

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, ship_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (hearts.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (hearts.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "ARMY", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, hearts.size() > 0 ? (last - start) - 1 : idx, idx, startx, text_buttony, Control::Type::ARMY));
    controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "FLEET", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, hearts.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::FLEET));
    controls.push_back(Button(idx + 2, createHeaderButton(window, FONT_DARK11, 22, "ROMANCE", clrWH, intDB, text_buttonw, 48, -1), idx + 1, idx + 3, hearts.size() > 0 ? (last - start) - 1 : idx + 2, idx + 2, startx + 2 * text_gridsize, text_buttony, Control::Type::ROMANCE));
    controls.push_back(Button(idx + 3, createHeaderButton(window, FONT_DARK11, 22, "BACK", clrWH, intDB, text_buttonw, 48, -1), idx + 2, idx + 3, hearts.size() > 0 ? (last - start) - 1 : idx + 3, idx + 3, startx + 3 * text_gridsize, text_buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> teamsList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Team::Type> &teams, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (teams.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            std::string teams_string = std::string(Team::Descriptions[teams[index]]);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 28, teams_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (teams.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (teams.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/yes.png", idx, idx, teams.size() > 0 ? (last - start) - 1 : idx, idx, textx, buttony, Control::Type::CONFIRM));
    controls.push_back(Button(idx + 1, "icons/back-button.png", idx, idx + 1, teams.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, lastx, buttony, Control::Type::BACK));

    return controls;
}

bool partyDetails(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party)
{
    auto font_size = 28;

    TTF_Init();

    auto font_mason = TTF_OpenFont(FONT_MASON, 24);
    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, font_size);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

    TTF_SetFontKerning(font_dark11, 0);

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Party");

        auto current = 0;

        auto selected = false;

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (124);
        auto last = offset + limit;

        if (last > party.Army.size())
        {
            last = party.Army.size();
        }

        auto controls = armyList(window, renderer, party.Army, offset, last, limit, textx, (texty + infoh), true);

        auto current_mode = Control::Type::ARMY;

        auto scrollUp = false;
        auto scrollDown = false;
        auto scrollSpeed = 1;
        auto hold = false;

        auto done = false;

        auto fg = Color::HEADER(party.Book);

        while (!done)
        {
            fillWindow(renderer, intWH);

            putHeader(renderer, "Location", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty);
            putText(renderer, Location::Description[party.Location], font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + infoh);

            putHeader(renderer, "Money", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space - 1));
            putText(renderer, (std::to_string(party.Money) + std::string(" silver coins")).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + text_bounds - (3 * boxh + infoh + box_space));

            putHeader(renderer, "Party", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (Engine::ALIVE(party) > 0)
            {
                std::string party_string = "";

                auto count = 0;

                for (auto i = 0; i < party.Members.size(); i++)
                {
                    if (count > 0)
                    {
                        party_string += "\n";
                    }

                    party_string += party.Members[i].Name;

                    if (Engine::IS_DEAD(party.Members[i]))
                    {
                        party_string += " (D)";
                    }
                    else if (Engine::IS_CURSED(party.Members[i]))
                    {
                        party_string += " (C)";
                    }

                    count += 1;
                }

                putText(renderer, party_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            if (current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::ARMY)
                {
                    if (current_mode != Control::Type::ARMY)
                    {
                        offset = 0;

                        last = offset + limit;

                        if (last > party.Army.size())
                        {
                            last = party.Army.size();
                        }

                        controls = armyList(window, renderer, party.Army, offset, last, limit, textx, texty + infoh, true);

                        current = FIND_CONTROL(controls, Control::Type::ARMY);
                    }

                    current_mode = Control::Type::ARMY;
                }
                else if (controls[current].Type == Control::Type::FLEET)
                {
                    if (current_mode != Control::Type::FLEET)
                    {
                        offset = 0;

                        last = offset + limit;

                        if (last > party.Fleet.size())
                        {
                            last = party.Fleet.size();
                        }

                        controls = shipList(window, renderer, party.Fleet, offset, last, limit, textx, texty + infoh);

                        current = FIND_CONTROL(controls, Control::Type::FLEET);
                    }

                    current_mode = Control::Type::FLEET;
                }
                else if (controls[current].Type == Control::Type::ROMANCE)
                {
                    if (current_mode != Control::Type::ROMANCE)
                    {
                        offset = 0;

                        last = offset + limit;

                        if (last > party.Hearts.size())
                        {
                            last = party.Hearts.size();
                        }

                        controls = romanceList(window, renderer, party.Hearts, offset, last, limit, textx, texty + infoh);

                        current = FIND_CONTROL(controls, Control::Type::ROMANCE);
                    }

                    current_mode = Control::Type::ROMANCE;
                }
            }

            if (current_mode == Control::Type::ARMY)
            {
                putHeader(renderer, "Army", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (current_mode == Control::Type::FLEET)
            {
                putHeader(renderer, "Fleet", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (current_mode == Control::Type::ROMANCE)
            {
                putHeader(renderer, "Romance", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else
            {
                fillRect(renderer, textwidth, infoh, textx, texty, fg);
            }

            fillRect(renderer, textwidth, (text_bounds - infoh), textx, (texty + infoh), intBE);

            for (auto i = offset; i < last; i++)
            {
                auto index = i - offset;

                if (current != index)
                {
                    if (index >= 0 && index < controls.size())
                    {
                        drawRect(renderer, controls[index].W + (2 * text_space), controls[index].H + (2 * text_space), controls[index].X - text_space, controls[index].Y - text_space, intBK);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, border_space, border_pts);

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (current_mode == Control::Type::ARMY)
                        {
                            if (last > party.Army.size())
                            {
                                last = party.Army.size();
                            }

                            controls = armyList(window, renderer, party.Army, offset, last, limit, textx, texty + infoh, true);
                        }
                        else if (current_mode == Control::Type::FLEET)
                        {
                            if (last > party.Fleet.size())
                            {
                                last = party.Fleet.size();
                            }

                            controls = shipList(window, renderer, party.Fleet, offset, last, limit, textx, texty + infoh);
                        }
                        else if (current_mode == Control::Type::ROMANCE)
                        {
                            if (last > party.Hearts.size())
                            {
                                last = party.Hearts.size();
                            }

                            controls = romanceList(window, renderer, party.Hearts, offset, last, limit, textx, texty + infoh);
                        }

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (current_mode == Control::Type::ARMY)
                    {
                        if (party.Army.size() - last > 0)
                        {
                            if (offset < party.Army.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > party.Army.size() - limit)
                            {
                                offset = party.Army.size() - limit;
                            }

                            last = offset + limit;

                            if (last > party.Army.size())
                            {
                                last = party.Army.size();
                            }

                            controls = armyList(window, renderer, party.Army, offset, last, limit, textx, texty + infoh, true);

                            SDL_Delay(50);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (party.Army.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }
                    else if (current_mode == Control::Type::FLEET)
                    {
                        if (party.Fleet.size() - last > 0)
                        {
                            if (offset < party.Fleet.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > party.Fleet.size() - limit)
                            {
                                offset = party.Fleet.size() - limit;
                            }

                            last = offset + limit;

                            if (last > party.Fleet.size())
                            {
                                last = party.Fleet.size();
                            }

                            controls = shipList(window, renderer, party.Fleet, offset, last, limit, textx, texty + infoh);

                            SDL_Delay(50);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (party.Fleet.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }
                    else if (current_mode == Control::Type::ROMANCE)
                    {
                        if (party.Hearts.size() - last > 0)
                        {
                            if (offset < party.Hearts.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > party.Hearts.size() - limit)
                            {
                                offset = party.Hearts.size() - limit;
                            }

                            last = offset + limit;

                            if (last > party.Hearts.size())
                            {
                                last = party.Hearts.size();
                            }

                            controls = romanceList(window, renderer, party.Hearts, offset, last, limit, textx, texty + infoh);

                            SDL_Delay(50);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (party.Hearts.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }

                    SDL_Delay(50);

                    if (offset > 0)
                    {
                        current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                    }
                }
                else if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;
                }
            }
        }
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    TTF_Quit();

    return false;
}

bool viewParty(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, bool inCombat)
{
    SDL_Surface *adventurer = NULL;
    SDL_Texture *adventurerTexture = NULL;
    SDL_Surface *text = NULL;
    SDL_Surface *code_text = NULL;

    auto font_size = 20;
    auto garamond_size = 24;

    TTF_Init();

    auto font_mason = TTF_OpenFont(FONT_MASON, 24);
    auto font_mason2 = TTF_OpenFont(FONT_MASON, 22);
    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, garamond_size);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

    TTF_SetFontKerning(font_dark11, 0);

    auto character_box = (int)(text_bounds * 2 / 3);
    auto offset = 0;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: View Party");

        const char *choices[7] = {"PARTY", "PREVIOUS", "NEXT", "EQUIPMENT", "SPELLBOOK", "FOLLOWERS", "BACK"};

        auto current = 2;

        auto selected = false;

        auto controls = createHTextButtons(choices, 7, text_buttonh, startx, text_buttony, true);

        controls[0].X = scrollx;
        controls[0].Y = texty + border_space;
        controls[1].X = scrollx;
        controls[1].Y = scrolly;
        controls[2].Type = Control::Type::PARTY;
        controls[3].Type = Control::Type::PREVIOUS;
        controls[4].Type = Control::Type::NEXT;
        controls[5].Type = Control::Type::EQUIPMENT;
        controls[6].Type = Control::Type::SPELLBOOK;
        controls[7].Type = Control::Type::FOLLOWERS;
        controls[8].Type = Control::Type::BACK;

        auto done = false;

        auto character = 0;

        auto current_mode = Control::Type::PARTY;

        if (character >= 0 && character < party.Members.size())
        {
            if (party.Members[character].Image.length() > 0)
            {
                if (adventurer)
                {
                    SDL_FreeSurface(adventurer);

                    adventurer = NULL;
                }

                if (adventurerTexture)
                {
                    SDL_DestroyTexture(adventurerTexture);

                    adventurerTexture = NULL;
                }

                adventurer = createImage(party.Members[character].Image.c_str());

                if (adventurer)
                {
                    adventurerTexture = SDL_CreateTextureFromSurface(renderer, adventurer);
                }
            }

            if (text)
            {
                SDL_FreeSurface(text);

                text = NULL;
            }

            text = createText(characterText(party.Members[character], false).c_str(), FONT_GARAMOND, garamond_size, clrDB, listwidth, TTF_STYLE_NORMAL);
        }

        if (party.Codes.size() > 0)
        {
            sort(party.Codes.begin(), party.Codes.end());

            std::string code_string = "";

            for (auto i = 0; i < party.Codes.size(); i++)
            {
                if (i > 0)
                {
                    code_string += ", ";
                }

                code_string += std::string(Codes::Prefix[party.Codes[i].Type]) + std::to_string(party.Codes[i].Code);
            }

            code_text = createText(code_string.c_str(), FONT_MASON, 24, clrBK, listwidth, TTF_STYLE_NORMAL);
        }

        auto compact = (code_text && code_text->h <= text_bounds - infoh - 2 * text_space) || !code_text;

        auto fg = Color::HEADER(party.Book);

        while (!done)
        {
            fillWindow(renderer, intWH);

            auto adventurerh = splashw;

            if (current_mode != Control::Type::PARTY)
            {
                if (adventurer)
                {
                    adventurerh = fitImage(renderer, adventurer, startx, starty, splashw, text_bounds);
                }
                else
                {
                    adventurerh = starty - infoh + text_space;
                }
            }
            else
            {
                putHeader(renderer, "Location", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty);
                putText(renderer, Location::Description[party.Location], font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + infoh);

                putHeader(renderer, "Money", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space - 1));
                putText(renderer, (std::to_string(party.Money) + std::string(" silver coins")).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + text_bounds - (3 * boxh + infoh + box_space));

                putHeader(renderer, "Party", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

                if (Engine::ALIVE(party) > 0)
                {
                    std::string party_string = "";

                    auto count = 0;

                    for (auto i = 0; i < party.Members.size(); i++)
                    {
                        if (count > 0)
                        {
                            party_string += "\n";
                        }

                        party_string += party.Members[i].Name;

                        if (Engine::IS_DEAD(party.Members[i]))
                        {
                            party_string += " (D)";
                        }
                        else if (Engine::IS_CURSED(party.Members[i]))
                        {
                            party_string += " (C)";
                        }

                        count += 1;
                    }

                    putText(renderer, party_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }

                putHeader(renderer, "Codes", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

                fillRect(renderer, textwidth, (text_bounds - infoh), textx, (texty + infoh), intBE);

                if (code_text)
                {
                    renderText(renderer, code_text, intBE, textx + text_space, texty + infoh + text_space, text_bounds - infoh - 2 * text_space, offset);
                }
            }

            if (current_mode != Control::Type::PARTY && text)
            {
                fillRect(renderer, textwidth, character_box, textx, texty, intBE);

                renderText(renderer, text, intBE, textx + text_space, texty + text_space, character_box - 2 * text_space, 0);
            }

            if (current_mode != Control::Type::PARTY && character >= 0 && character < party.Members.size())
            {
                putText(renderer, party.Members[character].Name.c_str(), font_mason, -1, clrDB, intWH, TTF_STYLE_NORMAL, splashw, infoh, startx, adventurerh + infoh - text_space);
            }

            if (current_mode != Control::Type::PARTY && character >= 0 && character < party.Members.size())
            {
                if ((party.Members[character].Status.size() > 0) || (party.Members[character].Team != Team::Type::NONE && !Engine::IS_CHARACTER(party.Members[character].Team)))
                {
                    putHeader(renderer, "Status", font_mason2, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, starty + character_box + 10);

                    std::string status_string = "";

                    for (auto i = 0; i < party.Members[character].Status.size(); i++)
                    {
                        if (i > 0)
                        {
                            status_string += ", ";
                        }

                        status_string += Character::StatusDescriptions[party.Members[character].Status[i]];
                    }

                    if (party.Members[character].Team != Team::Type::NONE)
                    {
                        if (!Engine::IS_CHARACTER(party.Members[character].Team))
                        {
                            if (status_string.length() > 0)
                            {
                                status_string += ", ";
                            }

                            status_string += std::string(Team::Descriptions[party.Members[character].Team]);

                            if (party.Members[character].Team != Team::Type::SOLO)
                            {
                                status_string += " team";
                            }
                        }
                    }

                    putText(renderer, status_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, textwidth, (text_bounds - character_box) - infoh - box_space, textx, starty + text_bounds + infoh - (text_bounds - character_box) + box_space);
                }
            }

            if (current_mode != Control::Type::PARTY)
            {
                if (current_mode == Control::Type::SPELLBOOK && party.Members[character].SpellCaster && party.Members[character].SpellBook.size() > 0)
                {
                    putHeader(renderer, "SPELLBOOK", font_mason2, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, starty + character_box + 10);

                    std::string spellbook_string = "";

                    for (auto i = 0; i < party.Members[character].SpellBook.size(); i++)
                    {
                        if (i > 0)
                        {
                            spellbook_string += ", ";
                        }

                        spellbook_string += party.Members[character].SpellBook[i].Name;
                    }

                    putText(renderer, spellbook_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, textwidth, (text_bounds - character_box) - infoh - box_space, textx, starty + text_bounds + infoh - (text_bounds - character_box) + box_space);
                }
                else if (current_mode == Control::Type::EQUIPMENT && party.Members[character].Equipment.size() > 0)
                {
                    putHeader(renderer, "EQUIPMENT", font_mason2, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, starty + character_box + 10);

                    std::string equipment_string = "";

                    for (auto i = 0; i < party.Members[character].Equipment.size(); i++)
                    {
                        if (i > 0)
                        {
                            equipment_string += ", ";
                        }

                        equipment_string += itemString(party.Members[character].Equipment[i]);
                    }

                    putText(renderer, equipment_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, textwidth, (text_bounds - character_box) - infoh - box_space, textx, starty + text_bounds + infoh - (text_bounds - character_box) + box_space);
                }
                else if (current_mode == Control::Type::FOLLOWERS && party.Members[character].Followers.size() > 0)
                {
                    putHeader(renderer, "FOLLOWERS", font_mason2, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, starty + character_box + 10);

                    std::string followers_string = "";

                    for (auto i = 0; i < party.Members[character].Followers.size(); i++)
                    {
                        if (i > 0)
                        {
                            followers_string += ", ";
                        }

                        followers_string += party.Members[character].Followers[i].Name + " (Health: " + std::to_string(party.Members[character].Followers[i].Health) + ")";
                    }

                    putText(renderer, followers_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, textwidth, (text_bounds - character_box) - infoh - box_space, textx, starty + text_bounds + infoh - (text_bounds - character_box) + box_space);
                }
            }

            renderTextButtons(renderer, controls, FONT_DARK11, current, clrWH, intDB, intLB, font_size + 2, scrollx, scrolly, ((current_mode != Control::Type::PARTY || compact) ? true : false), TTF_STYLE_NORMAL);

            auto scrollUp = false;
            auto scrollDown = false;
            auto hold = false;
            auto scrollSpeed = 20;

            if (adventurer && current_mode != Control::Type::PARTY)
            {
                auto mousex = 0;
                auto mousey = 0;

                SDL_GetMouseState(&mousex, &mousey);

                auto zoomw = (int)(0.80 * (double)textwidth);
                auto zoomh = (int)(0.80 * (double)text_bounds);

                clipValue(zoomw, 0, adventurer->w);
                clipValue(zoomh, 0, adventurer->h);

                auto boundx = splashw;

                if (adventurerh == text_bounds)
                {
                    boundx = (int)((double)adventurerh / adventurer->h * (double)adventurer->w);
                }

                if (mousex >= startx && mousex <= (startx + boundx) && mousey >= starty && mousey <= (starty + adventurerh))
                {
                    auto scalex = (double)(mousex - startx) / boundx;
                    auto scaley = (double)(mousey - starty) / adventurerh;

                    auto centerx = (int)(scalex * (double)adventurer->w);
                    auto centery = (int)(scaley * (double)adventurer->h);

                    clipValue(centerx, zoomw / 2, adventurer->w - zoomw / 2);
                    clipValue(centery, zoomh / 2, adventurer->h - zoomh / 2);

                    if (adventurerTexture)
                    {
                        SDL_Rect src;

                        src.w = zoomw;
                        src.h = zoomh;
                        src.x = centerx - zoomw / 2;
                        src.y = centery - zoomh / 2;

                        SDL_Rect dst;

                        dst.w = zoomw;
                        dst.h = zoomh;
                        dst.x = (textx + (textwidth - zoomw) / 2);
                        dst.y = (texty + (text_bounds - zoomh) / 2);

                        fillRect(renderer, dst.w, dst.h, dst.x, dst.y, intWH);
                        SDL_RenderCopy(renderer, adventurerTexture, &src, &dst);
                        drawRect(renderer, dst.w + 2, dst.h + 2, dst.x - 1, dst.y - 1, intBK);
                    }
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if (current == 2)
            {
                current_mode = Control::Type::PARTY;
            }
            else if (current > 2)
            {
                if (current > 2 && current < controls.size() && controls[current].Type != Control::Type::BACK)
                {
                    current_mode = controls[current].Type;
                }
            }

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (code_text)
                    {
                        if (offset > 0)
                        {
                            offset -= scrollSpeed;
                        }

                        if (offset < 0)
                        {
                            offset = 0;
                        }
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (code_text)
                    {
                        if (code_text->h >= text_bounds - 2 * text_space - infoh)
                        {
                            if (offset < code_text->h - text_bounds + 2 * text_space + infoh)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > code_text->h - text_bounds + 2 * text_space + infoh)
                            {
                                offset = code_text->h - text_bounds + 2 * text_space + infoh;
                            }
                        }
                    }
                }
                else if (controls[current].Type == Control::Type::PARTY && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    partyDetails(window, renderer, party);

                    done = false;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::PREVIOUS && !hold)
                {
                    if (character > 0)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        character -= 1;

                        if (character >= 0 && character < party.Members.size())
                        {
                            if (adventurer)
                            {
                                SDL_FreeSurface(adventurer);

                                adventurer = NULL;
                            }

                            if (adventurerTexture)
                            {
                                SDL_DestroyTexture(adventurerTexture);

                                adventurerTexture = NULL;
                            }

                            if (text)
                            {
                                SDL_FreeSurface(text);

                                text = NULL;
                            }

                            if (party.Members[character].Image.length() > 0)
                            {
                                adventurer = createImage(party.Members[character].Image.c_str());

                                if (adventurer)
                                {
                                    adventurerTexture = SDL_CreateTextureFromSurface(renderer, adventurer);
                                }
                            }

                            text = createText(characterText(party.Members[character], false).c_str(), FONT_GARAMOND, garamond_size, clrDB, listwidth, TTF_STYLE_NORMAL);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);
                    }
                }
                else if (controls[current].Type == Control::Type::NEXT && !hold)
                {
                    if (character < party.Members.size() - 1)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        character += 1;

                        if (character >= 0 && character < party.Members.size())
                        {
                            if (adventurer)
                            {
                                SDL_FreeSurface(adventurer);

                                adventurer = NULL;
                            }

                            if (adventurerTexture)
                            {
                                SDL_DestroyTexture(adventurerTexture);

                                adventurerTexture = NULL;
                            }

                            if (text)
                            {
                                SDL_FreeSurface(text);

                                text = NULL;
                            }

                            if (party.Members[character].Image.length() > 0)
                            {
                                adventurer = createImage(party.Members[character].Image.c_str());

                                if (adventurer)
                                {
                                    adventurerTexture = SDL_CreateTextureFromSurface(renderer, adventurer);
                                }
                            }

                            text = createText(characterText(party.Members[character], false).c_str(), FONT_GARAMOND, garamond_size, clrDB, listwidth, TTF_STYLE_NORMAL);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);
                    }
                }
                else if (controls[current].Type == Control::Type::EQUIPMENT && !hold)
                {
                    if (Engine::IS_ACTIVE(party, character))
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        inventoryScreen(window, renderer, party, team, party.Members[character], -1, inCombat);
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::SPELLBOOK && !hold)
                {
                    if (party.Members[character].SpellCaster && party.Members[character].SpellBook.size() > 0 && !inCombat)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        spellBook(window, renderer, party, party.Members[character], party.Members[character].SpellBookLimit);
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;
                }
            }
        }
    }

    if (adventurer)
    {
        SDL_FreeSurface(adventurer);

        adventurer = NULL;
    }

    if (adventurerTexture)
    {
        SDL_DestroyTexture(adventurerTexture);

        adventurerTexture = NULL;
    }

    if (text)
    {
        SDL_FreeSurface(text);

        text = NULL;
    }

    if (code_text)
    {
        SDL_FreeSurface(code_text);

        code_text = NULL;
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    if (font_mason2)
    {
        TTF_CloseFont(font_mason2);

        font_mason2 = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    TTF_Quit();

    return false;
}

bool recruitAdventurer(SDL_Window *window, SDL_Renderer *renderer, Book::Type bookID, Party::Base &party, int recruitmentPrice)
{
    SDL_Surface *adventurer = NULL;
    SDL_Surface *text = NULL;

    auto font_size = 20;
    auto garamond_size = 24;

    TTF_Init();

    auto font_mason = TTF_OpenFont(FONT_MASON, 32);
    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, garamond_size);
    auto character_box = (int)(text_bounds * 2 / 3);

    auto flash_message = false;

    auto flash_color = intRD;

    std::string message = "";

    Uint32 start_ticks = 0;

    Uint32 duration = 3000;

    auto displayMessage = [&](std::string msg, Uint32 color)
    {
        flash_message = true;

        message = msg;

        flash_color = color;

        start_ticks = SDL_GetTicks();
    };

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Recruit adventuerer for your party");

        std::string recruitment_string = std::string("RECRUIT");

        if (recruitmentPrice >= 0)
        {
            recruitment_string += "(";

            if (recruitmentPrice > 0)
            {
                recruitment_string += std::to_string(recruitmentPrice);
            }
            else
            {
                recruitment_string += "Free";
            }

            recruitment_string += ")";
        }

        const char *choices[4] = {"PREVIOUS", "NEXT", recruitment_string.c_str(), "BACK"};

        auto current = -1;

        auto selected = false;

        auto controls = createHTextButtons(choices, 4, text_buttonh, startx, text_buttony);
        controls[0].Type = Control::Type::PREVIOUS;
        controls[1].Type = Control::Type::NEXT;
        controls[2].Type = Control::Type::RECRUIT;
        controls[3].Type = Control::Type::BACK;

        auto done = false;

        std::vector<Character::Base> characters = {};

        if (bookID == Book::Type::BOOK1)
        {
            for (auto i = 0; i < Character::BOOK1.size(); i++)
            {
                if ((Engine::FIND_LIST(party.Dead, Character::BOOK1[i].Type) < 0) && !Engine::IN_PARTY(party, Character::BOOK1[i].Type))
                {
                    characters.push_back(Character::BOOK1[i]);
                }
            }
        }

        auto character = 0;

        if (character >= 0 && character < characters.size())
        {
            if (characters[character].Image.length() > 0)
            {
                if (adventurer)
                {
                    SDL_FreeSurface(adventurer);

                    adventurer = NULL;
                }

                adventurer = createImage(characters[character].Image.c_str());
            }

            if (text)
            {
                SDL_FreeSurface(text);

                text = NULL;
            }

            text = createText(characterText(characters[character], false).c_str(), FONT_GARAMOND, garamond_size, clrDB, listwidth, TTF_STYLE_NORMAL);
        }

        if (characters.size() > 0)
        {
            while (!done)
            {
                fillWindow(renderer, intWH);

                auto adventurerh = splashw;

                if (adventurer)
                {
                    adventurerh = fitImage(renderer, adventurer, startx, starty, splashw, text_bounds);
                }

                fillRect(renderer, textwidth, character_box, textx, texty, intBE);

                if (text)
                {
                    renderText(renderer, text, intBE, textx + text_space, texty + text_space, character_box, 0);
                }

                if (character >= 0 && character < characters.size() && adventurer)
                {
                    putText(renderer, characters[character].Name.c_str(), font_mason, -1, clrDB, intWH, TTF_STYLE_NORMAL, splashw, infoh, startx, adventurerh + infoh - text_space);
                }

                renderTextButtons(renderer, controls, FONT_MASON, current, clrWH, intDB, intLB, font_size + 2, TTF_STYLE_NORMAL);

                auto scrollUp = false;
                auto scrollDown = false;
                auto hold = false;

                if (flash_message)
                {
                    if ((SDL_GetTicks() - start_ticks) < duration)
                    {
                        putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                    }
                    else
                    {
                        flash_message = false;
                    }
                }

                Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

                if (selected && current >= 0 && current < controls.size())
                {
                    if (controls[current].Type == Control::Type::PREVIOUS && !hold)
                    {
                        if (character > 0)
                        {
                            character -= 1;
                        }

                        if (character >= 0 && character < characters.size())
                        {
                            if (characters[character].Image.length() > 0)
                            {
                                if (adventurer)
                                {
                                    SDL_FreeSurface(adventurer);

                                    adventurer = NULL;
                                }

                                adventurer = createImage(characters[character].Image.c_str());
                            }

                            if (text)
                            {
                                SDL_FreeSurface(text);

                                text = NULL;
                            }

                            text = createText(characterText(characters[character], false).c_str(), FONT_GARAMOND, garamond_size, clrDB, listwidth, TTF_STYLE_NORMAL);
                        }
                    }
                    else if (controls[current].Type == Control::Type::NEXT && !hold)
                    {
                        if (character < characters.size() - 1)
                        {
                            character += 1;
                        }

                        if (character >= 0 && character < characters.size())
                        {
                            if (characters[character].Image.length() > 0)
                            {
                                if (adventurer)
                                {
                                    SDL_FreeSurface(adventurer);

                                    adventurer = NULL;
                                }

                                adventurer = createImage(characters[character].Image.c_str());
                            }

                            if (text)
                            {
                                SDL_FreeSurface(text);

                                text = NULL;
                            }

                            text = createText(characterText(characters[character], false).c_str(), FONT_GARAMOND, garamond_size, clrDB, listwidth, TTF_STYLE_NORMAL);
                        }
                    }
                    else if (controls[current].Type == Control::Type::RECRUIT && !hold)
                    {
                        if (recruitmentPrice >= 0 && party.Money >= recruitmentPrice && party.Members.size() < party.Limit)
                        {
                            if (character >= 0 && character < characters.size())
                            {
                                Engine::GAIN_MONEY(party, -recruitmentPrice);

                                auto recruit = characters[character];

                                if (recruit.SpellCaster)
                                {
                                    // TODO: Update this for other books
                                    if (bookID == Book::Type::BOOK1)
                                    {
                                        auto spells_selected = 0;

                                        auto spell_selection = std::vector<int>();

                                        auto spellBook = Spells::BOOK1_SPELLS;

                                        while (spells_selected < 3)
                                        {
                                            spell_selection = selectSpell(window, renderer, bookID, recruit, spellBook, 3, Spells::Select::SPELLBOOK);

                                            spells_selected = spell_selection.size();
                                        }

                                        for (auto j = 0; j < spell_selection.size(); j++)
                                        {
                                            recruit.SpellBook.push_back(spellBook[spell_selection[j]]);
                                        }
                                    }
                                }

                                party.Members.push_back(recruit);

                                Engine::CONSOLIDATE(party);

                                party.CurrentCharacter = -1;

                                party.LastSelected = -1;

                                party.LastSelection.clear();

                                party.Order.clear();

                                done = true;

                                Sound::Play(Sound::Type::BUTTON_CLICK);
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("Please choose an adventurer to recruit!", intRD);
                            }
                        }
                        else if (recruitmentPrice < 0)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You cannot recruit adventurers here!", intRD);
                        }
                        else if (party.Money < recruitmentPrice)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have enough silver!", intRD);
                        }
                        else if (party.Members.size() >= party.Limit)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You already have full party!", intRD);
                        }
                    }
                    else if (controls[current].Type == Control::Type::BACK && !hold)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        done = true;
                    }
                }
            }
        }
    }

    if (adventurer)
    {
        SDL_FreeSurface(adventurer);

        adventurer = NULL;
    }

    if (text)
    {
        SDL_FreeSurface(text);

        text = NULL;
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    TTF_Quit();

    return false;
}

bool selectParty(SDL_Window *window, SDL_Renderer *renderer, Book::Type bookID, Party::Base &party)
{
    party.Members.clear();

    SDL_Surface *adventurer = NULL;
    SDL_Surface *text = NULL;

    auto font_size = 20;
    auto garamond_size = 24;

    TTF_Init();

    auto font_mason = TTF_OpenFont(FONT_MASON, 32);
    auto font_mason2 = TTF_OpenFont(FONT_MASON, 22);
    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, garamond_size);

    auto character_box = (int)(text_bounds * 2 / 3);

    auto flash_message = false;

    auto flash_color = intRD;

    std::string message = "";

    Uint32 start_ticks = 0;

    Uint32 duration = 3000;

    auto fg = Color::HEADER(bookID);

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Select adventurers for your party");

        const char *choices_add[6] = {"PREVIOUS", "NEXT", "ADD TO PARTY", "ABOUT", "START", "BACK"};
        const char *choices_del[6] = {"PREVIOUS", "NEXT", "REMOVE", "ABOUT", "START", "BACK"};

        auto current = -1;

        auto selected = false;

        auto controls_add = createHTextButtons(choices_add, 6, text_buttonh, startx, text_buttony);
        auto controls_del = createHTextButtons(choices_del, 6, text_buttonh, startx, text_buttony);

        controls_add[0].Type = Control::Type::PREVIOUS;
        controls_add[1].Type = Control::Type::NEXT;
        controls_add[2].Type = Control::Type::PLUS;
        controls_add[3].Type = Control::Type::ABOUT;
        controls_add[4].Type = Control::Type::NEW;
        controls_add[5].Type = Control::Type::BACK;

        controls_del[0].Type = Control::Type::PREVIOUS;
        controls_del[1].Type = Control::Type::NEXT;
        controls_del[2].Type = Control::Type::MINUS;
        controls_del[3].Type = Control::Type::ABOUT;
        controls_del[4].Type = Control::Type::NEW;
        controls_del[5].Type = Control::Type::BACK;

        std::vector<TextButton> *controls;

        auto done = false;

        auto Party = Party::Base();

        std::vector<Character::Base> characters = {};

        if (bookID == Book::Type::BOOK1)
        {
            characters = Character::BOOK1;
        }

        auto selection = std::vector<int>();

        auto character = 0;

        if (character >= 0 && character < characters.size())
        {
            if (characters[character].Image.length() > 0)
            {
                if (adventurer)
                {
                    SDL_FreeSurface(adventurer);

                    adventurer = NULL;
                }

                adventurer = createImage(characters[character].Image.c_str());
            }

            if (text)
            {
                SDL_FreeSurface(text);

                text = NULL;
            }

            text = createText(characterText(characters[character], false).c_str(), FONT_GARAMOND, garamond_size, clrDB, listwidth, TTF_STYLE_NORMAL);
        }

        while (!done)
        {
            fillWindow(renderer, intWH);

            auto adventurerh = splashw;

            if (adventurer)
            {
                adventurerh = fitImage(renderer, adventurer, startx, starty, splashw, text_bounds);
            }

            fillRect(renderer, textwidth, character_box, textx, texty, intBE);

            if (text)
            {
                renderText(renderer, text, intBE, textx + text_space, texty + text_space, character_box, 0);
            }

            if (character >= 0 && character < characters.size() && adventurer)
            {
                putText(renderer, characters[character].Name.c_str(), font_mason, -1, clrDB, intWH, TTF_STYLE_NORMAL, splashw, infoh, startx, adventurerh + infoh - text_space);
            }

            if (selection.size() > 0)
            {
                putHeader(renderer, std::string("PARTY (Limit: " + std::to_string(party.Limit) + ")").c_str(), font_mason2, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, starty + character_box + 10);

                std::string party_string = "";

                for (auto i = 0; i < selection.size(); i++)
                {
                    if (selection[i] >= 0 && selection[i] < characters.size())
                    {
                        if (i > 0)
                        {
                            party_string += ", ";
                        }

                        party_string += characters[selection[i]].Name;
                    }
                }

                putText(renderer, party_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, textwidth, (text_bounds - character_box) - infoh - box_space, textx, starty + text_bounds + infoh - (text_bounds - character_box) + box_space);
            }

            if (Engine::FIND_LIST(selection, character) >= 0)
            {
                renderTextButtons(renderer, controls_del, FONT_DARK11, current, clrWH, intDB, intLB, font_size + 2, TTF_STYLE_NORMAL);

                controls = &controls_del;
            }
            else
            {
                renderTextButtons(renderer, controls_add, FONT_DARK11, current, clrWH, intDB, intLB, font_size + 2, TTF_STYLE_NORMAL);

                controls = &controls_add;
            }

            auto scrollUp = false;
            auto scrollDown = false;
            auto hold = false;

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            if (Engine::FIND_LIST(selection, character) >= 0)
            {
                Input::GetInput(renderer, controls_del, current, selected, scrollUp, scrollDown, hold);
            }
            else
            {
                Input::GetInput(renderer, controls_add, current, selected, scrollUp, scrollDown, hold);
            }

            if (selected && current >= 0 && current < controls->size())
            {
                if (controls->at(current).Type == Control::Type::PREVIOUS && !hold)
                {
                    if (character > 0)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        character -= 1;

                        if (character >= 0 && character < characters.size())
                        {
                            if (characters[character].Image.length() > 0)
                            {
                                if (adventurer)
                                {
                                    SDL_FreeSurface(adventurer);

                                    adventurer = NULL;
                                }

                                adventurer = createImage(characters[character].Image.c_str());
                            }

                            if (text)
                            {
                                SDL_FreeSurface(text);

                                text = NULL;
                            }

                            text = createText(characterText(characters[character], false).c_str(), FONT_GARAMOND, garamond_size, clrDB, listwidth, TTF_STYLE_NORMAL);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);
                    }
                }
                else if (controls->at(current).Type == Control::Type::NEXT && !hold)
                {
                    if (character < characters.size() - 1)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        character += 1;

                        if (character >= 0 && character < characters.size())
                        {
                            if (characters[character].Image.length() > 0)
                            {
                                if (adventurer)
                                {
                                    SDL_FreeSurface(adventurer);

                                    adventurer = NULL;
                                }

                                adventurer = createImage(characters[character].Image.c_str());
                            }

                            if (text)
                            {
                                SDL_FreeSurface(text);

                                text = NULL;
                            }

                            text = createText(characterText(characters[character], false).c_str(), FONT_GARAMOND, garamond_size, clrDB, listwidth, TTF_STYLE_NORMAL);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);
                    }
                }
                else if (controls->at(current).Type == Control::Type::PLUS && !hold)
                {
                    if (selection.size() < party.Limit)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        selection.push_back(character);
                    }
                }
                else if (controls->at(current).Type == Control::Type::MINUS && !hold)
                {
                    if (selection.size() > 0)
                    {
                        auto result = Engine::FIND_LIST(selection, character);

                        if (result >= 0)
                        {
                            Sound::Play(Sound::Type::FAIL);

                            selection.erase(selection.begin() + result);
                        }
                    }
                }
                else if (controls->at(current).Type == Control::Type::NEW && !hold)
                {
                    if (selection.size() == party.Limit)
                    {
                        for (auto i = 0; i < selection.size(); i++)
                        {
                            if (selection[i] >= 0 && selection[i] < characters.size())
                            {
                                auto character = characters[selection[i]];

                                if (character.SpellCaster)
                                {
                                    // TODO: Update this for other books
                                    if (bookID == Book::Type::BOOK1)
                                    {
                                        auto spells_selected = 0;

                                        auto spell_selection = std::vector<int>();

                                        auto spellBook = Spells::BOOK1_SPELLS;

                                        while (spells_selected < 3)
                                        {
                                            spell_selection = selectSpell(window, renderer, bookID, character, spellBook, 3, Spells::Select::SPELLBOOK);

                                            spells_selected = spell_selection.size();
                                        }

                                        for (auto j = 0; j < spell_selection.size(); j++)
                                        {
                                            character.SpellBook.push_back(spellBook[spell_selection[j]]);
                                        }
                                    }
                                }

                                party.Members.push_back(character);
                            }
                        }

                        Sound::Play(Sound::Type::SUCCESS);

                        done = true;

                        current = -1;

                        selected = false;
                    }
                    else
                    {
                        flash_message = true;

                        message = "Please select up to 4 party members!";

                        start_ticks = SDL_GetTicks();

                        flash_color = intRD;

                        Sound::Play(Sound::Type::ERROR);
                    }
                }
                else if (controls->at(current).Type == Control::Type::ABOUT && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    encyclopediaScreen(window, renderer, bookID);
                }
                else if (controls->at(current).Type == Control::Type::BACK && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;
                }
            }
        }
    }

    if (adventurer)
    {
        SDL_FreeSurface(adventurer);

        adventurer = NULL;
    }

    if (text)
    {
        SDL_FreeSurface(text);

        text = NULL;
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    if (font_mason2)
    {
        TTF_CloseFont(font_mason2);

        font_mason2 = NULL;
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    TTF_Quit();

    return false;
}

bool mapScreen(SDL_Window *window, SDL_Renderer *renderer, Book::Type book)
{
    TTF_Init();

    auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);

    auto done = false;

    std::string book_map = "";

    if (book == Book::Type::BOOK1)
    {
        book_map = "images/book1/valley-of-bones-map.png";
    }
    else
    {
        book_map = "images/legendary-kingdoms-map-small.png";
    }

    auto map_local = createImage(book_map.c_str());
    auto map_world = createImage("images/legendary-kingdoms-map-small.png");

    auto texture_valley = SDL_CreateTextureFromSurface(renderer, map_local);
    auto texture_kingdom = SDL_CreateTextureFromSurface(renderer, map_world);

    auto current_map = 1;

    if (window && renderer && map_local && map_world)
    {
        auto selected = false;

        auto current = -1;

        auto controls = std::vector<Button>();
        controls.push_back(Button(0, "icons/scroll.png", 0, 1, 0, 0, startx, buttony, Control::Type::TOGGLE_MAP));
        controls.push_back(Button(1, "icons/back-button.png", 0, 1, 1, 1, (int)((1.0 - Margin) * SCREEN_WIDTH - buttonw), buttony, Control::Type::BACK));

        auto offset_x = 0;
        auto offset_y = 0;

        while (!done)
        {
            if (current_map == 1)
            {
                if (book == Book::Type::BOOK1)
                {
                    SDL_SetWindowTitle(window, "Map: The Valley of Bones");
                }
                else
                {
                    SDL_SetWindowTitle(window, "Map: Legendary Kingdoms");
                }
            }
            else
            {
                SDL_SetWindowTitle(window, "Map: Legendary Kingdoms");
            }

            if (current_map == 1)
            {
                offset_x = (fullwidth - (double)text_bounds / map_local->h * map_local->w) / 2;
                offset_y = ((SCREEN_HEIGHT) - (double)text_bounds / map_local->h * map_local->h) / 2;
            }
            else
            {
                offset_x = (fullwidth - (double)text_bounds / map_world->h * map_world->w) / 2;
                offset_y = ((SCREEN_HEIGHT) - (double)text_bounds / map_world->h * map_world->h) / 2;
            }

            fillWindow(renderer, intWH);

            if (current_map == 1)
            {
                fitImage(renderer, map_local, startx + offset_x, offset_y, fullwidth, text_bounds);
            }
            else
            {
                fitImage(renderer, map_world, startx + offset_x, offset_y, fullwidth, text_bounds);
            }

            renderButtons(renderer, controls, current, intLB, border_space, border_pts);

            auto scrollUp = false;
            auto scrollDown = false;
            auto hold = false;

            if (map_local && map_world)
            {
                auto mousex = 0;
                auto mousey = 0;

                SDL_GetMouseState(&mousex, &mousey);

                auto zoomw = (int)(0.40 * (double)(fullwidth - 2 * offset_x));
                auto zoomh = (int)(0.40 * (double)text_bounds);

                if (zoomw > zoomh)
                {
                    zoomw = zoomh;
                }
                else
                {
                    zoomh = zoomw;
                }

                if (current_map == 1)
                {
                    clipValue(zoomw, 0, map_local->w);
                    clipValue(zoomh, 0, map_local->h);
                }
                else
                {
                    clipValue(zoomw, 0, map_world->w);
                    clipValue(zoomh, 0, map_world->h);
                }

                auto boundx = startx + offset_x + fullwidth;

                if (current_map == 1)
                {
                    boundx = (int)((double)text_bounds / map_local->h * (double)map_local->w);
                }
                else
                {
                    boundx = (int)((double)text_bounds / map_world->h * (double)map_world->w);
                }

                if ((mousex >= startx + offset_x) && mousex <= (startx + offset_x + boundx) && mousey >= offset_y && mousey <= (offset_y + text_bounds))
                {
                    auto scalex = (double)(mousex - (startx + offset_x)) / boundx;
                    auto scaley = (double)(mousey - offset_y) / text_bounds;

                    auto centerx = (int)(scalex * (double)map_world->w);
                    auto centery = (int)(scaley * (double)map_world->h);

                    clipValue(centerx, zoomw / 2, map_world->w - zoomw / 2);
                    clipValue(centery, zoomh / 2, map_world->h - zoomh / 2);

                    if (current_map == 1)
                    {
                        centerx = (int)(scalex * (double)map_local->w);
                        centery = (int)(scaley * (double)map_local->h);

                        clipValue(centerx, zoomw / 2, map_local->w - zoomw / 2);
                        clipValue(centery, zoomh / 2, map_local->h - zoomh / 2);
                    }

                    if ((current_map == 1 && texture_valley) || (current_map == 0 && texture_kingdom))
                    {
                        SDL_Rect src;

                        src.w = zoomw;
                        src.h = zoomh;
                        src.x = centerx - zoomw / 2;
                        src.y = centery - zoomh / 2;

                        SDL_Rect dst;

                        dst.w = zoomw;
                        dst.h = zoomh;
                        dst.x = mousex + buttonw / 4;
                        dst.y = mousey - (buttonh / 4 + zoomh);

                        clipValue(dst.x, buttonw / 4, SCREEN_WIDTH - buttonw / 4 - zoomw);
                        clipValue(dst.y, buttonh / 4, SCREEN_HEIGHT - buttonh / 4 - zoomh);

                        if (current_map == 1)
                        {
                            SDL_RenderCopy(renderer, texture_valley, &src, &dst);
                        }
                        else
                        {
                            SDL_RenderCopy(renderer, texture_kingdom, &src, &dst);
                        }

                        drawRect(renderer, dst.w, dst.h, dst.x, dst.y, intBK);
                    }
                }
            }

            if (current >= 0 && current < controls.size() && !hold)
            {
                renderCaption(renderer, font_caption, controls[current]);
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if (selected && current >= 0 && current < controls.size() && controls[current].Type == Control::Type::BACK)
            {
                Sound::Play(Sound::Type::BUTTON_CLICK);

                done = true;
            }
            else if (selected && current >= 0 && current < controls.size() && controls[current].Type == Control::Type::TOGGLE_MAP)
            {
                Sound::Play(Sound::Type::BUTTON_CLICK);

                current_map = 1 - current_map;
            }
        }

        SDL_FreeSurface(map_local);
        SDL_FreeSurface(map_world);

        SDL_DestroyTexture(texture_valley);
        SDL_DestroyTexture(texture_kingdom);

        map_local = NULL;
        map_world = NULL;

        texture_valley = NULL;
        texture_kingdom = NULL;
    }

    if (font_caption)
    {
        TTF_CloseFont(font_caption);

        font_caption = NULL;
    }

    TTF_Quit();

    return done;
}

std::string itemString(Equipment::Base &equipment)
{
    std::string item_string = equipment.Name;

    if (equipment.TwoHanded)
    {
        item_string += "*";
    }

    if (equipment.Attribute != Attribute::Type::NONE || equipment.AdditionalSlots > 0)
    {
        item_string += " (";

        if (equipment.Attribute != Attribute::Type::NONE)
        {
            if (equipment.Attribute == Attribute::Type::FIGHTING3_LORE2)
            {
                item_string += std::string(Attribute::Descriptions[equipment.Attribute]);
            }
            else
            {
                item_string += "+" + std::to_string(equipment.Modifier) + " " + std::string(Attribute::Descriptions[equipment.Attribute]);
            }
        }

        if (equipment.AdditionalSlots > 0)
        {
            if (equipment.Attribute != Attribute::Type::NONE)
            {
                item_string += ", ";
            }

            item_string += std::to_string(equipment.AdditionalSlots + 1) + " slots";
        }

        item_string += ")";
    }

    return item_string;
}

std::vector<Button> equipmentList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Equipment::Base> list, int start, int last, int limit, bool confirm_button, bool back_button)
{
    auto font_size = 28;

    auto controls = std::vector<Button>();

    if (list.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto item_string = itemString(list[index]);

            auto text = createText(item_string.c_str(), FONT_GARAMOND, font_size, clrBK, textwidth - 4 * text_space, TTF_STYLE_NORMAL);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : texty + 2 * text_space);

            controls.push_back(Button(i, text, i, i, (i > 0 ? i - 1 : i), i + 1, textx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = textwidth - 4 * text_space;

            controls[i].H = text->h;
        }
    }

    auto idx = (int)controls.size();

    if (list.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (list.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    if (confirm_button)
    {
        idx = controls.size();

        controls.push_back(Button(idx, "icons/yes.png", idx - 1, (back_button ? idx + 1 : idx), (list.size() > 0 ? ((last - start) - 1) : idx), idx, textx, buttony, Control::Type::CONFIRM));
    }

    if (back_button)
    {
        idx = controls.size();

        controls.push_back(Button(idx, "icons/back-button.png", idx - 1, idx, (list.size() > 0 ? ((last - start) - 1) : idx), idx, lastx, buttony, Control::Type::BACK));
    }

    return controls;
}

std::vector<Button> equipmentList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Equipment::Base> list, int start, int last, int limit, int offsety, int scrolly)
{
    auto font_size = 28;

    auto controls = std::vector<Button>();

    if (list.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto item_string = itemString(list[index]);

            auto text = createText(item_string.c_str(), FONT_GARAMOND, font_size, clrBK, textwidth - 4 * text_space, TTF_STYLE_NORMAL);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, text, i, i, (i > 0 ? i - 1 : i), i + 1, textx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = textwidth - 4 * text_space;

            controls[i].H = text->h;
        }
    }

    auto idx = (int)controls.size();

    if (list.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (list.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/yes.png", idx, idx + 1, (list.size() > 0 ? ((last - start) - 1) : idx), idx, textx, buttony, Control::Type::USE));
    controls.push_back(Button(idx + 1, "icons/no.png", idx, idx + 2, (list.size() > 0 ? ((last - start) - 1) : idx + 1), idx + 1, textx + gridsize, buttony, Control::Type::DROP));
    controls.push_back(Button(idx + 2, "icons/interaction.png", idx + 1, idx + 3, (list.size() > 0 ? ((last - start) - 1) : idx + 2), idx + 2, textx + 2 * gridsize, buttony, Control::Type::TRANSFER));
    controls.push_back(Button(idx + 3, "icons/vault.png", idx + 2, idx + 4, (list.size() > 0 ? ((last - start) - 1) : idx + 3), idx + 3, textx + 3 * gridsize, buttony, Control::Type::VAULT));
    controls.push_back(Button(idx + 4, "icons/back-button.png", idx + 3, idx + 4, (list.size() > 0 ? ((last - start) - 1) : idx + 4), idx + 4, lastx, buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> vaultList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Equipment::Base> list, int start, int last, int limit, int offsety, int scrolly)
{
    auto font_size = 28;

    auto controls = std::vector<Button>();

    if (list.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto item_string = itemString(list[index]);

            auto text = createText(item_string.c_str(), FONT_GARAMOND, font_size, clrBK, textwidth - 4 * text_space, TTF_STYLE_NORMAL);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, text, i, i, (i > 0 ? i - 1 : i), i + 1, textx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = textwidth - 4 * text_space;

            controls[i].H = text->h;
        }
    }

    auto idx = (int)controls.size();

    if (list.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (list.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/yes.png", idx, idx + 1, (list.size() > 0 ? ((last - start) - 1) : idx), idx, textx, buttony, Control::Type::USE));
    controls.push_back(Button(idx + 1, "icons/interaction.png", idx, idx + 2, (list.size() > 0 ? ((last - start) - 1) : idx + 1), idx + 1, textx + gridsize, buttony, Control::Type::TRANSFER));
    controls.push_back(Button(idx + 2, "icons/shop.png", idx + 1, idx + 3, (list.size() > 0 ? ((last - start) - 1) : idx + 2), idx + 2, textx + 2 * gridsize, buttony, Control::Type::MONEY));
    controls.push_back(Button(idx + 3, "icons/back-button.png", idx + 2, idx + 3, (list.size() > 0 ? ((last - start) - 1) : idx + 3), idx + 3, lastx, buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> spellList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Spells::Base> &spells, int start, int last, int limit, int offsetx, int offsety, int scrolly, bool confirm_button, bool back_button)
{
    auto controls = std::vector<Button>();

    if (spells.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto spell = spells[index];

            std::string spell_string = "";

            spell_string += spell.Name;

            spell_string += "\nType: " + std::string(Spells::ScopeDescriptions[spell.Scope]) + ", Charged: " + std::string(spell.Charged ? "Yes" : "No") + ", Recharge: " + std::to_string(spell.Recharge);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, spell_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (spells.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (spells.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    if (confirm_button)
    {
        idx = controls.size();

        controls.push_back(Button(idx, "icons/yes.png", idx - 1, (back_button ? idx + 1 : idx), spells.size() > 0 ? (last - start) - 1 : idx, idx, textx, buttony, Control::Type::CONFIRM));
    }

    if (back_button)
    {
        idx = controls.size();

        controls.push_back(Button(idx, "icons/back-button.png", idx - 1, idx, spells.size() > 0 ? (last - start) - 1 : idx, idx, lastx, buttony, Control::Type::BACK));
    }

    return controls;
}

std::vector<Button> spellList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Spells::Base> &spells, int start, int last, int limit, int offsetx, int offsety, int scrolly)
{
    auto controls = std::vector<Button>();

    if (spells.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto spell = spells[index];

            std::string spell_string = "";

            spell_string += spell.Name;

            spell_string += "\nType: " + std::string(Spells::ScopeDescriptions[spell.Scope]) + ", Charged: " + std::string(spell.Charged ? "Yes" : "No") + ", Recharge: " + std::to_string(spell.Recharge);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, spell_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (spells.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (spells.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    controls.push_back(Button(idx, "icons/yes.png", idx, idx + 1, (spells.size() > 0 ? ((last - start) - 1) : idx), idx, textx, buttony, Control::Type::SPELL));
    controls.push_back(Button(idx + 1, "icons/no.png", idx, idx + 2, (spells.size() > 0 ? ((last - start) - 1) : idx + 1), idx + 1, textx + gridsize, buttony, Control::Type::UNLEARN));
    controls.push_back(Button(idx + 2, "icons/back-button.png", idx + 1, idx + 2, (spells.size() > 0 ? ((last - start) - 1) : idx + 2), idx + 2, lastx, buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> rechargeList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Spells::Base> &spells, int start, int last, int limit, int offsetx, int offsety, int scrolly)
{
    auto controls = std::vector<Button>();

    if (spells.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto spell = spells[index];

            std::string spell_string = "";

            spell_string += spell.Name;

            spell_string += "\nType: " + std::string(Spells::ScopeDescriptions[spell.Scope]) + ", Charged: " + std::string(spell.Charged ? "Yes" : "No") + ", Recharge: " + std::to_string(spell.Recharge);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, spell_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (spells.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (spells.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    controls.push_back(Button(idx, "icons/yes.png", idx, idx + 1, (spells.size() > 0 ? ((last - start) - 1) : idx), idx, textx, buttony, Control::Type::RECHARGE));
    controls.push_back(Button(idx + 1, "icons/back-button.png", idx, idx + 1, (spells.size() > 0 ? ((last - start) - 1) : idx + 1), idx + 1, lastx, buttony, Control::Type::BACK));

    return controls;
}

std::string shipString(Ship::Base &ship, bool cargo)
{
    std::string ship_string = "";

    if (!cargo)
    {
        ship_string = "[" + ship.Name + "]";

        ship_string += "\nFighting: " + (ship.Fighting > 0 ? std::to_string(ship.Fighting) : std::string("Special"));

        ship_string += " Health: " + std::to_string(ship.Health);
    }
    else
    {
        ship_string = "[" + ship.Name + "] Fighting: " + std::to_string(ship.Fighting) + ", Health: " + std::to_string(ship.Health) + ", Cargo Units: " + std::to_string(ship.MaximumCargo);

        ship_string += "\nLocation: " + std::string(Location::Description[ship.Location]);
    }

    if (cargo)
    {
        if (ship.Cargo.size() > 0)
        {
            ship_string += " Cargo: ";

            for (auto i = 0; i < ship.Cargo.size(); i++)
            {
                if (i > 0)
                {
                    ship_string += ", ";
                }

                ship_string += Cargo::Description[ship.Cargo[i]];
            }
        }
    }

    return ship_string;
}

std::string monsterString(Monster::Base &monster)
{
    std::string monster_string = monster.Name;

    monster_string += "\nAttack: " + (monster.Attack > 0 ? std::to_string(monster.Attack) : std::string("Special")) + std::string(monster.Difficulty > 0 ? (" (" + std::to_string(monster.Difficulty) + "+)") : "");

    if (monster.Auto > 0)
    {
        monster_string += " +" + std::to_string(monster.Auto) + " Auto";
    }

    monster_string += ", Defense: " + std::to_string(monster.Defence) + "+, Health: " + std::to_string(monster.Health);

    return monster_string;
}

std::vector<Button> monsterList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Monster::Base> &monsters, int start, int last, int limit, int offsetx, int offsety, bool confirm_button, bool back_button)
{
    auto controls = std::vector<Button>();

    if (monsters.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto monster = monsters[index];

            std::string monster_string = monsterString(monster);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, monster_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (monsters.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (monsters.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    if (confirm_button)
    {
        idx = controls.size();

        controls.push_back(Button(idx, "icons/yes.png", idx - 1, (back_button ? idx + 1 : idx), monsters.size() > 0 ? (last - start) - 1 : idx, idx, textx, buttony, Control::Type::CONFIRM));
    }

    if (back_button)
    {
        idx = controls.size();

        controls.push_back(Button(idx, "icons/back-button.png", idx - 1, idx, monsters.size() > 0 ? (last - start) - 1 : idx, idx, lastx, buttony, Control::Type::BACK));
    }

    return controls;
}

std::vector<Button> monsterList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Monster::Base> &monsters, int start, int last, int limit, int offsetx, int offsety, Control::Type mode)
{
    auto controls = std::vector<Button>();

    if (monsters.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto monster = monsters[index];

            std::string monster_string = monsterString(monster);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, monster_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (monsters.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (monsters.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "VIEW PARTY", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, monsters.size() > 0 ? (last - start) - 1 : idx, idx, startx, text_buttony, Control::Type::PARTY));

    if (mode == Control::Type::ATTACK)
    {
        controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "ATTACK", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, monsters.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::ATTACK));
    }
    else if (mode == Control::Type::DEFEND)
    {
        controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "DEFEND", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, monsters.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::ATTACK));
    }
    else if (mode == Control::Type::NEXT)
    {
        controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "NEXT ROUND", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, monsters.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::ATTACK));
    }

    controls.push_back(Button(idx + 2, createHeaderButton(window, FONT_DARK11, 22, "CAST SPELL", clrWH, intDB, text_buttonw, 48, -1), idx + 1, idx + 3, monsters.size() > 0 ? (last - start) - 1 : idx + 2, idx + 2, startx + 2 * text_gridsize, text_buttony, Control::Type::SPELL));

    controls.push_back(Button(idx + 3, createHeaderButton(window, FONT_DARK11, 22, "FLEE", clrWH, intDB, text_buttonw, 48, -1), idx + 2, idx + 3, monsters.size() > 0 ? (last - start) - 1 : idx + 3, idx + 3, startx + 3 * text_gridsize, text_buttony, Control::Type::FLEE));

    return controls;
}

std::vector<Button> combatantList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Character::Base> party, int start, int last, int limit, int offsetx, int offsety, bool confirm_button, bool back_button)
{
    auto controls = std::vector<Button>();

    if (party.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto adventurer = party[index];

            std::string adventurer_string = characterText(adventurer, true);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, adventurer_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), ((i < (last - start) - 1) ? i + 1 : ((back_button || confirm_button) ? i + 1 : i)), offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (party.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (party.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    if (confirm_button)
    {
        idx = controls.size();

        controls.push_back(Button(idx, "icons/yes.png", idx, back_button ? idx + 1 : idx, party.size() > 0 ? (last - start) - 1 : idx, idx, textx, buttony, Control::Type::CONFIRM));
    }

    if (back_button)
    {
        idx = controls.size();

        controls.push_back(Button(idx, "icons/back-button.png", confirm_button ? idx - 1 : idx, idx, party.size() > 0 ? (last - start) - 1 : idx, idx, lastx, buttony, Control::Type::BACK));
    }

    return controls;
}

std::vector<Button> restList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Character::Base> party, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (party.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto adventurer = party[index];

            std::string adventurer_string = characterText(adventurer, true);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, adventurer_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (party.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (party.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "HEAL 1", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, party.size() > 0 ? (last - start) - 1 : idx, idx, startx, text_buttony, Control::Type::HEAL1));
    controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "FULLY RECOVER", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, party.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::FULL_RECOVERY));
    controls.push_back(Button(idx + 2, createHeaderButton(window, FONT_DARK11, 22, "RECHARGE SPELLS", clrWH, intDB, text_buttonw, 48, -1), idx + 1, idx + 3, party.size() > 0 ? (last - start) - 1 : idx + 2, idx + 2, startx + 2 * text_gridsize, text_buttony, Control::Type::RECHARGE));
    controls.push_back(Button(idx + 3, createHeaderButton(window, FONT_DARK11, 22, "BACK", clrWH, intDB, text_buttonw, 48, -1), idx + 2, idx + 3, party.size() > 0 ? (last - start) - 1 : idx + 3, idx + 3, startx + 3 * text_gridsize, text_buttony, Control::Type::BACK));

    return controls;
}

int armourSave(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Character::Base &character, int damage)
{
    auto combat_damage = damage;
    auto final_damage = damage;

    if (Engine::IS_ALIVE(character) && Engine::ARMOUR(character) > 0)
    {
        if (window && renderer)
        {
            auto flash_message = false;

            auto flash_color = intRD;

            std::string message = "";

            Uint32 start_ticks = 0;

            Uint32 duration = 3000;

            auto headerw = (int)(boxwidth * 0.75);

            auto done = false;

            auto stage = Engine::ArmourSave::START;

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Armour Save");

            TTF_Init();

            auto font_mason = TTF_OpenFont(FONT_MASON, 32);

            auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 32);

            auto font_size = 24;

            const char *choices_save[1] = {"Armour Save"};
            const char *choices_reduce[1] = {"Reduce Damage"};
            const char *choices_end[1] = {"Done"};

            SDL_Surface *dice[6];

            dice[0] = createImage("images/dice/dice1.png");
            dice[1] = createImage("images/dice/dice2.png");
            dice[2] = createImage("images/dice/dice3.png");
            dice[3] = createImage("images/dice/dice4.png");
            dice[4] = createImage("images/dice/dice5.png");
            dice[5] = createImage("images/dice/dice6.png");

            auto controls_save = createFixedTextButtons(choices_save, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_save[0].Type = Control::Type::CONFIRM;

            auto controls_reduce = createFixedTextButtons(choices_reduce, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_reduce[0].Type = Control::Type::CONFIRM;

            auto controls_end = createFixedTextButtons(choices_end, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_end[0].Type = Control::Type::BACK;

            auto current = -1;

            auto selected = false;

            auto scrollUp = false;

            auto scrollDown = false;

            auto hold = false;

            std::vector<int> results = {};

            auto save_score = Engine::ARMOUR(character);

            if (save_score > combat_damage)
            {
                save_score = combat_damage;
            }

            auto size_dice = 64;

            auto cols = (fullwidth - 2 * box_space) / (size_dice + 2 * box_space);

            auto controls = std::vector<TextButton>();

            auto reduced = false;

            final_damage = combat_damage;

            auto reduced_damage = 0;

            auto fg = Color::HEADER(book);

            while (!done)
            {
                fillWindow(renderer, intWH);

                putHeader(renderer, "Armour save results", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty + infoh + boxh + box_space);

                fillRect(renderer, fullwidth, boxh * 3, startx, starty + infoh + boxh + box_space + infoh, intBE);

                if (stage != Engine::ArmourSave::START)
                {
                    if (stage == Engine::ArmourSave::SAVE)
                    {
                        if (results.size() == 0)
                        {
                            Sound::Play(Sound::Type::DICE_ROLL);

                            results = Engine::ROLL_DICE(save_score);
                        }
                    }

                    auto row = 0;
                    auto col = 0;

                    auto offsety = starty + infoh + boxh + box_space + infoh + box_space;
                    auto offsetx = startx + box_space;

                    for (auto i = 0; i < results.size(); i++)
                    {
                        if (results[i] >= 1 && results[i] <= 6)
                        {
                            auto result = results[i] - 1;

                            fitImage(renderer, dice[result], offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);

                            if (stage == Engine::ArmourSave::REDUCE)
                            {
                                if (results[i] >= 4)
                                {
                                    thickRect(renderer, size_dice, size_dice, offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), intLB, 2);

                                    reduced_damage += 1;
                                }
                            }

                            if (col < cols)
                            {
                                col += 1;
                            }
                            else
                            {
                                col = 0;

                                row += 1;
                            }
                        }
                    }
                }

                if (stage == Engine::ArmourSave::REDUCE)
                {
                    if (!reduced)
                    {
                        final_damage = combat_damage - reduced_damage;

                        flash_message = true;

                        if (final_damage > 0)
                        {
                            Sound::Play(Sound::Type::FAIL);

                            Engine::GAIN_HEALTH(character, -final_damage);

                            message = character.Name + " dealt " + std::to_string(final_damage) + " damage!";

                            flash_color = intRD;
                        }
                        else
                        {
                            Sound::Play(Sound::Type::SUCCESS);

                            message = character.Name + " deflects the attack!";

                            flash_color = intLB;
                        }

                        start_ticks = SDL_GetTicks();

                        reduced = true;
                    }
                }

                std::string defender_string = "";

                putHeader(renderer, character.Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty);

                fillRect(renderer, boxwidth, boxh, startx, starty + infoh, intBE);

                defender_string = "Armour Save: +" + std::to_string(save_score);
                defender_string += "\nHealth: " + std::to_string(Engine::HEALTH(character));

                putText(renderer, defender_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx, starty + infoh);

                if (stage == Engine::ArmourSave::START)
                {
                    controls = controls_save;
                }
                else if (stage == Engine::ArmourSave::SAVE)
                {
                    controls = controls_reduce;
                }
                else if (stage == Engine::ArmourSave::REDUCE)
                {
                    controls = controls_end;
                }

                if (flash_message)
                {
                    if ((SDL_GetTicks() - start_ticks) < duration)
                    {
                        putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                    }
                    else
                    {
                        flash_message = false;
                    }
                }

                renderTextButtons(renderer, controls, FONT_MASON, current, clrWH, intDB, intLB, font_size, TTF_STYLE_NORMAL);

                Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

                if (selected && current >= 0 && current < controls.size())
                {
                    if (stage == Engine::ArmourSave::START && controls[current].Type == Control::Type::CONFIRM)
                    {
                        stage = Engine::ArmourSave::SAVE;
                    }
                    else if (stage == Engine::ArmourSave::SAVE && controls[current].Type == Control::Type::CONFIRM)
                    {
                        stage = Engine::ArmourSave::REDUCE;
                    }
                    else if (stage == Engine::ArmourSave::REDUCE && controls[current].Type == Control::Type::BACK)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        stage = Engine::ArmourSave::END;

                        done = true;

                        current = -1;

                        selected = false;
                    }
                }
            }

            if (font_mason)
            {
                TTF_CloseFont(font_mason);

                font_mason = NULL;
            }

            if (font_garamond)
            {
                TTF_CloseFont(font_garamond);

                font_garamond = NULL;
            }

            TTF_Quit();

            for (auto i = 0; i < 6; i++)
            {
                if (dice[i])
                {
                    SDL_FreeSurface(dice[i]);

                    dice[i] = NULL;
                }
            }
        }
    }

    return std::max<int>(0, final_damage);
}

int assignDamage(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, int combat_damage)
{
    auto result = -1;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Assign Damage");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > party.Members.size())
        {
            last = party.Members.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, false);

        auto done = false;

        auto selection = -1;

        auto fg = Color::HEADER(party.Book);

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            putHeader(renderer, "Party", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            for (auto i = offset; i < last; i++)
            {
                auto index = i - offset;

                if (index >= 0 && index < party.Members.size())
                {
                    if (selection == index)
                    {
                        for (auto size = 4; size >= 0; size--)
                        {
                            auto w = controls[index].W + 2 * (8 - size);
                            auto h = controls[index].H + 2 * (8 - size);
                            auto x = controls[index].X - 8 + size;
                            auto y = controls[index].Y - 8 + size;

                            drawRect(renderer, w, h, x, y, intLB);
                        }
                    }
                    else if (Engine::IS_ALIVE(party.Members[index]))
                    {
                        drawRect(renderer, controls[index].W + border_space, controls[index].H + border_space, controls[index].X - border_pts, controls[index].Y - border_pts, intBK);
                    }
                    else
                    {
                        drawRect(renderer, controls[index].W + border_space, controls[index].H + border_space, controls[index].X - border_pts, controls[index].Y - border_pts, intRD);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            putHeader(renderer, (std::string("Deal " + std::to_string(combat_damage) + " damage to")).c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection >= 0 && selection < party.Members.size())
            {
                if (Engine::IS_ALIVE(party.Members[selection]))
                {
                    putText(renderer, party.Members[selection].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
                }
            }
            else
            {
                fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if (selected && current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if (selection >= 0 && selection < party.Members.size())
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        done = true;

                        result = selection;

                        current = -1;

                        selected = false;
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You must select an adventurer damaged by the attack.", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < party.Members.size())
                    {
                        if (selection == current + offset)
                        {
                            selection = -1;
                        }
                        else
                        {
                            if (Engine::IS_ALIVE(party.Members[current + offset]))
                            {
                                if (team == Team::Type::NONE || party.Members[current + offset].Team == team)
                                {
                                    if (Engine::IS_CURSED(party.Members[current + offset]))
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage("You cannot assign the damage to " + party.Members[current + offset].Name + "!", intRD);
                                    }
                                    else
                                    {
                                        selection = current + offset;
                                    }
                                }
                                else
                                {
                                    if (!Engine::IS_CHARACTER(party.Members[current + offset].Team))
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[current + offset].Name + " is not part of the " + std::string(Team::Descriptions[team]) + " team!", intRD);
                                    }
                                    else
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage("You can only assign damage to " + std::string(Team::Descriptions[team]) + "!", intRD);
                                    }
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[current + offset].Name + " is dead!", intRD);
                            }
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return result;
}

int magicAttackScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Monster::Base> &monsters, Spells::Base &spell, int combatant, int opponent, int fighting_score)
{
    auto combat_damage = 0;

    auto Defence = monsters[opponent].Defence;

    if (Engine::VERIFY_CODES(party, {Codes::Type::ENEMY_DAZING_LIGHTS}))
    {
        Defence += 1;

        Defence = std::min<int>(Defence, 6);
    }

    if (Engine::COUNT(party) > 0 && Engine::COUNT(monsters) > 0)
    {
        if (window && renderer)
        {
            auto flash_message = false;

            auto flash_color = intRD;

            std::string message = "";

            Uint32 start_ticks = 0;

            Uint32 duration = 3000;

            auto displayMessage = [&](std::string msg, Uint32 color)
            {
                flash_message = true;

                message = msg;

                flash_color = color;

                start_ticks = SDL_GetTicks();
            };

            auto headerw = (int)(boxwidth * 0.75);

            auto done = false;

            auto stage = Engine::Attack::START;

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Magic Attack");

            TTF_Init();

            auto font_mason = TTF_OpenFont(FONT_MASON, 32);

            auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 32);

            auto font_size = 24;

            const char *choices_attack[2] = {"Attack", "Cancel"};
            const char *choices_damage[1] = {"Deal Damage"};
            const char *choices_end[1] = {"Done"};

            SDL_Surface *dice[6];

            dice[0] = createImage("images/dice/dice1.png");
            dice[1] = createImage("images/dice/dice2.png");
            dice[2] = createImage("images/dice/dice3.png");
            dice[3] = createImage("images/dice/dice4.png");
            dice[4] = createImage("images/dice/dice5.png");
            dice[5] = createImage("images/dice/dice6.png");

            auto controls_attack = createFixedTextButtons(choices_attack, 2, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_attack[0].Type = Control::Type::CONFIRM;
            controls_attack[1].Type = Control::Type::BACK;

            auto controls_damage = createFixedTextButtons(choices_damage, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_damage[0].Type = Control::Type::CONFIRM;
            controls_damage[0].W = controls_attack[0].W;

            auto controls_end = createFixedTextButtons(choices_end, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_end[0].Type = Control::Type::BACK;
            controls_end[0].W = controls_attack[0].W;

            auto current = -1;

            auto selected = false;

            auto scrollUp = false;

            auto scrollDown = false;

            auto hold = false;

            std::vector<int> results = {};

            auto size_dice = 64;

            auto cols = (fullwidth - 2 * box_space) / (size_dice + box_space);

            auto controls = std::vector<TextButton>();

            auto damaged = false;

            if (Engine::VERIFY_CODES(party, {Codes::Type::ENEMY_DAZING_LIGHTS}))
            {
                Sound::Play(Sound::Type::FAIL);

                displayMessage("The enemy cast Dazing Lights. Your target is more difficult to hit!", intRD);
            }

            auto fg = Color::HEADER(party.Book);

            while (!done)
            {
                fillWindow(renderer, intWH);

                putHeader(renderer, "Attack Results", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty + infoh + boxh + box_space);

                fillRect(renderer, fullwidth, boxh * 3, startx, starty + infoh + boxh + box_space + infoh, intBE);

                if (stage != Engine::Attack::START)
                {
                    if (stage == Engine::Attack::ATTACK)
                    {
                        if (results.size() == 0)
                        {
                            Sound::Play(Sound::Type::DICE_ROLL);

                            results = Engine::ROLL_DICE(fighting_score);
                        }
                    }

                    auto row = 0;
                    auto col = 0;

                    auto offsety = starty + infoh + boxh + box_space + infoh + box_space;
                    auto offsetx = startx + box_space;

                    auto damage = 0;

                    for (auto i = 0; i < results.size(); i++)
                    {
                        if (results[i] >= 1 && results[i] <= 6)
                        {
                            auto result = results[i] - 1;

                            fitImage(renderer, dice[result], offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);

                            if (stage == Engine::Attack::DAMAGE)
                            {
                                if (results[i] >= Defence)
                                {
                                    thickRect(renderer, size_dice, size_dice, offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), intLB, 2);

                                    damage += 1;
                                }
                            }

                            if (col < cols)
                            {
                                col += 1;
                            }
                            else
                            {
                                col = 0;

                                row += 1;
                            }
                        }
                    }

                    if (stage == Engine::Attack::DAMAGE)
                    {
                        if (!damaged)
                        {
                            std::string stunned = "";

                            if (damage > 0 && monsters[opponent].Type == Monster::Type::FASTILON && !monsters[opponent].Damaged)
                            {
                                Sound::Play(Sound::Type::FAIL);

                                stunned = "\n\n" + party.Members[combatant].Name + " is stunned next round!";

                                Engine::GAIN_STATUS(party.Members[combatant], Character::Status::STUNNED_NEXT_ROUND);
                            }

                            Engine::GAIN_HEALTH(monsters[opponent], -damage);

                            combat_damage = damage;

                            if (damage > 0)
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                displayMessage(party.Members[combatant].Name + "'s " + spell.Name + " deals " + std::to_string(damage) + " to the " + monsters[opponent].Name + "!" + stunned, intLB);
                            }
                            else
                            {
                                Sound::Play(Sound::Type::FAIL);

                                displayMessage(party.Members[combatant].Name + "'s " + spell.Name + " was ineffective!", intRD);
                            }

                            damaged = true;
                        }
                    }
                }

                putHeader(renderer, party.Members[combatant].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty);
                fillRect(renderer, boxwidth, boxh, startx, starty + infoh, intBE);
                std::string attacker_string = "Magic Fighting Score: " + std::to_string(fighting_score);
                putText(renderer, attacker_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx, starty + infoh);

                putHeader(renderer, monsters[opponent].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx + boxwidth + marginx, starty);
                fillRect(renderer, boxwidth, boxh, startx + boxwidth + marginx, starty + infoh, intBE);
                std::string defender_string = "Defence: " + std::to_string(Defence) + "+\nHealth: " + std::to_string(monsters[opponent].Health);
                putText(renderer, defender_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx + boxwidth + marginx, starty + infoh);

                std::string spell_string = "SPELL: " + spell.Name;
                putHeader(renderer, spell_string.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx, starty + 2 * infoh + 4 * boxh + 2 * box_space);

                if (stage == Engine::Attack::START)
                {
                    controls = controls_attack;
                }
                else if (stage == Engine::Attack::ATTACK)
                {
                    controls = controls_damage;
                }
                else if (stage == Engine::Attack::DAMAGE)
                {
                    controls = controls_end;
                }

                if (flash_message)
                {
                    if ((SDL_GetTicks() - start_ticks) < duration)
                    {
                        putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                    }
                    else
                    {
                        flash_message = false;
                    }
                }

                renderTextButtons(renderer, controls, FONT_MASON, current, clrWH, intDB, intLB, font_size, TTF_STYLE_NORMAL);

                Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

                if (selected && current >= 0 && current < controls.size())
                {
                    if (stage == Engine::Attack::START && controls[current].Type == Control::Type::BACK)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        combat_damage = -1;

                        done = true;

                        current = -1;

                        selected = false;
                    }
                    else if (stage == Engine::Attack::START && controls[current].Type == Control::Type::CONFIRM)
                    {
                        stage = Engine::Attack::ATTACK;
                    }
                    else if (stage == Engine::Attack::ATTACK && controls[current].Type == Control::Type::CONFIRM)
                    {
                        stage = Engine::Attack::DAMAGE;
                    }
                    else if (stage == Engine::Attack::DAMAGE && controls[current].Type == Control::Type::BACK)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        stage = Engine::Attack::END;

                        done = true;

                        current = -1;

                        selected = false;
                    }
                }
            }

            if (font_mason)
            {
                TTF_CloseFont(font_mason);

                font_mason = NULL;
            }

            if (font_garamond)
            {
                TTF_CloseFont(font_garamond);

                font_garamond = NULL;
            }

            TTF_Quit();

            for (auto i = 0; i < 6; i++)
            {
                if (dice[i])
                {
                    SDL_FreeSurface(dice[i]);

                    dice[i] = NULL;
                }
            }
        }
    }

    return combat_damage;
}

std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, int start, int last, int limit, int offsetx, int offsety, bool cargo, bool confirm_button, bool back_button)
{
    auto controls = std::vector<Button>();

    if (ships.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto ship_string = shipString(ships[index], cargo);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, ship_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (ships.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (ships.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    if (confirm_button)
    {
        idx = controls.size();

        controls.push_back(Button(idx, "icons/yes.png", idx - 1, (back_button ? idx + 1 : idx), ships.size() > 0 ? (last - start) - 1 : idx, idx, textx, buttony, Control::Type::CONFIRM));
    }

    if (back_button)
    {
        idx = controls.size();

        controls.push_back(Button(idx, "icons/back-button.png", idx - 1, idx, ships.size() > 0 ? (last - start) - 1 : idx, idx, lastx, buttony, Control::Type::BACK));
    }

    return controls;
}

std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, int start, int last, int limit, int offsetx, int offsety, Control::Type mode)
{
    auto controls = std::vector<Button>();

    if (ships.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            std::string ship_string = shipString(ships[index], false);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, ship_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (ships.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (ships.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    if (mode == Control::Type::ATTACK)
    {
        controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "ATTACK", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, ships.size() > 0 ? (last - start) - 1 : idx, idx, startx, text_buttony, Control::Type::ATTACK));
    }
    else if (mode == Control::Type::DEFEND)
    {
        controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "DEFEND", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, ships.size() > 0 ? (last - start) - 1 : idx, idx, startx, text_buttony, Control::Type::ATTACK));
    }
    else if (mode == Control::Type::NEXT)
    {
        controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "NEXT ROUND", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, ships.size() > 0 ? (last - start) - 1 : idx, idx, startx, text_buttony, Control::Type::ATTACK));
    }

    controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "CAST SPELL", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, ships.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::SPELL));

    controls.push_back(Button(idx + 2, createHeaderButton(window, FONT_DARK11, 22, "FLEE", clrWH, intDB, text_buttonw, 48, -1), idx + 1, idx + 2, ships.size() > 0 ? (last - start) - 1 : idx + 2, idx + 2, startx + 2 * text_gridsize, text_buttony, Control::Type::FLEE));

    return controls;
}

int seaAttackScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Ship::Base> &enemyFleet, int opponent, int direction)
{
    auto flash_message = false;

    auto flash_color = intRD;

    std::string message = "";

    Uint32 start_ticks = 0;

    Uint32 duration = 3000;

    auto displayMessage = [&](std::string msg, Uint32 color)
    {
        flash_message = true;

        message = msg;

        flash_color = color;

        start_ticks = SDL_GetTicks();
    };

    auto fg = Color::HEADER(party.Book);

    TTF_Init();

    auto font_mason = TTF_OpenFont(FONT_MASON, 32);

    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 32);

    auto font_size = 24;

    SDL_Surface *dice[6];

    dice[0] = createImage("images/dice/dice1.png");
    dice[1] = createImage("images/dice/dice2.png");
    dice[2] = createImage("images/dice/dice3.png");
    dice[3] = createImage("images/dice/dice4.png");
    dice[4] = createImage("images/dice/dice5.png");
    dice[5] = createImage("images/dice/dice6.png");

    auto size_dice = 64;

    auto attacks = 1;

    auto Difficulty = 4;

    std::vector<int> target_damage = {};

    SDL_SetWindowTitle(window, "Legendary Kingdoms: Ship Attack");

    const char *choices_attack[2] = {"Attack", "Cancel"};
    const char *choices_defend[1] = {"Attack"};
    const char *choices_damage[1] = {"Deal Damage"};
    const char *choices_end[1] = {"Done"};

    auto headerw = (int)(boxwidth * 0.75);

    auto cols = (fullwidth - 2 * box_space) / (size_dice + box_space);

    auto controls_attack = createFixedTextButtons(choices_attack, 2, text_buttonw, text_buttonh, 10, startx, text_buttony);
    controls_attack[0].Type = Control::Type::CONFIRM;
    controls_attack[1].Type = Control::Type::BACK;

    auto controls_defend = createFixedTextButtons(choices_defend, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
    controls_defend[0].Type = Control::Type::CONFIRM;

    auto controls_damage = createFixedTextButtons(choices_damage, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
    controls_damage[0].Type = Control::Type::CONFIRM;

    auto controls_end = createFixedTextButtons(choices_end, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
    controls_end[0].Type = Control::Type::BACK;

    auto combat_damage = 0;

    for (auto num_attacks = 0; num_attacks < attacks; num_attacks++)
    {
        if (Engine::SHIP_INTACT(party) && opponent >= 0 && opponent < enemyFleet.size() && enemyFleet[opponent].Health > 0)
        {
            if (window && renderer)
            {
                auto done = false;

                auto stage = Engine::Attack::START;

                auto current = -1;

                auto selected = false;

                auto scrollUp = false;

                auto scrollDown = false;

                auto hold = false;

                std::vector<int> results = {};

                combat_damage = 0;

                auto attack_score = 1;

                auto controls = std::vector<TextButton>();

                auto damaged = false;

                auto special_event_trigger = true;

                while (!done)
                {
                    fillWindow(renderer, intWH);

                    putHeader(renderer, "Attack Results", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty + infoh + boxh + box_space);

                    fillRect(renderer, fullwidth, boxh * 3, startx, starty + infoh + boxh + box_space + infoh, intBE);

                    if (stage != Engine::Attack::START)
                    {
                        if (stage == Engine::Attack::ATTACK)
                        {
                            if (results.size() == 0)
                            {
                                Sound::Play(Sound::Type::DICE_ROLL);

                                results = Engine::ROLL_DICE(attack_score);
                            }
                        }

                        auto row = 0;
                        auto col = 0;

                        auto offsety = starty + infoh + boxh + box_space + infoh + box_space;
                        auto offsetx = startx + box_space;

                        auto damage = 0;

                        for (auto i = 0; i < results.size(); i++)
                        {
                            if (results[i] >= 1 && results[i] <= 6)
                            {
                                auto result = results[i] - 1;

                                fitImage(renderer, dice[result], offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);

                                if (stage == Engine::Attack::DAMAGE)
                                {
                                    if (results[i] >= Difficulty)
                                    {
                                        thickRect(renderer, size_dice, size_dice, offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), (direction == 0 ? intLB : intRD), 2);

                                        damage += 1;
                                    }
                                }

                                if (col < cols)
                                {
                                    col += 1;
                                }
                                else
                                {
                                    col = 0;

                                    row += 1;
                                }
                            }
                        }

                        if (stage == Engine::Attack::DAMAGE)
                        {
                            if (!damaged)
                            {
                                if (direction == 0)
                                {
                                    auto damage_scale = 1;

                                    Engine::GAIN_HEALTH(enemyFleet[opponent], -(damage_scale * damage));

                                    combat_damage = damage_scale * damage;

                                    if (damage_scale * damage > 0)
                                    {
                                        Sound::Play(Sound::Type::SUCCESS);

                                        displayMessage("The " + party.Fleet[party.CurrentShip].Name + " deals " + std::to_string(damage_scale * damage) + " to the " + enemyFleet[opponent].Name + "!", intLB);
                                    }
                                    else
                                    {
                                        Sound::Play(Sound::Type::FAIL);

                                        displayMessage("The " + party.Fleet[party.CurrentShip].Name + "'s attack was ineffective!", intRD);
                                    }
                                }
                                else
                                {
                                    combat_damage = damage;

                                    if (combat_damage > 0)
                                    {
                                        Sound::Play(Sound::Type::FAIL);

                                        Engine::GAIN_HEALTH(party.Fleet[party.CurrentShip], -damage);

                                        displayMessage(enemyFleet[opponent].Name + " deals " + std::to_string(damage) + " to your ship!", intRD);
                                    }
                                    else
                                    {
                                        Sound::Play(Sound::Type::SUCCESS);

                                        displayMessage("The " + enemyFleet[opponent].Name + "'s attack was ineffective!", intLB);
                                    }
                                }

                                damaged = true;
                            }
                        }
                    }
                    else
                    {
                        if (direction == 1 && special_event_trigger)
                        {
                            special_event_trigger = false;
                        }
                    }

                    std::string attacker_string = "";

                    if (direction == 0)
                    {
                        putHeader(renderer, party.Fleet[party.CurrentShip].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty);

                        attack_score = party.Fleet[party.CurrentShip].Fighting;

                        if (Engine::VERIFY_CODES(party, {Codes::Type::CANNOT_USE_SHIPWEAPONS}))
                        {
                            attack_score -= 1;

                            if (attack_score < 0)
                            {
                                attack_score = 0;
                            }
                        }

                        attacker_string = "Fighting: " + std::to_string(attack_score);
                        attacker_string += "\nHealth: " + std::to_string(party.Fleet[party.CurrentShip].Health);
                    }
                    else
                    {
                        putHeader(renderer, enemyFleet[opponent].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty);

                        attack_score = enemyFleet[opponent].Fighting;

                        if (attack_score < 0)
                        {
                            attack_score = 0;
                        }

                        attacker_string = "Fighting: " + std::to_string(attack_score);
                        attacker_string += "\nHealth: " + std::to_string(enemyFleet[opponent].Health);
                    }

                    fillRect(renderer, boxwidth, boxh, startx, starty + infoh, intBE);

                    putText(renderer, attacker_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx, starty + infoh);

                    std::string defender_string = "";

                    if (direction == 0)
                    {
                        putHeader(renderer, enemyFleet[opponent].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx + boxwidth + marginx, starty);
                        defender_string = "Defence: " + std::to_string(Difficulty) + "+";
                        defender_string += "\nHealth: " + std::to_string(enemyFleet[opponent].Health);
                    }
                    else
                    {
                        putHeader(renderer, party.Fleet[party.CurrentShip].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx + boxwidth + marginx, starty);
                        defender_string = "Defence: " + std::to_string(Difficulty) + "+";
                        defender_string += "\nHealth: " + std::to_string(party.Fleet[party.CurrentShip].Health);
                    }

                    fillRect(renderer, boxwidth, boxh, startx + boxwidth + marginx, starty + infoh, intBE);

                    putText(renderer, defender_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx + boxwidth + marginx, starty + infoh);

                    if (stage == Engine::Attack::START)
                    {
                        if (direction == 0)
                        {
                            controls = controls_attack;
                        }
                        else
                        {
                            controls = controls_defend;
                        }
                    }
                    else if (stage == Engine::Attack::ATTACK)
                    {
                        controls = controls_damage;
                    }
                    else if (stage == Engine::Attack::DAMAGE)
                    {
                        controls = controls_end;
                    }

                    if (flash_message)
                    {
                        if ((SDL_GetTicks() - start_ticks) < duration)
                        {
                            putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                        }
                        else
                        {
                            flash_message = false;
                        }
                    }

                    renderTextButtons(renderer, controls, FONT_MASON, current, clrWH, intDB, intLB, font_size, TTF_STYLE_NORMAL);

                    Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

                    if (selected && current >= 0 && current < controls.size())
                    {
                        if (stage == Engine::Attack::START && controls[current].Type == Control::Type::BACK)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            done = true;

                            current = -1;

                            selected = false;

                            combat_damage = -1;
                        }
                        else if (stage == Engine::Attack::START && controls[current].Type == Control::Type::CONFIRM)
                        {
                            stage = Engine::Attack::ATTACK;
                        }
                        else if (stage == Engine::Attack::ATTACK && controls[current].Type == Control::Type::CONFIRM)
                        {
                            stage = Engine::Attack::DAMAGE;
                        }
                        else if (stage == Engine::Attack::DAMAGE && controls[current].Type == Control::Type::BACK)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            stage = Engine::Attack::END;

                            done = true;

                            current = -1;

                            selected = false;
                        }
                        else if (stage == Engine::Attack::DAMAGE && controls[current].Type == Control::Type::CONFIRM)
                        {
                            if (Engine::SHIP_INTACT(party))
                            {
                                if (combat_damage > 0)
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    displayMessage(party.Fleet[party.CurrentShip].Name + " dealt " + std::to_string(combat_damage) + " damage!", intRD);

                                    Engine::GAIN_HEALTH(party.Fleet[party.CurrentShip], -combat_damage);
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    displayMessage("The " + enemyFleet[opponent].Name + "'s attack was ineffective!", intLB);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::BUTTON_CLICK);

                                done = true;

                                selected = false;

                                current = -1;
                            }
                        }
                    }
                }
            }
        }
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    TTF_Quit();

    for (auto i = 0; i < 6; i++)
    {
        if (dice[i])
        {
            SDL_FreeSurface(dice[i]);

            dice[i] = NULL;
        }
    }

    return std::max<int>(0, combat_damage);
}

int attackScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Monster::Base> &monsters, int combatant, int opponent, int direction, int combatRound, bool useEquipment)
{
    auto combat_damage = 0;

    auto num_attacks = direction == 0 ? 1 : std::min<int>(monsters[opponent].Attacks, Engine::COUNT(party, team));

    auto Difficulty = monsters[opponent].Difficulty;

    auto Defence = monsters[opponent].Defence;

    if (Engine::VERIFY_CODES_ANY(party, {Codes::Type::FIGHT_TO_KILL, Codes::Type::FIGHT_TO_STUN}))
    {
        Difficulty = 4;

        Defence = 4;
    }

    std::vector<int> target_damage = {};

    auto spell = Spells::Type::NONE;

    if (direction == 1)
    {
        if (monsters[opponent].Type == Monster::Type::IMOPPOSH_THE_MAD)
        {
            if (combatRound == 0)
            {
                num_attacks = std::min<int>(2, Engine::COUNT(party, team));
            }
            else if (combatRound == 2)
            {
                num_attacks = Engine::COUNT(party, team);

                spell = Spells::Type::SANDSTORM;
            }
        }
        else if (monsters[opponent].Type == Monster::Type::MONKEY_WITH_SPELLS)
        {
            auto roll = Engine::ROLL(1);

            if (roll <= 2)
            {
                spell = Spells::Type::ICE_BOLT;

                num_attacks = 1;

                Difficulty = 4;
            }
            else if (roll <= 4)
            {
                spell = Spells::Type::UNFAILING_STRIKE;

                num_attacks = 1;

                Difficulty = 1;
            }
            else if (roll <= 6)
            {
                num_attacks = std::min<int>(2, Engine::COUNT(party, team));

                spell = Spells::Type::POISON_STREAM;

                Difficulty = 4;
            }
        }
        else if (monsters[opponent].Type == Monster::Type::ZEALOT_SORCERER)
        {
            if (combatRound == 0)
            {
                spell = Spells::Type::ICE_BOLT;

                num_attacks = 1;
            }
            else if (combatRound == 2)
            {
                num_attacks = Engine::COUNT(party, team);

                spell = Spells::Type::SANDSTORM;
            }
        }
        else if (monsters[opponent].Type == Monster::Type::FASTILON)
        {
            if (combatRound == 0)
            {
                spell = Spells::Type::RUNE_OF_UNMAKING;

                num_attacks = 1;
            }
            else if (combatRound == 1)
            {
                num_attacks = std::min<int>(2, Engine::COUNT(party, team));
            }
        }
    }
    else
    {
        if (Engine::VERIFY_CODES(party, {Codes::Type::ENEMY_DAZING_LIGHTS}))
        {
            Defence += 1;

            Defence = std::min<int>(Defence, 6);
        }
    }

    auto flash_message = false;

    auto flash_color = intRD;

    std::string message = "";

    Uint32 start_ticks = 0;

    Uint32 duration = 3000;

    auto displayMessage = [&](std::string msg, Uint32 color)
    {
        flash_message = true;

        message = msg;

        flash_color = color;

        start_ticks = SDL_GetTicks();
    };

    auto fg = Color::HEADER(party.Book);

    TTF_Init();

    auto font_mason = TTF_OpenFont(FONT_MASON, 32);

    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 32);

    auto font_size = 24;

    auto size_dice = 64;

    auto cols = (fullwidth - 2 * box_space) / (size_dice + box_space);

    const char *choices_attack[4] = {"Attack", "Add Focus", "Remove Focus", "Cancel"};
    const char *choices_skipattack[5] = {"Attack", "Skip", "Add Focus", "Remove Focus", "Cancel"};
    const char *choices_defend[1] = {"Attack"};
    const char *choices_damage[1] = {"Deal Damage"};
    const char *choices_end[1] = {"Done"};
    const char *choices_assign[1] = {"Assign"};

    SDL_Surface *dice[6];

    dice[0] = createImage("images/dice/dice1.png");
    dice[1] = createImage("images/dice/dice2.png");
    dice[2] = createImage("images/dice/dice3.png");
    dice[3] = createImage("images/dice/dice4.png");
    dice[4] = createImage("images/dice/dice5.png");
    dice[5] = createImage("images/dice/dice6.png");

    auto controls_attack = createFixedTextButtons(choices_attack, 4, text_buttonw, text_buttonh, 10, startx, text_buttony);
    controls_attack[0].Type = Control::Type::CONFIRM;
    controls_attack[1].Type = Control::Type::PLUS;
    controls_attack[2].Type = Control::Type::MINUS;
    controls_attack[3].Type = Control::Type::BACK;

    auto controls_skipattack = createFixedTextButtons(choices_skipattack, 5, text_buttonw, text_buttonh, 10, startx, text_buttony);
    controls_skipattack[0].Type = Control::Type::CONFIRM;
    controls_skipattack[1].Type = Control::Type::NEXT;
    controls_skipattack[2].Type = Control::Type::PLUS;
    controls_skipattack[3].Type = Control::Type::MINUS;
    controls_skipattack[4].Type = Control::Type::BACK;

    auto controls_defend = createFixedTextButtons(choices_defend, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
    controls_defend[0].Type = Control::Type::CONFIRM;

    auto controls_damage = createFixedTextButtons(choices_damage, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
    controls_damage[0].Type = Control::Type::CONFIRM;

    auto controls_end = createFixedTextButtons(choices_end, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
    controls_end[0].Type = Control::Type::BACK;

    auto controls_assign = createFixedTextButtons(choices_assign, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
    controls_assign[0].Type = Control::Type::CONFIRM;

    for (auto attacks = 0; attacks < num_attacks; attacks++)
    {
        if (Engine::COUNT(party, team) > 0 && Engine::COUNT(monsters) > 0)
        {
            if (window && renderer)
            {
                auto done = false;

                auto stage = Engine::Attack::START;

                SDL_SetWindowTitle(window, "Legendary Kingdoms: Attack");

                auto current = -1;

                auto selected = false;

                auto scrollUp = false;

                auto scrollDown = false;

                auto hold = false;

                auto focus = 0;

                std::vector<int> results = {};

                combat_damage = 0;

                auto attack_score = 1;

                auto controls = std::vector<TextButton>();

                auto damaged = false;

                auto assigned = false;

                auto special_event_trigger = true;

                flash_message = false;

                while (!done)
                {
                    fillWindow(renderer, intWH);

                    putHeader(renderer, "Attack Results", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx, starty + infoh + boxh + box_space);

                    fillRect(renderer, fullwidth, boxh * 3, startx, starty + infoh + boxh + box_space + infoh, intBE);

                    putHeader(renderer, (std::string("Focus: " + std::to_string(focus))).c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx, starty + 2 * infoh + 4 * boxh + 2 * box_space);

                    if (stage != Engine::Attack::START)
                    {
                        if (stage == Engine::Attack::ATTACK)
                        {
                            if (results.size() == 0)
                            {
                                Sound::Play(Sound::Type::DICE_ROLL);

                                results = Engine::ROLL_DICE(attack_score);
                            }
                        }

                        auto row = 0;
                        auto col = 0;

                        auto offsety = starty + infoh + boxh + box_space + infoh + box_space;
                        auto offsetx = startx + box_space;

                        auto damage = 0;

                        for (auto i = 0; i < results.size(); i++)
                        {
                            if (results[i] >= 1 && results[i] <= 6)
                            {
                                auto result = results[i] - 1;

                                if (direction == 1 && Engine::VERIFY_CODES(party, {Codes::Type::DAZING_LIGHTS}))
                                {
                                    result = std::max<int>(0, result - 1);
                                }

                                fitImage(renderer, dice[result], offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);

                                if (stage == Engine::Attack::DAMAGE)
                                {
                                    if (direction == 0)
                                    {
                                        if (results[i] >= (Defence - focus))
                                        {
                                            thickRect(renderer, size_dice, size_dice, offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), intLB, 2);

                                            damage += 1;
                                        }
                                    }
                                    else
                                    {
                                        auto attack_result = results[i];

                                        if (Engine::VERIFY_CODES(party, {Codes::Type::DAZING_LIGHTS}))
                                        {
                                            attack_result = std::max<int>(1, attack_result - 1);
                                        }

                                        if (attack_result >= Difficulty)
                                        {
                                            thickRect(renderer, size_dice, size_dice, offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), intRD, 2);

                                            damage += 1;
                                        }
                                    }
                                }

                                if (col < cols)
                                {
                                    col += 1;
                                }
                                else
                                {
                                    col = 0;

                                    row += 1;
                                }
                            }
                        }

                        if (direction == 1)
                        {
                            damage += monsters[opponent].Auto;
                        }

                        if (stage == Engine::Attack::DAMAGE)
                        {
                            if (!damaged)
                            {
                                if (direction == 0)
                                {
                                    auto damage_scale = 1;

                                    auto weapon_used = Engine::FIND_EQUIPMENT(party.Members[combatant], Equipment::Class::WEAPON, Attribute::Type::FIGHTING);

                                    if (weapon_used >= 0 && weapon_used < party.Members[combatant].Equipment.size() && party.Members[combatant].Equipment[weapon_used].Type == Equipment::Type::STONECUTTER_SWORD2)
                                    {
                                        if (monsters[opponent].Type == Monster::Type::ROCK || monsters[opponent].Type == Monster::Type::STONE)
                                        {
                                            damage_scale = 2;
                                        }
                                    }

                                    combat_damage = damage_scale * damage;

                                    std::string stunned = "";

                                    if (combat_damage > 0 && monsters[opponent].Type == Monster::Type::FASTILON && !monsters[opponent].Damaged)
                                    {
                                        Engine::GAIN_STATUS(party.Members[combatant], Character::Status::STUNNED_NEXT_ROUND);

                                        stunned = "\n\n" + party.Members[combatant].Name + " is stunned next round!";
                                    }

                                    Engine::GAIN_HEALTH(monsters[opponent], -combat_damage);

                                    if (combat_damage > 0)
                                    {
                                        if (stunned.length() <= 0)
                                        {
                                            Sound::Play(Sound::Type::SUCCESS);
                                        }
                                        else
                                        {
                                            Sound::Play(Sound::Type::FAIL);
                                        }

                                        displayMessage(party.Members[combatant].Name + " deals " + std::to_string(damage_scale * damage) + " to the " + monsters[opponent].Name + "!" + stunned, intLB);
                                    }
                                    else
                                    {
                                        Sound::Play(Sound::Type::FAIL);

                                        displayMessage(party.Members[combatant].Name + "'s attack was ineffective!", intRD);
                                    }
                                }
                                else
                                {
                                    combat_damage = damage;

                                    if (combat_damage > 0)
                                    {
                                        Sound::Play(Sound::Type::FAIL);

                                        displayMessage(monsters[opponent].Name + " deals " + std::to_string(damage) + " to the party!", intRD);
                                    }
                                    else
                                    {
                                        Sound::Play(Sound::Type::SUCCESS);

                                        assigned = true;

                                        displayMessage("The " + monsters[opponent].Name + "'s attack was ineffective!", intLB);
                                    }
                                }

                                damaged = true;
                            }
                        }
                    }
                    else
                    {
                        if (direction == 1 && special_event_trigger)
                        {
                            if (Engine::VERIFY_CODES(party, {Codes::Type::DAZING_LIGHTS}))
                            {
                                Sound::Play(Sound::Type::FAIL);

                                displayMessage("Dazing Lights reduces " + monsters[opponent].Name + "'s Attack results by 1.", intLB);
                            }

                            if (monsters[opponent].Type == Monster::Type::SKALLOS && !monsters[opponent].Damaged)
                            {
                                Sound::Play(Sound::Type::FAIL);

                                displayMessage("Skallos unleashes a roar of black magic! Each party member loses 1 Health. Skallos recovers 4 Health points!", intRD);

                                Engine::GAIN_HEALTH(party, -1);

                                Engine::GAIN_HEALTH(monsters[opponent], 4);
                            }
                            else if (monsters[opponent].Type == Monster::Type::SNAKEMAN_PRIEST || monsters[opponent].Type == Monster::Type::SNAKEMAN)
                            {
                                if (Engine::VERIFY_EQUIPMENT(party, {Equipment::Type::HYGLIPH_FLOWER}))
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    Difficulty = monsters[opponent].Difficulty + 1;

                                    if (monsters[opponent].Type == Monster::Type::SNAKEMAN_PRIEST)
                                    {
                                        message = "The priest is put off by the pungent odour of the HYGLIPH FLOWER and requires a 5+ to his attack rolls to inflict damage during this battle.";
                                    }
                                    else if (monsters[opponent].Type == Monster::Type::SNAKEMAN)
                                    {
                                        message = "The snakeman is put off by the pungent odour of the HYGLIPH FLOWER and requires a " + std::to_string(Difficulty) + "+ to his attack rolls to inflict damage during this battle.";
                                    }

                                    displayMessage(message, intLB);
                                }
                            }
                            else if (monsters[opponent].Type == Monster::Type::IMOPPOSH_THE_MAD)
                            {
                                if (attacks == 0)
                                {
                                    if (combatRound == 0)
                                    {
                                        message = "Imopposh casts a Thunderbolt spell! He makes two Fighting: 10 attacks!";
                                    }
                                    else if (combatRound == 1)
                                    {
                                        message = "Imopposh casts an Orb of Annihilation! He makes a single Fighting: 13 attack!";
                                    }

                                    displayMessage(message, intRD);
                                }
                            }
                            else if (monsters[opponent].Type == Monster::Type::CURSITE_ASSASSIN)
                            {
                                if (!monsters[opponent].Damaged)
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    displayMessage("The Cursite Assassin executes a backstabbing attack dealing 4 damage to the party!", intRD);

                                    damaged = true;

                                    assigned = false;

                                    stage = Engine::Attack::DAMAGE;

                                    combat_damage = 4;
                                }
                            }
                            else if (monsters[opponent].Type == Monster::Type::FASTILON)
                            {
                                if (attacks == 0)
                                {
                                    if (combatRound == 1)
                                    {
                                        message = "Fastilon casts a Thunderbolt spell! He makes two Fighting: 5 attacks!";
                                    }

                                    displayMessage(message, intRD);
                                }
                            }

                            if (spell != Spells::Type::NONE && attacks == 0)
                            {
                                message = monsters[opponent].Name + " casts ";

                                if (spell == Spells::Type::ICE_BOLT)
                                {
                                    message += "Ice Bolt! " + monsters[opponent].Name + " makes a Fighting: 8 attack at Difficulty: " + std::to_string(Difficulty) + "+";
                                }
                                else if (spell == Spells::Type::UNFAILING_STRIKE)
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    message += "Unfailing Strike! " + monsters[opponent].Name + " deals 3 damage to the party!";

                                    damaged = true;

                                    assigned = false;

                                    stage = Engine::Attack::DAMAGE;

                                    combat_damage = 3;
                                }
                                else if (spell == Spells::Type::RUNE_OF_UNMAKING)
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    message += "Rune of Unmaking! " + monsters[opponent].Name + " deals 6 damage to the party!";

                                    damaged = true;

                                    assigned = false;

                                    stage = Engine::Attack::DAMAGE;

                                    combat_damage = 6;
                                }
                                else if (spell == Spells::Type::POISON_STREAM)
                                {
                                    message += "Poison Stream! " + monsters[opponent].Name + " makes two Fighting: 5 attack at Difficulty: " + std::to_string(Difficulty) + "+";
                                }
                                else if (spell == Spells::Type::SANDSTORM)
                                {
                                    message += "Sandstorm! " + monsters[opponent].Name + " makes a Fighting: 3 attack on each party member!";
                                }

                                displayMessage(message, intRD);
                            }

                            special_event_trigger = false;
                        }
                    }

                    std::string attacker_string = "";

                    if (direction == 0)
                    {
                        putHeader(renderer, party.Members[combatant].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx, starty);

                        if (useEquipment)
                        {
                            if (Engine::VERIFY_CODES_ANY(party, {Codes::Type::FIGHT_TO_STUN, Codes::Type::NO_WEAPONS}))
                            {
                                attack_score = Engine::SCORE(party.Members[combatant], Attribute::Type::FIGHTING) - (focus * 5) - 1;

                                if (attack_score < 0)
                                {
                                    attack_score = 0;
                                }
                            }
                            else
                            {
                                if (!Engine::VERIFY_CODES(party, {Codes::Type::TWO_HANDED_DISABLED}))
                                {
                                    attack_score = Engine::FIGHTING_SCORE(party.Members[combatant]) - (focus * 5);
                                }
                                else
                                {
                                    attack_score = Engine::FIGHTING_SCORE_ONE_HANDED(party.Members[combatant]) - (focus * 5);
                                }
                            }
                        }
                        else
                        {
                            attack_score = Engine::SCORE(party.Members[combatant], Attribute::Type::FIGHTING) - (focus * 5);
                        }

                        attacker_string = "Fighting: " + std::to_string(attack_score);
                        attacker_string += "\nHealth: " + std::to_string(Engine::HEALTH(party.Members[combatant]));
                    }
                    else
                    {
                        putHeader(renderer, monsters[opponent].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx, starty);

                        attack_score = monsters[opponent].Attack;

                        if (monsters[opponent].Type == Monster::Type::IMOPPOSH_THE_MAD)
                        {
                            if (combatRound == 0)
                            {
                                attack_score = 10;
                            }
                            else if (combatRound == 1)
                            {
                                attack_score = 13;
                            }
                            else if (combatRound == 2)
                            {
                                attack_score = 3;
                            }
                        }
                        else if (monsters[opponent].Type == Monster::Type::FASTILON)
                        {
                            if (combatRound == 1)
                            {
                                attack_score = 5;
                            }
                        }

                        if (spell == Spells::Type::ICE_BOLT)
                        {
                            attack_score = 8;
                        }
                        else if (spell == Spells::Type::POISON_STREAM)
                        {
                            attack_score = 5;
                        }
                        else if (spell == Spells::Type::SANDSTORM)
                        {
                            attack_score = 3;
                        }

                        if (attack_score < 0)
                        {
                            attack_score = 0;
                        }

                        attacker_string = "Attack: " + std::to_string(attack_score) + " (" + std::to_string(Difficulty) + "+)";

                        if (monsters[opponent].Auto > 0)
                        {
                            attacker_string += " +" + std::to_string(monsters[opponent].Auto) + " Auto";
                        }

                        attacker_string += "\nHealth: " + std::to_string(monsters[opponent].Health);
                    }

                    fillRect(renderer, boxwidth, boxh, startx, starty + infoh, intBE);

                    putText(renderer, attacker_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx, starty + infoh);

                    std::string defender_string = "";

                    if (direction == 0)
                    {
                        putHeader(renderer, monsters[opponent].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx + boxwidth + marginx, starty);
                        defender_string = "Defence: " + std::to_string(Defence - focus) + "+";
                        defender_string += "\nHealth: " + std::to_string(monsters[opponent].Health);
                    }
                    else
                    {
                        if (combatant == -1)
                        {
                            putHeader(renderer, "To be determined", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx + boxwidth + marginx, starty);
                        }
                        else
                        {
                            putHeader(renderer, party.Members[combatant].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx + boxwidth + marginx, starty);
                            defender_string = "Health: " + std::to_string(Engine::HEALTH(party.Members[combatant]));
                        }
                    }

                    fillRect(renderer, boxwidth, boxh, startx + boxwidth + marginx, starty + infoh, intBE);

                    putText(renderer, defender_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx + boxwidth + marginx, starty + infoh);

                    if (stage == Engine::Attack::START)
                    {
                        if (direction == 0)
                        {
                            if (monsters[opponent].Type == Monster::Type::JUNGLE)
                            {
                                controls = controls_skipattack;
                            }
                            else
                            {
                                controls = controls_attack;
                            }
                        }
                        else
                        {
                            controls = controls_defend;
                        }
                    }
                    else if (stage == Engine::Attack::ATTACK)
                    {
                        controls = controls_damage;
                    }
                    else if (stage == Engine::Attack::DAMAGE)
                    {
                        if (direction == 0)
                        {
                            controls = controls_end;
                        }
                        else
                        {
                            if (!assigned)
                            {
                                controls = controls_assign;
                            }
                            else
                            {
                                controls = controls_end;
                            }
                        }
                    }

                    if (flash_message)
                    {
                        if ((SDL_GetTicks() - start_ticks) < duration)
                        {
                            putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                        }
                        else
                        {
                            flash_message = false;
                        }
                    }

                    renderTextButtons(renderer, controls, FONT_MASON, current, clrWH, intDB, intLB, font_size, TTF_STYLE_NORMAL);

                    Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

                    if (selected && current >= 0 && current < controls.size())
                    {
                        if (stage == Engine::Attack::START && controls[current].Type == Control::Type::BACK)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            done = true;

                            current = -1;

                            selected = false;

                            combat_damage = -1;
                        }
                        else if (stage == Engine::Attack::START && controls[current].Type == Control::Type::NEXT)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            done = true;

                            current = -1;

                            selected = false;

                            combat_damage = 100;
                        }
                        else if (stage == Engine::Attack::START && controls[current].Type == Control::Type::PLUS)
                        {
                            if (direction == 0)
                            {
                                if ((attack_score - 5) > 0)
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    focus += 1;
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage("You cannot add more focus points!", intRD);
                                }
                            }

                            selected = false;
                        }
                        else if (stage == Engine::Attack::START && controls[current].Type == Control::Type::MINUS)
                        {
                            if (direction == 0)
                            {
                                if (focus > 0)
                                {
                                    focus -= 1;
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage("All focus points have been removed!", intRD);
                                }
                            }

                            selected = false;
                        }
                        else if (stage == Engine::Attack::START && controls[current].Type == Control::Type::CONFIRM)
                        {
                            stage = Engine::Attack::ATTACK;
                        }
                        else if (stage == Engine::Attack::ATTACK && controls[current].Type == Control::Type::CONFIRM)
                        {
                            stage = Engine::Attack::DAMAGE;
                        }
                        else if (stage == Engine::Attack::DAMAGE && controls[current].Type == Control::Type::BACK)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            stage = Engine::Attack::END;

                            done = true;

                            current = -1;

                            selected = false;
                        }
                        else if (stage == Engine::Attack::DAMAGE && controls[current].Type == Control::Type::CONFIRM)
                        {
                            if (Engine::COUNT(party, team) > 0)
                            {
                                if (combat_damage > 0)
                                {
                                    auto result = -1;

                                    if (Engine::COUNT(party, team) == 1)
                                    {
                                        if (team != Team::Type::NONE)
                                        {
                                            result = Engine::FIRST(party, team);
                                        }
                                        else
                                        {
                                            result = Engine::FIRST(party);
                                        }
                                    }
                                    else
                                    {
                                        result = assignDamage(window, renderer, party, team, combat_damage);
                                    }

                                    if (result >= 0 && result < party.Members.size())
                                    {
                                        if (Engine::IS_ALIVE(party.Members[result]))
                                        {
                                            if (Engine::FIND_LIST(target_damage, result) < 0)
                                            {
                                                assigned = true;

                                                target_damage.push_back(result);

                                                if (Engine::HAS_STATUS(party.Members[result], Character::Status::POTION_OF_INVULNERABILITY))
                                                {
                                                    Sound::Play(Sound::Type::SUCCESS);

                                                    displayMessage(party.Members[result].Name + "'s Invulnerability cancels the damage!", intLB);

                                                    Engine::REMOVE_STATUS(party.Members[result], Character::Status::POTION_OF_INVULNERABILITY);

                                                    combat_damage = 0;
                                                }
                                                else if (Engine::HAS_FOLLOWER(party.Members[result], Follower::Type::MORDAIN_SKELETONS))
                                                {
                                                    Sound::Play(Sound::Type::SUCCESS);

                                                    message = party.Members[result].Name + "'s [SKELETON] steps in the way and takes " + std::to_string(combat_damage) + " damage!";

                                                    auto follower = Engine::FIND_FOLLOWER(party.Members[result], Follower::Type::MORDAIN_SKELETONS);

                                                    if (follower >= 0 && follower < party.Members[result].Followers.size())
                                                    {
                                                        Engine::GAIN_HEALTH(party.Members[result].Followers[follower], -combat_damage);

                                                        if (party.Members[result].Followers[follower].Health <= 0)
                                                        {
                                                            party.Members[result].Followers.erase(party.Members[result].Followers.begin() + follower);

                                                            message += " The [SKELETON] is destroyed!";
                                                        }
                                                    }

                                                    displayMessage(message, intLB);

                                                    combat_damage = 0;
                                                }
                                                else if (Engine::ARMOUR(party.Members[result]) > 0 && monsters[opponent].Type != Monster::Type::PAPER && monsters[opponent].Type != Monster::Type::NAGA && !Engine::VERIFY_CODES(party, {Codes::Type::ARMOUR_DISABLED}))
                                                {
                                                    auto reduced_damage = armourSave(window, renderer, party.Book, party.Members[result], combat_damage);

                                                    combat_damage = std::max<int>(0, reduced_damage);

                                                    selected = false;

                                                    current = -1;

                                                    if (monsters[opponent].Type == Monster::Type::UNBRAAKI && reduced_damage > 0)
                                                    {
                                                        Sound::Play(Sound::Type::FAIL);

                                                        Engine::GAIN_HEALTH(monsters[opponent], reduced_damage);

                                                        displayMessage("Unbraaki gains " + std::to_string(reduced_damage) + " health!", intRD);
                                                    }
                                                    else
                                                    {
                                                        done = true;
                                                    }
                                                }
                                                else
                                                {
                                                    message = party.Members[result].Name + " dealt " + std::to_string(combat_damage) + " damage!";

                                                    Engine::GAIN_HEALTH(party.Members[result], -combat_damage);

                                                    if (monsters[opponent].Type == Monster::Type::UNBRAAKI && combat_damage > 0)
                                                    {
                                                        Sound::Play(Sound::Type::FAIL);

                                                        Engine::GAIN_HEALTH(monsters[opponent], combat_damage);

                                                        message += " " + monsters[opponent].Name + " gains " + std::to_string(combat_damage) + " health point";

                                                        if (combat_damage > 1)
                                                        {
                                                            message += "s";
                                                        }

                                                        message += ".";
                                                    }

                                                    displayMessage(message, intRD);
                                                }
                                            }
                                            else
                                            {
                                                Sound::Play(Sound::Type::ERROR);

                                                displayMessage(party.Members[result].Name + " was already assigned damage. Please choose another target.", intRD);
                                            }
                                        }
                                        else
                                        {
                                            Sound::Play(Sound::Type::ERROR);

                                            displayMessage(party.Members[result].Name + " is already dead!", intRD);
                                        }
                                    }
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    assigned = true;

                                    displayMessage("The " + monsters[opponent].Name + "'s attack was ineffective!", intLB);
                                }
                            }
                            else
                            {
                                done = true;

                                selected = false;

                                current = -1;
                            }
                        }
                    }
                }
            }
        }
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    TTF_Quit();

    for (auto i = 0; i < 6; i++)
    {
        if (dice[i])
        {
            SDL_FreeSurface(dice[i]);

            dice[i] = NULL;
        }
    }

    // seize and loot drops
    if (monsters[opponent].Health <= 0 && monsters[opponent].Loot.size() > 0)
    {
        takeScreen(window, renderer, party, team, monsters[opponent].Loot, monsters[opponent].Loot.size(), false);
    }

    return direction == 0 ? std::max<int>(-1, combat_damage) : std::max<int>(0, combat_damage);
}

bool retreatArmy(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, int unit, Location::Type &location, int threshold, int rolls)
{
    auto retreats = false;

    if (party.Army.size() > 0)
    {
        if (window && renderer)
        {
            auto flash_message = false;

            auto flash_color = intRD;

            std::string message = "";

            Uint32 start_ticks = 0;

            Uint32 duration = 3000;

            auto displayMessage = [&](std::string msg, Uint32 color)
            {
                flash_message = true;

                message = msg;

                flash_color = color;

                start_ticks = SDL_GetTicks();
            };

            auto fg = Color::HEADER(party.Book);

            auto headerw = (int)(boxwidth * 0.75);

            auto done = false;

            auto stage = Engine::Retreat::START;

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Retreat Army");

            TTF_Init();

            auto font_mason = TTF_OpenFont(FONT_MASON, 32);

            auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 32);

            auto font_size = 24;

            const char *choices_retreat[1] = {"Retreat"};
            const char *choices_confirm[1] = {"Confirm"};
            const char *choices_end[1] = {"Done"};

            SDL_Surface *dice[6];

            dice[0] = createImage("images/dice/dice1.png");
            dice[1] = createImage("images/dice/dice2.png");
            dice[2] = createImage("images/dice/dice3.png");
            dice[3] = createImage("images/dice/dice4.png");
            dice[4] = createImage("images/dice/dice5.png");
            dice[5] = createImage("images/dice/dice6.png");

            auto controls_retreat = createFixedTextButtons(choices_retreat, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_retreat[0].Type = Control::Type::CONFIRM;

            auto controls_confirm = createFixedTextButtons(choices_confirm, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_confirm[0].Type = Control::Type::CONFIRM;

            auto controls_end = createFixedTextButtons(choices_end, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_end[0].Type = Control::Type::BACK;

            auto current = -1;

            auto selected = false;

            auto scrollUp = false;

            auto scrollDown = false;

            auto hold = false;

            std::vector<int> results = {};

            auto size_dice = 64;

            auto cols = (fullwidth - 2 * box_space) / (size_dice + box_space);

            auto controls = std::vector<TextButton>();

            auto confirmed = false;

            while (!done)
            {
                fillWindow(renderer, intWH);

                putHeader(renderer, "Results", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty + infoh + boxh + box_space);

                fillRect(renderer, fullwidth, boxh * 3, startx, starty + infoh + boxh + box_space + infoh, intBE);

                if (stage != Engine::Retreat::START)
                {
                    auto success = 0;

                    if (rolls > 0)
                    {
                        if (stage == Engine::Retreat::RETREAT)
                        {
                            if (results.size() == 0)
                            {
                                Sound::Play(Sound::Type::DICE_ROLL);

                                results = Engine::ROLL_DICE(rolls);
                            }
                        }

                        auto row = 0;
                        auto col = 0;

                        auto offsety = starty + infoh + boxh + box_space + infoh + box_space;
                        auto offsetx = startx + box_space;

                        for (auto i = 0; i < results.size(); i++)
                        {
                            if (results[i] >= 1 && results[i] <= 6)
                            {
                                auto result = results[i] - 1;

                                fitImage(renderer, dice[result], offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);

                                success += results[i];

                                if (col < cols)
                                {
                                    col += 1;
                                }
                                else
                                {
                                    col = 0;

                                    row += 1;
                                }
                            }
                        }
                    }

                    if (stage == Engine::Retreat::CONFIRM)
                    {
                        if (!confirmed)
                        {
                            if (rolls > 0)
                            {
                                if (success > threshold)
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    retreats = true;

                                    displayMessage(party.Army[unit].Name + " retreats safely to " + std::string(Location::Description[location]) + ".", intLB);

                                    party.Army[unit].Morale = party.Army[unit].MaximumMorale;

                                    party.Army[unit].Garrison = location;
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    retreats = false;

                                    displayMessage(party.Army[unit].Name + " routed.", intRD);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                retreats = true;

                                displayMessage(party.Army[unit].Name + " retreats safely to " + std::string(Location::Description[location]) + ".", intLB);

                                party.Army[unit].Morale = party.Army[unit].MaximumMorale;

                                party.Army[unit].Garrison = location;
                            }

                            confirmed = true;
                        }
                    }
                }

                putHeader(renderer, party.Army[unit].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty);
                fillRect(renderer, boxwidth, boxh, startx, starty + infoh, intBE);
                std::string army_string = "Strength: " + std::to_string(party.Army[unit].Strength) + " Morale: " + std::to_string(party.Army[unit].Morale) + "\nPosition: " + Location::BattleFieldDescription[party.Army[unit].Position];
                putText(renderer, army_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx, starty + infoh);

                std::string attribute_string = "Retreat: Difficulty " + std::to_string(threshold);
                putHeader(renderer, attribute_string.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx, starty + 2 * infoh + 4 * boxh + 2 * box_space);

                if (stage == Engine::Retreat::START)
                {
                    controls = controls_retreat;
                }
                else if (stage == Engine::Retreat::RETREAT)
                {
                    controls = controls_confirm;
                }
                else if (stage == Engine::Retreat::CONFIRM)
                {
                    controls = controls_end;
                }

                if (flash_message)
                {
                    if ((SDL_GetTicks() - start_ticks) < duration)
                    {
                        putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                    }
                    else
                    {
                        flash_message = false;
                    }
                }

                renderTextButtons(renderer, controls, FONT_MASON, current, clrWH, intDB, intLB, font_size, TTF_STYLE_NORMAL);

                Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

                if (selected && current >= 0 && current < controls.size())
                {
                    if (stage == Engine::Retreat::START && controls[current].Type == Control::Type::CONFIRM)
                    {
                        if (rolls > 0)
                        {
                            stage = Engine::Retreat::RETREAT;
                        }
                        else
                        {
                            stage = Engine::Retreat::CONFIRM;
                        }
                    }
                    else if (stage == Engine::Retreat::RETREAT && controls[current].Type == Control::Type::CONFIRM)
                    {
                        stage = Engine::Retreat::CONFIRM;
                    }
                    else if (stage == Engine::Retreat::CONFIRM && controls[current].Type == Control::Type::BACK)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        stage = Engine::Retreat::END;

                        done = true;

                        current = -1;

                        selected = false;
                    }
                }
            }

            if (font_mason)
            {
                TTF_CloseFont(font_mason);

                font_mason = NULL;
            }

            if (font_garamond)
            {
                TTF_CloseFont(font_garamond);

                font_garamond = NULL;
            }

            TTF_Quit();

            for (auto i = 0; i < 6; i++)
            {
                if (dice[i])
                {
                    SDL_FreeSurface(dice[i]);

                    dice[i] = NULL;
                }
            }
        }
    }

    return retreats;
}

int gainAttributeScore(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Character::Base &character, Attribute::Type &attribute, int score, int rolls)
{
    auto increase = 0;

    if (Engine::IS_ALIVE(character))
    {
        if (window && renderer)
        {
            auto flash_message = false;

            auto flash_color = intRD;

            std::string message = "";

            Uint32 start_ticks = 0;

            Uint32 duration = 3000;

            auto displayMessage = [&](std::string msg, Uint32 color)
            {
                flash_message = true;

                message = msg;

                flash_color = color;

                start_ticks = SDL_GetTicks();
            };

            auto fg = Color::HEADER(book);

            auto headerw = (int)(boxwidth * 0.75);

            auto done = false;

            auto stage = Engine::RaiseAttribute::START;

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Increase Attribute");

            TTF_Init();

            auto font_mason = TTF_OpenFont(FONT_MASON, 32);

            auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 32);

            auto font_size = 24;

            const char *choices_raise[2] = {"Raise Attribute", "Cancel"};
            const char *choices_confirm[1] = {"Confirm"};
            const char *choices_end[1] = {"Done"};

            SDL_Surface *dice[6];

            dice[0] = createImage("images/dice/dice1.png");
            dice[1] = createImage("images/dice/dice2.png");
            dice[2] = createImage("images/dice/dice3.png");
            dice[3] = createImage("images/dice/dice4.png");
            dice[4] = createImage("images/dice/dice5.png");
            dice[5] = createImage("images/dice/dice6.png");

            auto controls_raise = createFixedTextButtons(choices_raise, 2, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_raise[0].Type = Control::Type::CONFIRM;
            controls_raise[1].Type = Control::Type::BACK;

            auto controls_confirm = createFixedTextButtons(choices_confirm, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_confirm[0].Type = Control::Type::CONFIRM;

            auto controls_end = createFixedTextButtons(choices_end, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_end[0].Type = Control::Type::BACK;

            auto current = -1;

            auto selected = false;

            auto scrollUp = false;

            auto scrollDown = false;

            auto hold = false;

            std::vector<int> results = {};

            auto size_dice = 64;

            auto cols = (fullwidth - 2 * box_space) / (size_dice + box_space);

            auto controls = std::vector<TextButton>();

            auto confirmed = false;

            while (!done)
            {
                fillWindow(renderer, intWH);

                putHeader(renderer, "Results", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty + infoh + boxh + box_space);

                fillRect(renderer, fullwidth, boxh * 3, startx, starty + infoh + boxh + box_space + infoh, intBE);

                if (stage != Engine::RaiseAttribute::START)
                {
                    auto success = 0;

                    if (rolls > 0)
                    {
                        if (stage == Engine::RaiseAttribute::RAISE)
                        {
                            if (results.size() == 0)
                            {
                                Sound::Play(Sound::Type::DICE_ROLL);

                                results = Engine::ROLL_DICE(rolls);
                            }
                        }

                        auto row = 0;
                        auto col = 0;

                        auto offsety = starty + infoh + boxh + box_space + infoh + box_space;
                        auto offsetx = startx + box_space;

                        for (auto i = 0; i < results.size(); i++)
                        {
                            if (results[i] >= 1 && results[i] <= 6)
                            {
                                auto result = results[i] - 1;

                                fitImage(renderer, dice[result], offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);

                                success += results[i];

                                if (col < cols)
                                {
                                    col += 1;
                                }
                                else
                                {
                                    col = 0;

                                    row += 1;
                                }
                            }
                        }
                    }

                    if (stage == Engine::RaiseAttribute::CONFIRM)
                    {
                        if (!confirmed)
                        {
                            if (rolls > 0)
                            {
                                if (success > Engine::SCORE(character, attribute))
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    increase = score;

                                    Engine::GAIN_SCORE(character, attribute, score);

                                    displayMessage(character.Name + "'s " + std::string(Attribute::Descriptions[attribute]) + " increased by " + std::to_string(score) + "!", intLB);
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    increase = 0;

                                    displayMessage(character.Name + "'s " + std::string(Attribute::Descriptions[attribute]) + " score did not increase.", intRD);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                increase = score;

                                Engine::GAIN_SCORE(character, attribute, score);

                                displayMessage(character.Name + "'s " + std::string(Attribute::Descriptions[attribute]) + " increased by " + std::to_string(score) + "!", intLB);
                            }

                            confirmed = true;
                        }
                    }
                }

                putHeader(renderer, character.Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty);
                fillRect(renderer, boxwidth, boxh, startx, starty + infoh, intBE);
                std::string attacker_string = std::string(Attribute::Descriptions[attribute]) + " Score: " + std::to_string(Engine::SCORE(character, attribute));
                putText(renderer, attacker_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx, starty + infoh);

                std::string attribute_string = "Raise: " + std::string(Attribute::Descriptions[attribute]);
                putHeader(renderer, attribute_string.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx, starty + 2 * infoh + 4 * boxh + 2 * box_space);

                if (stage == Engine::RaiseAttribute::START)
                {
                    controls = controls_raise;
                }
                else if (stage == Engine::RaiseAttribute::RAISE)
                {
                    controls = controls_confirm;
                }
                else if (stage == Engine::RaiseAttribute::CONFIRM)
                {
                    controls = controls_end;
                }

                if (flash_message)
                {
                    if ((SDL_GetTicks() - start_ticks) < duration)
                    {
                        putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                    }
                    else
                    {
                        flash_message = false;
                    }
                }

                renderTextButtons(renderer, controls, FONT_MASON, current, clrWH, intDB, intLB, font_size, TTF_STYLE_NORMAL);

                Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

                if (selected && current >= 0 && current < controls.size())
                {
                    if (stage == Engine::RaiseAttribute::START && controls[current].Type == Control::Type::BACK)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        increase = -1;

                        done = true;

                        current = -1;

                        selected = false;
                    }
                    else if (stage == Engine::RaiseAttribute::START && controls[current].Type == Control::Type::CONFIRM)
                    {
                        if (rolls > 0)
                        {
                            stage = Engine::RaiseAttribute::RAISE;
                        }
                        else
                        {
                            stage = Engine::RaiseAttribute::CONFIRM;
                        }
                    }
                    else if (stage == Engine::RaiseAttribute::RAISE && controls[current].Type == Control::Type::CONFIRM)
                    {
                        stage = Engine::RaiseAttribute::CONFIRM;
                    }
                    else if (stage == Engine::RaiseAttribute::CONFIRM && controls[current].Type == Control::Type::BACK)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        stage = Engine::RaiseAttribute::END;

                        done = true;

                        current = -1;

                        selected = false;

                        increase = score;
                    }
                }
            }

            if (font_mason)
            {
                TTF_CloseFont(font_mason);

                font_mason = NULL;
            }

            if (font_garamond)
            {
                TTF_CloseFont(font_garamond);

                font_garamond = NULL;
            }

            TTF_Quit();

            for (auto i = 0; i < 6; i++)
            {
                if (dice[i])
                {
                    SDL_FreeSurface(dice[i]);

                    dice[i] = NULL;
                }
            }
        }
    }

    return increase;
}

std::vector<int> selectSpell(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Character::Base &caster, std::vector<Spells::Base> &spells, int select_limit, Spells::Select mode)
{
    auto select_result = std::vector<int>();

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Select Spell");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_garamond2 = TTF_OpenFont(FONT_GARAMOND, 28);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto font_size = 24;

        auto offset = 0;
        auto limit = (int)((booksize - 2 * text_space) / (96));
        auto last = offset + limit;

        if (last > spells.size())
        {
            last = spells.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto spell_scrolly = starty + infoh + booksize - arrow_size - border_space;

        auto controls = spellList(window, renderer, spells, offset, last, limit, textx, texty + infoh + text_space, spell_scrolly, true, (mode == Spells::Select::CAST_SPELL ? true : false));

        auto done = false;

        auto selection = std::vector<int>();

        if (mode == Spells::Select::UNLEARN && !Engine::VERIFY_SPELL_LIMIT(caster))
        {
            Sound::Play(Sound::Type::ERROR);

            displayMessage("Your spellbook is holding too many spells! You must unlearn spells from your spellbook.", intRD);
        }

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        auto scrollSpeed = 1;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            fillRect(renderer, textwidth, booksize, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (Engine::FIND_LIST(selection, offset + i) >= 0)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else if (spells[offset + i].Charged)
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                    }
                }
            }

            if (current >= 0 && current < controls.size() && controls[current].Type == Control::Type::ACTION)
            {
                if ((current + offset) >= 0 && (current + offset) < spells.size())
                {
                    fillRect(renderer, textwidth, text_bounds / 3, textx, texty + 2 * text_bounds / 3, intLB);

                    auto text = createText(spells[current + offset].Description.c_str(), FONT_GARAMOND, font_size, clrWH, listwidth, TTF_STYLE_NORMAL);

                    renderText(renderer, text, intLB, textx + text_space, texty + 2 * text_bounds / 3 + text_space, text_bounds / 3 - 2 * text_space, 0);

                    SDL_FreeSurface(text);

                    text = NULL;
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            std::string list_header = "Choose " + (select_limit > 1 ? std::to_string(select_limit) : "a") + " spell" + (select_limit > 1 ? "s" : "") + " to ";

            if (mode == Spells::Select::SPELLBOOK)
            {
                list_header += "add to ";

                if (caster.Type != Character::Type::NONE)
                {
                    list_header += caster.Name + "'s ";
                }

                list_header += "spellbook";
            }
            else if (mode == Spells::Select::CAST_SPELL)
            {
                list_header = "cast";
            }
            else if (mode == Spells::Select::UNLEARN)
            {
                list_header = "unlearn";
            }

            putHeader(renderer, list_header.c_str(), font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection.size() > 0)
            {
                std::string spells_string = "";

                for (auto i = 0; i < selection.size(); i++)
                {
                    if (spells[selection[i]].Charged)
                    {
                        if (spells_string.length() > 0)
                        {
                            spells_string += ",";
                        }

                        spells_string += spells[selection[i]].Name;
                    }
                }

                if (spells_string.length() > 0)
                {
                    putText(renderer, spells_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
            }
            else
            {
                putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond2, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > spells.size())
                        {
                            last = spells.size();
                        }

                        controls = spellList(window, renderer, spells, offset, last, limit, textx, texty + infoh + text_space, spell_scrolly, true, false);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (spells.size() - last > 0)
                    {
                        if (offset < spells.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > spells.size() - limit)
                        {
                            offset = spells.size() - limit;
                        }

                        last = offset + limit;

                        if (last > spells.size())
                        {
                            last = spells.size();
                        }

                        controls = spellList(window, renderer, spells, offset, last, limit, textx, texty + infoh + text_space, spell_scrolly, true, false);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (spells.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    select_result.clear();

                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if (selection.size() > 0 && selection.size() >= select_limit)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        done = true;

                        for (auto i = 0; i < selection.size(); i++)
                        {
                            select_result.push_back(selection[i]);
                        }

                        current = -1;

                        selected = false;
                    }
                    else
                    {
                        if (mode == Spells::Select::CAST_SPELL)
                        {
                            message = "You must select a spell to CAST.";
                        }
                        else if (mode == Spells::Select::SPELLBOOK || mode == Spells::Select::UNLEARN)
                        {
                            message = "You must select ";

                            if (select_limit > 1)
                            {
                                message += std::to_string(select_limit);
                            }
                            else
                            {
                                message += "a";
                            }

                            message += " spell";

                            if (select_limit > 1)
                            {
                                message += "s";
                            }

                            message += " to ";

                            if (mode == Spells::Select::SPELLBOOK)
                            {
                                message += "add to ";
                            }
                            else
                            {
                                message += "erase from ";
                            }

                            if (caster.Type != Character::Type::NONE)
                            {
                                message += caster.Name + "'s";
                            }
                            else
                            {
                                message += "your";
                            }

                            message += " spellbook.";
                        }

                        Sound::Play(Sound::Type::ERROR);

                        displayMessage(message, intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < spells.size())
                    {
                        auto result = Engine::FIND_LIST(selection, current + offset);

                        if (result >= 0)
                        {
                            selection.erase(selection.begin() + result);
                        }
                        else
                        {
                            if (spells[current + offset].Charged)
                            {
                                if (selection.size() < select_limit)
                                {
                                    selection.push_back(current + offset);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(spells[current + offset].Name + " cannot be cast!", intRD);
                            }
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_garamond2)
        {
            TTF_CloseFont(font_garamond2);

            font_garamond2 = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return select_result;
}

int selectOpponent(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, int attacker, std::vector<Monster::Base> &monsters, std::vector<int> previousTargets, int combatRound, Control::Type mode)
{
    auto result = -1;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Select Opponent");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > monsters.size())
        {
            last = monsters.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = monsterList(window, renderer, monsters, offset, last, limit, textx, texty + infoh + text_space, true, false);

        auto done = false;

        auto selection = -1;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        auto scrollSpeed = 1;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            putHeader(renderer, "Select Opponent", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (selection == offset + i)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else if (monsters[offset + i].Health > 0)
                    {
                        if (combatRound >= monsters[offset + i].Round)
                        {
                            drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                        }
                        else
                        {
                            thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intGR, 2);
                        }
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            if (mode == Control::Type::COMBAT)
            {
                putHeader(renderer, "Attacker", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space));
            }
            else if (mode == Control::Type::SPELL)
            {
                putHeader(renderer, "Spell Caster", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space));
            }

            putText(renderer, party.Members[attacker].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + text_bounds - 3 * boxh - infoh - box_space);

            putHeader(renderer, "Opponent", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection >= 0 && selection < monsters.size())
            {
                if (monsters[selection].Health > 0)
                {
                    putText(renderer, monsters[selection].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
                }
            }
            else
            {
                fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > monsters.size())
                        {
                            last = monsters.size();
                        }

                        controls = monsterList(window, renderer, monsters, offset, last, limit, textx, texty + infoh + text_space, true, false);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (monsters.size() - last > 0)
                    {
                        if (offset < monsters.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > monsters.size() - limit)
                        {
                            offset = monsters.size() - limit;
                        }

                        last = offset + limit;

                        if (last > monsters.size())
                        {
                            last = monsters.size();
                        }

                        controls = monsterList(window, renderer, monsters, offset, last, limit, textx, texty + infoh + text_space, true, false);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (monsters.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    result = -1;

                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if (selection >= 0 && selection < monsters.size())
                    {
                        if (previousTargets.size() > 0)
                        {
                            if (Engine::FIND_LIST(previousTargets, selection) >= 0)
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("That opponent has been attacked before! Choose another target!", intRD);
                            }
                            else
                            {
                                Sound::Play(Sound::Type::BUTTON_CLICK);

                                done = true;

                                result = selection;

                                current = -1;

                                selected = false;
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            done = true;

                            result = selection;

                            current = -1;

                            selected = false;
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You must select an opponent to attack this round.", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < monsters.size())
                    {
                        if (selection == current + offset)
                        {
                            selection = -1;
                        }
                        else
                        {
                            if (monsters[current + offset].Health > 0 && combatRound >= monsters[current + offset].Round)
                            {
                                selection = current + offset;
                            }
                            else if (monsters[current + offset].Health > 0 && combatRound < monsters[current + offset].Round)
                            {
                                displayMessage(monsters[current + offset].Name + " has not joined the battle yet!", intRD);
                            }
                            else
                            {
                                displayMessage(monsters[current + offset].Name + " is dead!", intRD);
                            }
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return result;
}

int selectOpponent(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, std::vector<Ship::Base> &enemyFleet, std::vector<int> previousTargets, int combatRound)
{
    auto result = -1;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Select Enemy Ship");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (124);
        auto last = offset + limit;

        if (last > enemyFleet.size())
        {
            last = enemyFleet.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = shipList(window, renderer, enemyFleet, offset, last, limit, textx, texty + infoh + text_space, false, true, false);

        auto done = false;

        auto selection = -1;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        auto scrollSpeed = 1;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            putHeader(renderer, "Select Opponent", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (selection == offset + i)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else if (enemyFleet[offset + i].Health > 0)
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            putHeader(renderer, "Opponent", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection >= 0 && selection < enemyFleet.size())
            {
                if (enemyFleet[selection].Health > 0)
                {
                    putText(renderer, enemyFleet[selection].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
                }
            }
            else
            {
                fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > enemyFleet.size())
                        {
                            last = enemyFleet.size();
                        }

                        controls = shipList(window, renderer, enemyFleet, offset, last, limit, textx, texty + infoh + text_space, false, true, false);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (enemyFleet.size() - last > 0)
                    {
                        if (offset < enemyFleet.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > enemyFleet.size() - limit)
                        {
                            offset = enemyFleet.size() - limit;
                        }

                        last = offset + limit;

                        if (last > enemyFleet.size())
                        {
                            last = enemyFleet.size();
                        }

                        controls = shipList(window, renderer, enemyFleet, offset, last, limit, textx, texty + infoh + text_space, false, true, false);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (enemyFleet.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    result = -1;

                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if (selection >= 0 && selection < enemyFleet.size())
                    {
                        if (previousTargets.size() > 0)
                        {
                            if (Engine::FIND_LIST(previousTargets, selection) >= 0)
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("That opponent has been attacked before! Choose another target!", intRD);
                            }
                            else
                            {
                                Sound::Play(Sound::Type::BUTTON_CLICK);

                                done = true;

                                result = selection;

                                current = -1;

                                selected = false;
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            done = true;

                            result = selection;

                            current = -1;

                            selected = false;
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You must select an opponent to attack this round.", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < enemyFleet.size())
                    {
                        if (selection == current + offset)
                        {
                            selection = -1;
                        }
                        else
                        {
                            if (enemyFleet[current + offset].Health > 0)
                            {
                                selection = current + offset;
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(enemyFleet[current + offset].Name + " is destroyed!", intRD);
                            }
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return result;
}

bool skillTestScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team_type, std::vector<int> team, Attribute::Type Skill, int difficulty, int success, bool useEquipment)
{
    if (Skill == Attribute::Type::CHARISMA && Engine::VERIFY_CODES(party, {Codes::Type::CHARISMA_SUCCESS_CHALICE}) && party.Location == Location::Type::CHALICE && party.InCity == true)
    {
        return true;
    }

    auto test_result = false;

    if (Engine::COUNT(party) > 0 && Engine::COUNT(party) >= team.size())
    {
        if (window && renderer)
        {
            auto flash_message = false;

            auto flash_color = intRD;

            std::string message = "";

            Uint32 start_ticks = 0;

            Uint32 duration = 3000;

            auto displayMessage = [&](std::string msg, Uint32 color)
            {
                flash_message = true;

                message = msg;

                flash_color = color;

                start_ticks = SDL_GetTicks();
            };

            auto fg = Color::HEADER(party.Book);

            auto headerw = (int)(boxwidth * 0.75);

            auto done = false;

            auto stage = Attribute::Test::START;

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Skill Check");

            TTF_Init();

            auto font_mason = TTF_OpenFont(FONT_MASON, 32);

            auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 32);

            auto font_size = 24;

            const char *choices_skill[3] = {"Skill Check", "Add Focus", "Remove Focus"};
            const char *choices_confirm[1] = {"Confirm"};
            const char *choices_wolfspirit[2] = {"Wolf Spirit", "Done"};
            const char *choices_wisdom[2] = {"Wisdom", "Done"};
            const char *choices_silvertongue[2] = {"Silver Tongue", "Done"};
            const char *choices_charisma_potion[2] = {"Potion of Fluency", "Done"};
            const char *choices_silvertongue_potion[3] = {"Silver Tongue", "Potion of Fluency", "Done"};
            const char *choices_end[1] = {"Done"};

            SDL_Surface *dice[6];

            dice[0] = createImage("images/dice/dice1.png");
            dice[1] = createImage("images/dice/dice2.png");
            dice[2] = createImage("images/dice/dice3.png");
            dice[3] = createImage("images/dice/dice4.png");
            dice[4] = createImage("images/dice/dice5.png");
            dice[5] = createImage("images/dice/dice6.png");

            auto controls_skill = createFixedTextButtons(choices_skill, 3, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_skill[0].Type = Control::Type::CONFIRM;
            controls_skill[1].Type = Control::Type::PLUS;
            controls_skill[2].Type = Control::Type::MINUS;

            auto controls_confirm = createFixedTextButtons(choices_confirm, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_confirm[0].Type = Control::Type::CONFIRM;

            auto controls_end = createFixedTextButtons(choices_end, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_end[0].Type = Control::Type::BACK;

            auto controls_wolfspirit = createFixedTextButtons(choices_wolfspirit, 2, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_wolfspirit[0].Type = Control::Type::CONFIRM;
            controls_wolfspirit[1].Type = Control::Type::BACK;

            auto controls_wisdom = createFixedTextButtons(choices_wisdom, 2, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_wisdom[0].Type = Control::Type::CONFIRM;
            controls_wisdom[1].Type = Control::Type::BACK;

            auto controls_silvertongue = createFixedTextButtons(choices_silvertongue, 2, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_silvertongue[0].Type = Control::Type::CONFIRM;
            controls_silvertongue[1].Type = Control::Type::BACK;

            auto controls_charisma_potion = createFixedTextButtons(choices_charisma_potion, 2, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_charisma_potion[0].Type = Control::Type::DRINK;
            controls_charisma_potion[1].Type = Control::Type::BACK;

            auto controls_silvertongue_potion = createFixedTextButtons(choices_silvertongue_potion, 3, text_buttonw, text_buttonh, 10, startx, text_buttony);
            controls_silvertongue_potion[0].Type = Control::Type::CONFIRM;
            controls_silvertongue_potion[1].Type = Control::Type::DRINK;
            controls_silvertongue_potion[2].Type = Control::Type::BACK;

            auto current = -1;

            auto selected = false;

            auto scrollUp = false;

            auto scrollDown = false;

            auto hold = false;

            auto focus = 0;

            std::vector<int> results = {};

            auto skill_score = 0;

            auto score1 = 0;

            auto score2 = 0;

            auto computed_score1 = false;

            auto computed_score2 = false;

            auto size_dice = 64;

            auto cols = (fullwidth - 2 * box_space) / (size_dice + box_space);

            auto controls = std::vector<TextButton>();

            auto skill_checked = false;

            auto success_counter = 0;

            while (!done)
            {
                fillWindow(renderer, intWH);

                putHeader(renderer, "Skill Check Results", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty + infoh + boxh + box_space);

                fillRect(renderer, fullwidth, boxh * 3, startx, starty + infoh + boxh + box_space + infoh, intBE);

                if (stage != Attribute::Test::START)
                {
                    if (stage == Attribute::Test::CONFIRM)
                    {
                        if (results.size() == 0)
                        {
                            Sound::Play(Sound::Type::DICE_ROLL);

                            results = Engine::ROLL_DICE(skill_score);
                        }
                    }

                    auto row = 0;
                    auto col = 0;

                    auto offsety = starty + infoh + boxh + box_space + infoh + box_space;
                    auto offsetx = startx + box_space;

                    for (auto i = 0; i < results.size(); i++)
                    {
                        if (results[i] >= 1 && results[i] <= 6)
                        {
                            auto result = results[i] - 1;

                            fitImage(renderer, dice[result], offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);

                            if (stage == Attribute::Test::CHECK || stage == Attribute::Test::MAGIC)
                            {
                                if (results[i] >= (difficulty - focus))
                                {
                                    thickRect(renderer, size_dice, size_dice, offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), intLB, 2);

                                    if (stage == Attribute::Test::CHECK)
                                    {
                                        success_counter += 1;
                                    }
                                }
                            }

                            if (col < cols)
                            {
                                col += 1;
                            }
                            else
                            {
                                col = 0;

                                row += 1;
                            }
                        }
                    }

                    if (stage == Attribute::Test::CHECK)
                    {
                        if (!skill_checked)
                        {
                            party.RecentSuccesses = success_counter;

                            if (success_counter >= success)
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                displayMessage("Skill Check PASSED!", intLB);

                                test_result = true;
                            }
                            else
                            {
                                Sound::Play(Sound::Type::FAIL);

                                displayMessage("Skill Check FAILED!", intRD);

                                test_result = false;
                            }

                            skill_checked = true;
                        }
                    }
                }

                std::string test_string = std::string(Attribute::Descriptions[Skill]) + ": " + std::to_string(difficulty - focus) + "+, Success: " + (success > 0 ? std::to_string(success) : std::string("Special"));

                test_string += ", Focus: " + std::to_string(focus);

                if (skill_checked)
                {
                    test_string += " - ";

                    if (test_result)
                    {
                        test_string += "Passed";
                    }
                    else
                    {
                        test_string += "Failed";
                    }
                }

                putHeader(renderer, test_string.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, fullwidth, infoh, startx, starty + 2 * infoh + 4 * boxh + 2 * box_space);

                putHeader(renderer, party.Members[team[0]].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty);

                fillRect(renderer, boxwidth, boxh, startx, starty + infoh, intBE);

                if (!computed_score1)
                {
                    if (useEquipment)
                    {
                        if (Skill == Attribute::Type::FIGHTING)
                        {
                            score1 = Engine::SCORE(party.Members[team[0]], Attribute::Type::FIGHTING);

                            if (!Engine::VERIFY_CODES(party, {Codes::Type::TWO_HANDED_DISABLED}))
                            {
                                if (Engine::HAS_WEAPON(party.Members[team[0]]))
                                {
                                    score1 += Engine::MAX_WEAPON(party.Members[team[0]]);
                                }
                            }
                            else
                            {
                                if (Engine::HAS_ONE_HANDED_WEAPON(party.Members[team[0]]))
                                {
                                    score1 += Engine::MAX_ONE_HANDED(party.Members[team[0]]);
                                }
                            }

                            score1 -= (focus * 5);
                        }
                        else
                        {
                            score1 = Engine::SCORE(party.Members[team[0]], Skill) - (focus * 5);
                        }
                    }
                    else
                    {
                        if (Skill == Attribute::Type::FIGHTING)
                        {
                            score1 = Engine::SCORE(party.Members[team[0]], Attribute::Type::FIGHTING) - (focus * 5);
                        }
                        else
                        {
                            score1 = Engine::RAW_SCORE(party.Members[team[0]], Skill, true) - (focus * 5);
                        }
                    }

                    if (score1 < 0)
                    {
                        score1 = 0;
                    }

                    computed_score1 = true;

                    skill_score = score1;
                }

                std::string adventurer1 = std::string(Attribute::Descriptions[Skill]) + ": " + std::to_string(score1);

                putText(renderer, adventurer1.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx, starty + infoh);

                if (team.size() > 1)
                {
                    putHeader(renderer, party.Members[team[1]].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx + boxwidth + marginx, starty);

                    fillRect(renderer, boxwidth, boxh, startx + boxwidth + marginx, starty + infoh, intBE);

                    if (!computed_score2)
                    {
                        if (useEquipment)
                        {
                            if (Skill == Attribute::Type::FIGHTING)
                            {
                                score2 = Engine::SCORE(party.Members[team[1]], Attribute::Type::FIGHTING);

                                if (!Engine::VERIFY_CODES(party, {Codes::Type::TWO_HANDED_DISABLED}))
                                {
                                    if (Engine::HAS_WEAPON(party.Members[team[1]]))
                                    {
                                        score2 += Engine::MAX_WEAPON(party.Members[team[1]]);
                                    }
                                }
                                else
                                {
                                    if (Engine::HAS_ONE_HANDED_WEAPON(party.Members[team[1]]))
                                    {
                                        score2 += Engine::MAX_ONE_HANDED(party.Members[team[1]]);
                                    }
                                }

                                score2 -= (focus * 5);
                            }
                            else
                            {
                                score2 = Engine::SCORE(party.Members[team[1]], Skill) - (focus * 5);
                            }
                        }
                        else
                        {
                            if (Skill == Attribute::Type::FIGHTING)
                            {
                                score2 = Engine::SCORE(party.Members[team[1]], Attribute::Type::FIGHTING) - (focus * 5);
                            }
                            else
                            {
                                score2 = Engine::RAW_SCORE(party.Members[team[1]], Skill, true) - (focus * 5);
                            }
                        }

                        if (score2 < 0)
                        {
                            score2 = 0;
                        }

                        computed_score2 = true;

                        skill_score += score2;
                    }

                    std::string adventurer2 = std::string(Attribute::Descriptions[Skill]) + ": " + std::to_string(score2);

                    putText(renderer, adventurer2.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx + boxwidth + marginx, starty + infoh);
                }

                if (skill_score > 20)
                {
                    skill_score = 20;
                }

                if (stage == Attribute::Test::START)
                {
                    controls = controls_skill;
                }
                else if (stage == Attribute::Test::CONFIRM)
                {
                    controls = controls_confirm;
                }
                else if (stage == Attribute::Test::CHECK)
                {
                    if (test_result)
                    {
                        controls = controls_end;
                    }
                    else
                    {
                        if (Skill == Attribute::Type::SURVIVAL && Engine::CAN_CAST(party, team_type, Spells::Type::WOLF_SPIRIT) && ((success_counter + 3) >= success))
                        {
                            stage = Attribute::Test::MAGIC;

                            controls = controls_wolfspirit;
                        }
                        else if (Skill == Attribute::Type::LORE && Engine::CAN_CAST(party, team_type, Spells::Type::WISDOM) && ((success_counter + 3) >= success))
                        {
                            stage = Attribute::Test::MAGIC;

                            controls = controls_wisdom;
                        }
                        else if (Skill == Attribute::Type::CHARISMA && (Engine::CAN_CAST(party, team_type, Spells::Type::SILVER_TONGUE) || Engine::VERIFY_EQUIPMENT(party, team_type, {Equipment::Type::POTION_OF_CHARISMA})) && ((success_counter + 3) >= success))
                        {
                            auto has_spells = Engine::CAN_CAST(party, team_type, Spells::Type::SILVER_TONGUE);
                            auto has_potion = Engine::VERIFY_EQUIPMENT(party, team_type, {Equipment::Type::POTION_OF_CHARISMA});

                            stage = Attribute::Test::MAGIC;

                            if (has_spells && has_potion)
                            {
                                controls = controls_silvertongue_potion;
                            }
                            else if (has_spells)
                            {
                                controls = controls_silvertongue;
                            }
                            else if (has_potion)
                            {
                                controls = controls_charisma_potion;
                            }
                            else
                            {
                                controls = controls_end;
                            }
                        }
                        else
                        {
                            controls = controls_end;
                        }
                    }
                }

                if (flash_message)
                {
                    if ((SDL_GetTicks() - start_ticks) < duration)
                    {
                        putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                    }
                    else
                    {
                        flash_message = false;
                    }
                }

                renderTextButtons(renderer, controls, FONT_MASON, current, clrWH, intDB, intLB, font_size, TTF_STYLE_NORMAL);

                Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

                if (selected && current >= 0 && current < controls.size())
                {
                    if (stage == Attribute::Test::START && controls[current].Type == Control::Type::CONFIRM)
                    {
                        stage = Attribute::Test::CONFIRM;
                    }
                    else if (stage == Attribute::Test::START && controls[current].Type == Control::Type::PLUS)
                    {
                        if (team.size() > 1)
                        {
                            if ((score1 - 5) > 0 && (score2 - 5) > 0)
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                computed_score1 = false;

                                computed_score2 = false;

                                focus += 1;
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("You cannot add more focus points!", intRD);
                            }
                        }
                        else
                        {
                            if ((score1 - 5) > 0)
                            {
                                computed_score1 = false;

                                focus += 1;
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("You cannot add more focus points!", intRD);
                            }
                        }

                        selected = false;
                    }
                    else if (stage == Attribute::Test::START && controls[current].Type == Control::Type::MINUS)
                    {
                        if (focus > 0)
                        {
                            focus -= 1;

                            computed_score1 = false;

                            computed_score2 = false;
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("All focus points have been removed!", intRD);
                        }

                        selected = false;
                    }
                    else if (stage == Attribute::Test::CONFIRM && controls[current].Type == Control::Type::CONFIRM)
                    {
                        stage = Attribute::Test::CHECK;
                    }
                    else if (stage == Attribute::Test::MAGIC && controls[current].Type == Control::Type::CONFIRM)
                    {
                        stage = Attribute::Test::END;

                        if (Skill == Attribute::Type::SURVIVAL)
                        {
                            Sound::Play(Sound::Type::SUCCESS);

                            Engine::CAST_SPELL(party, team_type, Spells::Type::WOLF_SPIRIT);

                            party.RecentSuccesses += 3;

                            test_result = true;
                        }
                        else if (Skill == Attribute::Type::LORE)
                        {
                            Sound::Play(Sound::Type::SUCCESS);

                            Engine::CAST_SPELL(party, team_type, Spells::Type::WISDOM);

                            party.RecentSuccesses += 3;

                            test_result = true;
                        }
                        else if (Skill == Attribute::Type::CHARISMA)
                        {
                            Sound::Play(Sound::Type::SUCCESS);

                            Engine::CAST_SPELL(party, team_type, Spells::Type::SILVER_TONGUE);

                            party.RecentSuccesses += 3;

                            test_result = true;
                        }

                        done = true;

                        current = -1;

                        selected = false;
                    }
                    else if (stage == Attribute::Test::MAGIC && controls[current].Type == Control::Type::DRINK)
                    {
                        stage = Attribute::Test::END;

                        if (Skill == Attribute::Type::CHARISMA)
                        {
                            Sound::Play(Sound::Type::SUCCESS);

                            Engine::LOSE_EQUIPMENT(party, team_type, {Equipment::Type::POTION_OF_CHARISMA});

                            party.RecentSuccesses += 3;

                            test_result = true;
                        }

                        done = true;

                        current = -1;

                        selected = false;
                    }
                    else if (stage == Attribute::Test::MAGIC && controls[current].Type == Control::Type::BACK)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        stage = Attribute::Test::END;

                        done = true;

                        current = -1;

                        selected = false;
                    }
                    else if (stage == Attribute::Test::CHECK && controls[current].Type == Control::Type::BACK)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        stage = Attribute::Test::END;

                        done = true;

                        current = -1;

                        selected = false;
                    }
                }
            }

            if (font_mason)
            {
                TTF_CloseFont(font_mason);

                font_mason = NULL;
            }

            if (font_garamond)
            {
                TTF_CloseFont(font_garamond);

                font_garamond = NULL;
            }

            TTF_Quit();

            for (auto i = 0; i < 6; i++)
            {
                if (dice[i])
                {
                    SDL_FreeSurface(dice[i]);

                    dice[i] = NULL;
                }
            }
        }

        if (team.size() > 0)
        {
            party.LastSelection = team;

            if (team.size() == 1)
            {
                party.LastSelected = team[0];
            }
        }
    }

    return test_result;
}

bool magicRound0(Character::Base &character, int combatRound)
{
    auto result = true;

    result &= (!Engine::HAS_STATUS(character, Character::Status::EXTRA_MAGIC_ROUND0) || (Engine::HAS_STATUS(character, Character::Status::EXTRA_MAGIC_ROUND0) && combatRound != 0));
    result &= (!Engine::HAS_STATUS(character, Character::Status::UNLIMITED_MAGIC_ROUND0) || (Engine::HAS_STATUS(character, Character::Status::UNLIMITED_MAGIC_ROUND0) && combatRound != 0));

    return result;
}

int castCombatSpell(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Monster::Base> &monsters, std::vector<int> hasAttacked, int combatRound)
{
    auto result = -1;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Cast Spell");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > party.Members.size())
        {
            last = party.Members.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, true);

        auto done = false;

        auto selection = -1;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            putHeader(renderer, "Select Caster", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (selection == offset + i)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else if (Engine::IS_ALIVE(party.Members[offset + i]))
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection >= 0 && selection < party.Members.size())
            {
                putText(renderer, party.Members[selection].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }
            else
            {
                putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if (selected && current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;

                    current = -1;

                    selected = false;

                    result = -1;
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if (selection >= 0 && selection < party.Members.size())
                    {
                        if (party.Members[selection].SpellCaster && Engine::CAN_SPEAK(party.Members[selection]) && !Engine::IS_CAPTURED(party.Members[selection]) && !Engine::IS_CURSED(party.Members[selection]))
                        {
                            if (hasAttacked.size() > 0 && Engine::FIND_LIST(hasAttacked, selection) >= 0 && magicRound0(party.Members[selection], combatRound))
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[selection].Name + " already attacked this turn!", intRD);
                            }
                            else
                            {
                                auto spell = selectSpell(window, renderer, party.Book, party.Members[selection], party.Members[selection].SpellBook, 1, Spells::Select::CAST_SPELL);

                                if (spell.size() > 0)
                                {
                                    auto i = spell[0];

                                    if (party.Members[selection].SpellBook[i].Scope == Spells::Scope::COMBAT || party.Members[selection].SpellBook[i].Scope == Spells::Scope::ADVENTURE_COMBAT)
                                    {
                                        auto cast = false;

                                        if (party.Members[selection].SpellBook[i].Type == Spells::Type::ARMOUR_OF_HEAVEN)
                                        {
                                            auto target = -1;

                                            if (Engine::COUNT(party, team) == 1)
                                            {
                                                if (team == Team::Type::NONE)
                                                {
                                                    target = Engine::FIRST(party);
                                                }
                                                else
                                                {
                                                    target = Engine::FIRST(party, team);
                                                }
                                            }
                                            else
                                            {
                                                target = selectPartyMember(window, renderer, party, team, Equipment::NONE, Control::Type::SPELL_TARGET);
                                            }

                                            if (Engine::IS_ACTIVE(party, target))
                                            {
                                                if (Engine::HAS_STATUS(party.Members[target], Character::Status::ARMOUR3))
                                                {
                                                    Sound::Play(Sound::Type::ERROR);

                                                    displayMessage(party.Members[target].Name + " already has the " + party.Members[selection].SpellBook[i].Name + "!", intRD);
                                                }
                                                else
                                                {
                                                    Engine::GAIN_STATUS(party.Members[target], Character::Status::ARMOUR3);

                                                    cast = true;
                                                }
                                            }
                                            else
                                            {
                                                Sound::Play(Sound::Type::ERROR);

                                                displayMessage(party.Members[target].Name + " is an invalid target!", intRD);
                                            }
                                        }
                                        else if (party.Members[selection].SpellBook[i].Type == Spells::Type::SOOTHING_TOUCH)
                                        {
                                            auto target = -1;

                                            if (Engine::COUNT(party, team) == 1)
                                            {
                                                if (team == Team::Type::NONE)
                                                {
                                                    target = Engine::FIRST(party);
                                                }
                                                else
                                                {
                                                    target = Engine::FIRST(party, team);
                                                }
                                            }
                                            else
                                            {
                                                target = selectPartyMember(window, renderer, party, team, Equipment::NONE, Control::Type::SPELL_TARGET);
                                            }

                                            if (target >= 0 && target < party.Members.size())
                                            {
                                                if (party.Members[target].Health <= 0 || party.Members[target].Health == party.Members[target].MaximumHealth)
                                                {
                                                    message = party.Members[target].Name;

                                                    if (party.Members[target].Health <= 0)
                                                    {
                                                        message += " is dead!";
                                                    }
                                                    else
                                                    {
                                                        message += " is not injured!";
                                                    }

                                                    Sound::Play(Sound::Type::ERROR);

                                                    displayMessage(message, intRD);
                                                }
                                                else
                                                {
                                                    if (Engine::IS_ACTIVE(party, target))
                                                    {
                                                        Engine::GAIN_HEALTH(party.Members[target], 5);

                                                        cast = true;
                                                    }
                                                    else
                                                    {
                                                        Sound::Play(Sound::Type::ERROR);

                                                        displayMessage(party.Members[target].Name + " is an invalid target!", intRD);
                                                    }
                                                }
                                            }
                                        }
                                        else if (party.Members[selection].SpellBook[i].Type == Spells::Type::DAZING_LIGHTS)
                                        {
                                            if (Engine::VERIFY_CODES(party, {Codes::Type::DAZING_LIGHTS}))
                                            {
                                                Sound::Play(Sound::Type::ERROR);

                                                displayMessage("Dazing Lights has already been cast!", intRD);
                                            }
                                            else
                                            {
                                                Engine::GET_CODES(party, {Codes::Type::DAZING_LIGHTS});

                                                cast = true;
                                            }
                                        }
                                        else if (party.Members[selection].SpellBook[i].Type == Spells::Type::ICE_BOLT)
                                        {
                                            if (Engine::COUNT(monsters, combatRound) > 0)
                                            {
                                                auto target = -1;

                                                if (Engine::COUNT(monsters, combatRound) == 1)
                                                {
                                                    target = Engine::FIRST(monsters, combatRound);
                                                }
                                                else
                                                {
                                                    target = selectOpponent(window, renderer, party, selection, monsters, {}, combatRound, Control::Type::SPELL);
                                                }

                                                if (target >= 0)
                                                {
                                                    auto damage = magicAttackScreen(window, renderer, party, monsters, party.Members[selection].SpellBook[i], selection, target, 8);

                                                    if (damage >= 0)
                                                    {
                                                        cast = true;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                Sound::Play(Sound::Type::ERROR);

                                                displayMessage("There are no targets for " + party.Members[selection].SpellBook[i].Name + "!", intRD);
                                            }
                                        }
                                        else if (party.Members[selection].SpellBook[i].Type == Spells::Type::UNFAILING_STRIKE)
                                        {
                                            if (Engine::COUNT(monsters, combatRound) > 0)
                                            {
                                                auto target = -1;

                                                if (Engine::COUNT(monsters, combatRound) == 1)
                                                {
                                                    target = Engine::FIRST(monsters, combatRound);
                                                }
                                                else
                                                {
                                                    target = selectOpponent(window, renderer, party, selection, monsters, {}, combatRound, Control::Type::SPELL);
                                                }

                                                if (target >= 0)
                                                {
                                                    if (monsters[target].Type == Monster::Type::FASTILON && !monsters[target].Damaged)
                                                    {
                                                        Engine::GAIN_STATUS(party.Members[selection], Character::Status::STUNNED_NEXT_ROUND);
                                                    }

                                                    Engine::GAIN_HEALTH(monsters[target], -3);

                                                    cast = true;
                                                }
                                            }
                                            else
                                            {
                                                Sound::Play(Sound::Type::ERROR);

                                                displayMessage("There are no targets for " + party.Members[selection].SpellBook[i].Name + "!", intRD);
                                            }
                                        }
                                        else if (party.Members[selection].SpellBook[i].Type == Spells::Type::POISON_STREAM)
                                        {
                                            if (Engine::COUNT(monsters, combatRound) > 0)
                                            {
                                                auto max_targets = std::min<int>(2, Engine::COUNT(monsters, combatRound));

                                                auto targets = std::vector<int>();

                                                while (targets.size() < max_targets)
                                                {
                                                    auto target = -1;

                                                    if (Engine::COUNT(monsters, combatRound) == 1)
                                                    {
                                                        target = Engine::FIRST(monsters, combatRound);
                                                    }
                                                    else
                                                    {
                                                        target = selectOpponent(window, renderer, party, selection, monsters, targets, combatRound, Control::Type::SPELL);
                                                    }

                                                    if (target >= 0)
                                                    {
                                                        auto damage = magicAttackScreen(window, renderer, party, monsters, party.Members[selection].SpellBook[i], selection, target, 5);

                                                        if (damage >= 0)
                                                        {
                                                            targets.push_back(target);

                                                            cast = true;
                                                        }
                                                        else
                                                        {
                                                            break;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        break;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                Sound::Play(Sound::Type::ERROR);

                                                displayMessage("There are no targets for " + party.Members[selection].SpellBook[i].Name + "!", intRD);
                                            }
                                        }
                                        else if (party.Members[selection].SpellBook[i].Type == Spells::Type::SANDSTORM)
                                        {
                                            if (Engine::COUNT(monsters, combatRound) > 0)
                                            {
                                                auto max_targets = Engine::COUNT(monsters, combatRound);

                                                auto targets = std::vector<int>();

                                                while (targets.size() < max_targets)
                                                {
                                                    auto target = -1;

                                                    if (Engine::COUNT(monsters, combatRound) == 1)
                                                    {
                                                        target = Engine::FIRST(monsters, combatRound);
                                                    }
                                                    else
                                                    {
                                                        target = selectOpponent(window, renderer, party, selection, monsters, targets, combatRound, Control::Type::SPELL);
                                                    }

                                                    if (target >= 0)
                                                    {
                                                        auto damage = magicAttackScreen(window, renderer, party, monsters, party.Members[selection].SpellBook[i], selection, target, 3);

                                                        if (damage >= 0)
                                                        {
                                                            targets.push_back(target);

                                                            cast = true;
                                                        }
                                                        else
                                                        {
                                                            break;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        break;
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                Sound::Play(Sound::Type::ERROR);

                                                displayMessage("There are no targets for " + party.Members[selection].SpellBook[i].Name + "!", intRD);
                                            }
                                        }

                                        if (cast)
                                        {
                                            if (party.Location == Location::Type::SALTDAD_ARENA && Engine::VERIFY_CODES(party, {Codes::Type::WARNED_ABOUT_ARENA_MAGIC}))
                                            {
                                                Engine::GAIN_STATUS(party.Members[selection], Character::Status::USED_MAGIC_INARENA);
                                            }

                                            party.Members[selection].SpellBook[i].Charged = false;

                                            result = selection;

                                            Sound::Play(Sound::Type::BUTTON_CLICK);

                                            done = true;
                                        }
                                    }
                                    else
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[selection].Name + " cannot cast " + party.Members[selection].SpellBook[spell[0]].Name + " during combat!", intRD);
                                    }
                                }
                                else
                                {
                                    selected = false;

                                    current = -1;
                                }
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(party.Members[selection].Name + " cannot cast spells!", intRD);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You must select the adventurer to cast a spell.", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < party.Members.size())
                    {
                        if (selection == current + offset)
                        {
                            selection = -1;
                        }
                        else
                        {
                            if (Engine::IS_ALIVE(party.Members[current + offset]))
                            {
                                if (team == Team::Type::NONE || party.Members[current + offset].Team == team)
                                {
                                    selection = current + offset;
                                }
                                else
                                {
                                    if (!Engine::IS_CHARACTER(team))
                                    {
                                        message = party.Members[current + offset].Name + " is not part of the " + std::string(Team::Descriptions[team]) + " team!";
                                    }
                                    else
                                    {
                                        message = "You can only choose " + std::string(Team::Descriptions[team]) + "!";
                                    }

                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage(message, intRD);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[current + offset].Name + " is dead!", intRD);
                            }
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return result;
}

int castMassCombatSpell(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Army::Base> &enemyArmy, Location::Type battlefield, std::vector<int> castSpells, int combatRound)
{
    auto caster = -1;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Cast Mass Combat Spell");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > party.Members.size())
        {
            last = party.Members.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, true);

        auto done = false;

        auto selection = -1;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            putHeader(renderer, "Select Caster", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (selection == offset + i)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else if (Engine::IS_ALIVE(party.Members[offset + i]))
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection >= 0 && selection < party.Members.size())
            {
                putText(renderer, party.Members[selection].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }
            else
            {
                putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if (selected && current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;

                    current = -1;

                    selected = false;

                    caster = -1;
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if (selection >= 0 && selection < party.Members.size())
                    {
                        if (party.Members[selection].SpellCaster && Engine::CAN_SPEAK(party.Members[selection]) && !Engine::IS_CAPTURED(party.Members[selection]))
                        {
                            auto spell = selectSpell(window, renderer, party.Book, party.Members[selection], party.Members[selection].SpellBook, 1, Spells::Select::CAST_SPELL);

                            if (spell.size() > 0)
                            {
                                auto i = spell[0];

                                if (party.Members[selection].SpellBook[i].Scope == Spells::Scope::MASS_COMBAT)
                                {
                                    auto cast = false;

                                    if (party.Members[selection].SpellBook[i].Type == Spells::Type::CLINGING_DREAD)
                                    {
                                        if (Engine::COUNT(enemyArmy) > 0)
                                        {
                                            auto target = selectArmyUnits(window, renderer, party.Book, enemyArmy, Location::Type::NONE, 1);

                                            if (target.size() > 0)
                                            {
                                                if (target[0] >= 0 && target[0] < enemyArmy.size())
                                                {
                                                    Engine::GAIN_MORALE(enemyArmy[target[0]], -1);

                                                    Engine::UPDATE_ARMY(enemyArmy, Location::Type::NONE);

                                                    cast = true;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            Sound::Play(Sound::Type::ERROR);

                                            displayMessage("There are no targets for " + party.Members[selection].SpellBook[i].Name + "!", intRD);
                                        }
                                    }

                                    if (cast)
                                    {
                                        Sound::Play(Sound::Type::BUTTON_CLICK);

                                        party.Members[selection].SpellBook[i].Charged = false;

                                        caster = selection;

                                        done = true;
                                    }
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage(party.Members[selection].Name + " cannot cast " + party.Members[selection].SpellBook[spell[0]].Name + " during combat!", intRD);
                                }
                            }
                            else
                            {
                                selected = false;

                                current = -1;
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(party.Members[selection].Name + " cannot cast spells!", intRD);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You must select the adventurer to cast a spell.", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < party.Members.size())
                    {
                        if (Engine::FIND_LIST(castSpells, current + offset) >= 0)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(party.Members[current + offset].Name + " already cast a spell this round!", intRD);
                        }
                        else if (Engine::IS_ACTIVE(party, current + offset))
                        {
                            if (Engine::CAN_SPEAK(party.Members[current + offset]))
                            {
                                selection = current + offset;
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[current + offset].Name + " cannot cast spells", intRD);
                            }
                        }
                        else if (Engine::IS_ALIVE(party.Members[current + offset]))
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(party.Members[current + offset].Name + " has been captured!", intRD);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(party.Members[current + offset].Name + " is dead!", intRD);
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return caster;
}

int castSeaCombatSpell(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Ship::Base> &enemyFleet, std::vector<int> castSpells, int combatRound)
{
    auto caster = -1;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Cast Sea Combat Spell");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > party.Members.size())
        {
            last = party.Members.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, true);

        auto done = false;

        auto selection = -1;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            putHeader(renderer, "Select Caster", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (selection == offset + i)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else if (Engine::IS_ALIVE(party.Members[offset + i]))
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection >= 0 && selection < party.Members.size())
            {
                putText(renderer, party.Members[selection].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }
            else
            {
                putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if (selected && current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;

                    current = -1;

                    selected = false;

                    caster = -1;
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if (selection >= 0 && selection < party.Members.size())
                    {
                        if (party.Members[selection].SpellCaster && Engine::CAN_SPEAK(party.Members[selection]) && !Engine::IS_CAPTURED(party.Members[selection]))
                        {
                            auto spell = selectSpell(window, renderer, party.Book, party.Members[selection], party.Members[selection].SpellBook, 1, Spells::Select::CAST_SPELL);

                            if (spell.size() > 0)
                            {
                                auto i = spell[0];

                                if (party.Members[selection].SpellBook[i].Scope == Spells::Scope::SEA_COMBAT)
                                {
                                    auto cast = false;

                                    if (party.Members[selection].SpellBook[i].Type == Spells::Type::WARP_WOOD)
                                    {
                                        if (Engine::COUNT(enemyFleet) > 0)
                                        {
                                            auto target = selectShip(window, renderer, party.Book, enemyFleet, Location::Type::NONE, {}, Control::Type::SPELL_TARGET);

                                            if (target >= 0 && target < enemyFleet.size())
                                            {
                                                Engine::GAIN_HEALTH(enemyFleet[target], -3);

                                                cast = true;
                                            }
                                        }
                                        else
                                        {
                                            Sound::Play(Sound::Type::ERROR);

                                            displayMessage("There are no targets for " + party.Members[selection].SpellBook[i].Name + "!", intRD);
                                        }
                                    }

                                    if (cast)
                                    {
                                        party.Members[selection].SpellBook[i].Charged = false;

                                        caster = selection;

                                        done = true;
                                    }
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage(party.Members[selection].Name + " cannot cast " + party.Members[selection].SpellBook[spell[0]].Name + " during combat!", intRD);
                                }
                            }
                            else
                            {
                                selected = false;

                                current = -1;
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(party.Members[selection].Name + " cannot cast spells!", intRD);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You must select the adventurer to cast a spell.", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < party.Members.size())
                    {
                        if (Engine::FIND_LIST(castSpells, current + offset) >= 0)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(party.Members[current + offset].Name + " already cast a spell this round!", intRD);
                        }
                        else if (Engine::IS_ACTIVE(party, current + offset))
                        {
                            if (Engine::CAN_SPEAK(party.Members[current + offset]))
                            {
                                selection = current + offset;
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[current + offset].Name + " cannot cast spells!", intRD);
                            }
                        }
                        else if (Engine::IS_ALIVE(party.Members[current + offset]))
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(party.Members[current + offset].Name + " has been captured!", intRD);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(party.Members[current + offset].Name + " is dead!", intRD);
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return caster;
}

bool skillCheck(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, int team_size, Attribute::Type skill, int difficulty, int success, std::vector<int> &selection, bool useEquipment)
{
    if (skill == Attribute::Type::CHARISMA && Engine::VERIFY_CODES(party, {Codes::Type::CHARISMA_SUCCESS_CHALICE}) && party.Location == Location::Type::CHALICE && party.InCity == true)
    {
        return true;
    }

    auto result = false;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Skill Check");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > party.Members.size())
        {
            last = party.Members.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, true);

        auto done = false;

        selection = std::vector<int>();

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            if (team_size > 1)
            {
                putHeader(renderer, "Select Adventurers", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else
            {
                putHeader(renderer, "Select Adventurer", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            for (auto i = offset; i < last; i++)
            {
                auto index = i - offset;

                if (index >= 0 && index < party.Members.size())
                {
                    if (Engine::FIND_LIST(selection, index) >= 0)
                    {
                        thickRect(renderer, controls[index].W + border_pts, controls[index].H + border_pts, controls[index].X - 2, controls[index].Y - 2, intLB, 2);
                    }
                    else if (Engine::IS_ALIVE(party.Members[index]))
                    {
                        if (team != Team::Type::NONE)
                        {
                            if (party.Members[index].Team == team)
                            {
                                drawRect(renderer, controls[index].W + border_space, controls[index].H + border_space, controls[index].X - border_pts, controls[index].Y - border_pts, intBK);
                            }
                            else
                            {
                                thickRect(renderer, controls[index].W + border_pts, controls[index].H + border_pts, controls[index].X - 2, controls[index].Y - 2, intGR, 2);
                            }
                        }
                        else
                        {
                            drawRect(renderer, controls[index].W + border_space, controls[index].H + border_space, controls[index].X - border_pts, controls[index].Y - border_pts, intBK);
                        }
                    }
                    else
                    {
                        drawRect(renderer, controls[index].W + border_space, controls[index].H + border_space, controls[index].X - border_pts, controls[index].Y - border_pts, intRD);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection.size() >= 0)
            {
                std::string adventurers = "";

                for (auto i = 0; i < selection.size(); i++)
                {
                    if (selection[i] >= 0 && selection[i] < party.Members.size())
                    {
                        if (Engine::IS_ALIVE(party.Members[selection[i]]))
                        {
                            if (adventurers.length() > 0)
                            {
                                adventurers += "\n";
                            }

                            adventurers += party.Members[selection[i]].Name;
                        }
                    }
                }

                if (adventurers.length() > 0)
                {
                    putText(renderer, adventurers.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
            }
            else
            {
                putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if (selected && current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;

                    current = -1;

                    selected = false;

                    selection = {};
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if ((selection.size() >= team_size && selection.size() <= party.Members.size()) || (selection.size() == Engine::COUNT(party, team) && selection.size() <= team_size))
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        done = true;

                        result = skillTestScreen(window, renderer, party, team, selection, skill, difficulty, success, useEquipment);

                        current = -1;

                        selected = false;
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You must select the adventurer(s) who will perform the skill check.", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < party.Members.size())
                    {
                        auto index = Engine::FIND_LIST(selection, current + offset);

                        if (index >= 0)
                        {
                            selection.erase(selection.begin() + index);
                        }
                        else
                        {
                            if (selection.size() < team_size)
                            {
                                if (Engine::IS_ALIVE(party.Members[current + offset]))
                                {
                                    if (team == Team::Type::NONE)
                                    {
                                        selection.push_back(current + offset);
                                    }
                                    else if (party.Members[current + offset].Team == team)
                                    {
                                        selection.push_back(current + offset);
                                    }
                                    else
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[current + offset].Name + " is not part of the " + std::string(Team::Descriptions[team]) + " team!", intRD);
                                    }
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage(party.Members[current + offset].Name + " is dead!", intRD);
                                }
                            }
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return result;
}

Attribute::Type selectAttribute(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Character::Base &character, int increase)
{
    auto result = Attribute::Type::NONE;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Select Attribute");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto fg = Color::HEADER(book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        std::vector<Attribute::Type> attributes = {Attribute::Type::FIGHTING, Attribute::Type::STEALTH, Attribute::Type::LORE, Attribute::Type::SURVIVAL, Attribute::Type::CHARISMA};

        if (last > attributes.size())
        {
            last = attributes.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = attributeList(window, renderer, character, attributes, offset, last, limit, textx, texty + infoh + text_space);

        auto done = false;

        auto selection = -1;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        auto scrollSpeed = 1;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            std::string select_string = "Which of " + character.Name + "'s attributes will be raised by " + std::to_string(increase) + "?";

            putHeader(renderer, select_string.c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (selection == offset + i)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            putHeader(renderer, "Attribute", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection >= 0 && selection < attributes.size())
            {
                putText(renderer, Attribute::Descriptions[attributes[selection]], font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }
            else
            {
                fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > attributes.size())
                        {
                            last = attributes.size();
                        }

                        controls = attributeList(window, renderer, character, attributes, offset, last, limit, textx, texty + infoh + text_space);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (attributes.size() - last > 0)
                    {
                        if (offset < attributes.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > attributes.size() - limit)
                        {
                            offset = attributes.size() - limit;
                        }

                        last = offset + limit;

                        if (last > attributes.size())
                        {
                            last = attributes.size();
                        }

                        controls = attributeList(window, renderer, character, attributes, offset, last, limit, textx, texty + infoh + text_space);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (attributes.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if (selection >= 0 && selection < attributes.size())
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        done = true;

                        result = attributes[selection];

                        current = -1;

                        selected = false;
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        flash_message = true;

                        message = "You must select an ATTRIBUTE!";

                        start_ticks = SDL_GetTicks();

                        flash_color = intRD;

                        Sound::Play(Sound::Type::ERROR);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < attributes.size())
                    {
                        if (selection == current + offset)
                        {
                            selection = -1;
                        }
                        else
                        {
                            selection = current + offset;
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return result;
}

bool selectTeam(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Character::Base &character, std::vector<Engine::TeamAssignment> teams)
{
    auto result = false;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Select Team");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto fg = Color::HEADER(book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);

        auto teams_list = std::vector<Team::Type>();

        for (auto i = 0; i < teams.size(); i++)
        {
            teams_list.push_back(std::get<0>(teams[i]));
        }

        teams_list.push_back(Team::Type::NONE);

        auto last = offset + limit;

        if (last > teams_list.size())
        {
            last = teams_list.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = teamsList(window, renderer, teams_list, offset, last, limit, textx, texty + infoh + text_space);

        auto done = false;

        auto selection = -1;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        auto scrollSpeed = 1;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            putHeader(renderer, "Select Team", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (selection == offset + i)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection >= 0 && selection < teams_list.size())
            {
                putText(renderer, Team::Descriptions[teams_list[selection]], font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }
            else
            {
                putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > teams_list.size())
                        {
                            last = teams_list.size();
                        }

                        controls = teamsList(window, renderer, teams_list, offset, last, limit, textx, texty + infoh + text_space);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (teams_list.size() - last > 0)
                    {
                        if (offset < teams_list.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > teams_list.size() - limit)
                        {
                            offset = teams_list.size() - limit;
                        }

                        last = offset + limit;

                        if (last > teams_list.size())
                        {
                            last = teams_list.size();
                        }

                        controls = teamsList(window, renderer, teams_list, offset, last, limit, textx, texty + infoh + text_space);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (teams_list.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    if (selection >= 0 && selection < teams_list.size())
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        character.Team = teams_list[selection];

                        selected = false;

                        current = -1;

                        done = true;
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current + offset >= 0 && current + offset < teams_list.size())
                    {
                        if (selection == current + offset)
                        {
                            selection = -1;
                        }
                        else
                        {
                            selection = current + offset;
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return result;
}

bool assignTeams(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Engine::TeamAssignment> teams, int min_teams)
{
    auto result = false;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Assign Party Members to Teams");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > party.Members.size())
        {
            last = party.Members.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, false);

        auto done = false;

        auto selection = -1;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        auto scrollSpeed = 1;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            putHeader(renderer, "Assign Party Member to a Team", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            putHeader(renderer, "Teams", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (teams.size() > 0)
            {
                std::string teams_string = "";

                for (auto i = 0; i < teams.size(); i++)
                {
                    if (i > 0)
                    {
                        teams_string += ", ";
                    }

                    teams_string += std::string(Team::Descriptions[std::get<0>(teams[i])]);
                }

                putText(renderer, teams_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }
            else
            {
                fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > party.Members.size())
                        {
                            last = party.Members.size();
                        }

                        controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, false);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (party.Members.size() - last > 0)
                    {
                        if (offset < party.Members.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > party.Members.size() - limit)
                        {
                            offset = party.Members.size() - limit;
                        }

                        last = offset + limit;

                        if (last > party.Members.size())
                        {
                            last = party.Members.size();
                        }

                        controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, false);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (party.Members.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    auto assignment_error = false;

                    for (auto i = 0; i < teams.size(); i++)
                    {
                        auto count = Engine::COUNT(party, std::get<0>(teams[i]));

                        if (!(count >= std::get<1>(teams[i]) && count <= std::get<2>(teams[i])))
                        {
                            assignment_error = true;
                        }
                    }

                    selection = -1;

                    current = -1;

                    selected = false;

                    if (assignment_error || Engine::COUNT_TEAMS(party) < min_teams)
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("Please complete team selection", intRD);
                    }
                    else
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        done = true;
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current + offset >= 0 && current + offset < party.Members.size())
                    {
                        selection = current + offset;

                        if (selection >= 0 && selection < party.Members.size())
                        {
                            if (Engine::IS_ALIVE(party.Members[selection]))
                            {
                                selectTeam(window, renderer, party.Book, party.Members[selection], teams);

                                controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, false);
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[selection].Name + " is dead!", intRD);
                            }
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return result;
}

int selectPartyMember(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, Equipment::Base equipment, Control::Type mode)
{
    auto result = -1;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Select Party Member");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > party.Members.size())
        {
            last = party.Members.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, true);

        auto done = false;

        auto selection = -1;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        auto scrollSpeed = 1;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            if (mode == Control::Type::COMBAT)
            {
                putHeader(renderer, "Choose the party member attacking this round", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::SPELL_TARGET)
            {
                putHeader(renderer, "Choose target for this spell", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::ROLL_FOR_ATTRIBUTE_INCREASE || mode == Control::Type::RAISE_ATTRIBUTE_SCORE)
            {
                putHeader(renderer, "Choose party member to receive attibute increase", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::SELECT_LOWEST_ATTRIBUTE)
            {
                putHeader(renderer, "Choose party member with the lowest attibute score", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::LEARN_SPELL)
            {
                putHeader(renderer, "Choose the spellcaster who learns this spell", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::EQUIPMENT)
            {
                if (equipment.Type != Equipment::Type::NONE)
                {
                    std::string equipment_string = "Give the " + equipment.Name + " to";

                    putHeader(renderer, equipment_string.c_str(), font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else
                {
                    putHeader(renderer, "Give the item(s) to", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
            }
            else if (mode == Control::Type::HEALTH)
            {
                putHeader(renderer, "Choose party member to receive Maximum Health increase", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::GAIN_HEALTH)
            {
                putHeader(renderer, "Choose party member to recover health point(s)", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::LOSE_HEALTH)
            {
                putHeader(renderer, "Choose party member to lose health point(s)", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::ENTER_SHOP)
            {
                putHeader(renderer, "Choose party member to enter shop", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::PARTY)
            {
                putHeader(renderer, "Choose party member", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else
            {
                putHeader(renderer, "Choose Party Member", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (selection == offset + i)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else if (Engine::IS_ALIVE(party.Members[offset + i]))
                    {
                        if (team != Team::Type::NONE)
                        {
                            if (party.Members[offset + i].Team == team)
                            {
                                drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                            }
                            else
                            {
                                thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intGR, 2);
                            }
                        }
                        else if (Engine::IS_CURSED(party.Members[offset + i]))
                        {
                            thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intGR, 2);
                        }
                        else
                        {
                            drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                        }
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            if (mode == Control::Type::EQUIPMENT && equipment.Type != Equipment::Type::NONE)
            {
                putHeader(renderer, "Details", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space));

                putText(renderer, itemString(equipment).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + text_bounds - 3 * boxh - infoh - box_space);
            }

            putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection >= 0 && selection < party.Members.size())
            {
                if (Engine::IS_ALIVE(party.Members[selection]))
                {
                    putText(renderer, party.Members[selection].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
            }
            else
            {
                putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > party.Members.size())
                        {
                            last = party.Members.size();
                        }

                        controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, true);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (party.Members.size() - last > 0)
                    {
                        if (offset < party.Members.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > party.Members.size() - limit)
                        {
                            offset = party.Members.size() - limit;
                        }

                        last = offset + limit;

                        if (last > party.Members.size())
                        {
                            last = party.Members.size();
                        }

                        controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, true);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (party.Members.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if (selection >= 0 && selection < party.Members.size())
                    {
                        if (mode == Control::Type::EQUIPMENT)
                        {
                            if (party.Members[selection].Type == Character::Type::SKULLCRACKER)
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("Skullcracker refuses!", intRD);
                            }
                            else
                            {
                                Sound::Play(Sound::Type::BUTTON_CLICK);

                                done = true;

                                result = selection;

                                current = -1;

                                selected = false;
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            done = true;

                            result = selection;

                            current = -1;

                            selected = false;
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You must select a party member!", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < party.Members.size())
                    {
                        if (selection == current + offset)
                        {
                            selection = -1;
                        }
                        else
                        {
                            if (Engine::IS_ALIVE(party.Members[current + offset]))
                            {
                                if (team == Team::Type::NONE || party.Members[current + offset].Team == team)
                                {
                                    if (Engine::IS_CAPTURED(party.Members[current + offset]))
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[current + offset].Name + " has been captured!", intRD);
                                    }
                                    else if (Engine::IS_CURSED(party.Members[current + offset]))
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[current + offset].Name + " is cursed!", intRD);
                                    }
                                    else if (party.InCity && !party.Members[current + offset].IsCivilized)
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[current + offset].Name + " is waiting outside the city!", intRD);
                                    }
                                    else
                                    {
                                        selection = current + offset;
                                    }
                                }
                                else
                                {
                                    if (!Engine::IS_CHARACTER(team))
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[current + offset].Name + " is not part of the " + std::string(Team::Descriptions[team]) + " team!", intRD);
                                    }
                                    else
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage("You can only choose " + std::string(Team::Descriptions[team]) + "!", intRD);
                                    }
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[current + offset].Name + " is dead!", intRD);
                            }
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    if (Engine::IS_ALIVE(party, result) && (mode == Control::Type::PARTY || mode == Control::Type::SELECT_LOWEST_ATTRIBUTE))
    {
        party.LastSelected = result;
    }

    return result;
}

int selectShip(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, std::vector<Ship::Base> ships, Location::Type location, std::vector<Cargo::Type> cargo, Control::Type mode)
{
    auto result = -1;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Select Ship");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (124);
        auto last = offset + limit;

        if (last > ships.size())
        {
            last = ships.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = shipList(window, renderer, ships, offset, last, limit, textx, texty + infoh, true, true, true);

        auto done = false;

        auto selection = -1;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        auto scrollSpeed = 1;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            if (mode == Control::Type::COMBAT)
            {
                putHeader(renderer, "Choose the ship attacking this round", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::CARGO)
            {
                putHeader(renderer, "Choose the ship to receive cargo", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::SPELL_TARGET)
            {
                putHeader(renderer, "Choose target ship for this spell", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::GAIN_HEALTH)
            {
                putHeader(renderer, "Choose the ship to repair", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::LOSE_HEALTH)
            {
                putHeader(renderer, "Choose the ship to receive damage", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::SAIL)
            {
                putHeader(renderer, "Choose the ship to board", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else
            {
                putHeader(renderer, "Choose ship", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (selection == offset + i)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else if (ships[offset + i].Health > 0)
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection >= 0 && selection < ships.size())
            {
                if (ships[selection].Health > 0)
                {
                    putText(renderer, ships[selection].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
            }
            else
            {
                putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > ships.size())
                        {
                            last = ships.size();
                        }

                        controls = shipList(window, renderer, ships, offset, last, limit, textx, texty + infoh, true, true, true);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (ships.size() - last > 0)
                    {
                        if (offset < ships.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > ships.size() - limit)
                        {
                            offset = ships.size() - limit;
                        }

                        last = offset + limit;

                        if (last > ships.size())
                        {
                            last = ships.size();
                        }

                        controls = shipList(window, renderer, ships, offset, last, limit, textx, texty + infoh, true, true, true);
                        ;

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (ships.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if (selection >= 0 && selection < ships.size())
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        done = true;

                        result = selection;

                        current = -1;

                        selected = false;
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You must select a ship!", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < ships.size())
                    {
                        if (selection == current + offset)
                        {
                            selection = -1;
                        }
                        else
                        {
                            if (ships[current + offset].Health > 0)
                            {
                                if (location == Location::Type::NONE || ships[current + offset].Location == location)
                                {
                                    if (mode == Control::Type::CARGO)
                                    {
                                        if ((ships[current + offset].MaximumCargo - ships[current + offset].Cargo.size()) >= cargo.size())
                                        {
                                            selection = current + offset;
                                        }
                                        else
                                        {
                                            Sound::Play(Sound::Type::ERROR);

                                            displayMessage("This ship does not have enough space!", intRD);
                                        }
                                    }
                                    else
                                    {
                                        selection = current + offset;
                                    }
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage("You can only choose a ship docked at " + std::string(Location::Description[location]) + "!", intRD);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("The " + ships[current + offset].Name + " is destroyed!", intRD);
                            }
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return result;
}

std::vector<int> selectPartyMembers(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, int team_size, Control::Type mode)
{
    auto selected_party = std::vector<int>();

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Select Party Members");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > party.Members.size())
        {
            last = party.Members.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, true);

        auto done = false;

        auto selection = std::vector<int>();

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        auto scrollSpeed = 1;

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            if (mode == Control::Type::SPELL_TARGET)
            {
                putHeader(renderer, "Choose target(s) for this spell", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::SKILL)
            {
                putHeader(renderer, "Choose party member(s) to perform skill check", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::RAISE_MAX_HEALTH)
            {
                putHeader(renderer, "Choose party member(s) to raise maximum health points", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::GAIN_HEALTH)
            {
                putHeader(renderer, "Choose party member(s) to recover health points", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::LOSE_HEALTH)
            {
                putHeader(renderer, "Choose party member(s) to lose health points", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else if (mode == Control::Type::SELECT_ORDER)
            {
                putHeader(renderer, "Select the order of characters to perform the task", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
            else
            {
                putHeader(renderer, "Choose Party Member(s)", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    auto result = Engine::FIND_LIST(selection, offset + i);

                    if (result >= 0 && result < selection.size())
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else if (Engine::IS_ALIVE(party.Members[offset + i]))
                    {
                        if (team != Team::Type::NONE)
                        {
                            if (party.Members[offset + i].Team == team)
                            {
                                drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                            }
                            else
                            {
                                thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intGR, 2);
                            }
                        }
                        else
                        {
                            drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                        }
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (selection.size() > 0)
            {
                std::string party_string = "";

                for (auto i = 0; i < selection.size(); i++)
                {
                    if (i > 0)
                    {
                        party_string += "\n";
                    }

                    party_string += party.Members[selection[i]].Name;

                    if (Engine::IS_DEAD(party.Members[selection[i]]))
                    {
                        party_string += " (D)";
                    }
                    else if (Engine::IS_CURSED(party.Members[i]))
                    {
                        party_string += " (C)";
                    }
                }

                putText(renderer, party_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }
            else
            {
                putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > party.Members.size())
                        {
                            last = party.Members.size();
                        }

                        controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, true);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (party.Members.size() - last > 0)
                    {
                        if (offset < party.Members.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > party.Members.size() - limit)
                        {
                            offset = party.Members.size() - limit;
                        }

                        last = offset + limit;

                        if (last > party.Members.size())
                        {
                            last = party.Members.size();
                        }

                        controls = combatantList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh + text_space, true, true);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (party.Members.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::CONFIRM)
                {
                    if (selection.size() > 0 && (selection.size() >= team_size || selection.size() >= Engine::COUNT(party, team)))
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        done = true;

                        selected_party = selection;

                        current = -1;

                        selected = false;
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You must select " + std::to_string(team_size) + " party members!", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION)
                {
                    if (current + offset >= 0 && current + offset < party.Members.size())
                    {
                        auto result = Engine::FIND_LIST(selection, current + offset);

                        if (result >= 0 && result < selection.size())
                        {
                            selection.erase(selection.begin() + result);
                        }
                        else
                        {
                            if (Engine::IS_ALIVE(party.Members[current + offset]))
                            {
                                if (team == Team::Type::NONE || party.Members[current + offset].Team == team)
                                {
                                    if (Engine::IS_CAPTURED(party.Members[current + offset]))
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[current + offset].Name + " has been captured!", intRD);
                                    }
                                    else if (Engine::IS_CURSED(party.Members[current + offset]))
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[current + offset].Name + " is cursed!", intRD);
                                    }
                                    else if (Engine::IS_DEAD(party.Members[current + offset]))
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[current + offset].Name + " is dead!", intRD);
                                    }
                                    else if (party.InCity && !party.Members[current + offset].IsCivilized)
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[current + offset].Name + " is waiting outside the city!", intRD);
                                    }
                                    else if (selection.size() < team_size)
                                    {
                                        selection.push_back(current + offset);
                                    }
                                }
                                else
                                {
                                    if (!Engine::IS_CHARACTER(team))
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Members[current + offset].Name + " is not part of the " + std::string(Team::Descriptions[team]) + " team!", intRD);
                                    }
                                    else
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage("You can only choose " + std::string(Team::Descriptions[team]) + "!", intRD);
                                    }
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[current + offset].Name + " is dead!", intRD);
                            }
                        }
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    if (mode == Control::Type::PARTY)
    {
        party.LastSelection = selected_party;
    }

    if (selected_party.size() > 0 && mode == Control::Type::SELECT_ORDER)
    {
        party.Order.clear();

        for (auto i = 0; i < selected_party.size(); i++)
        {
            party.Order.push_back(party.Members[selected_party[i]].Type);
        }
    }

    if (selected_party.size() == 1 && Engine::IS_ALIVE(party, selected_party[0]) && mode == Control::Type::PARTY)
    {
        party.LastSelected = selected_party[0];
    }

    return selected_party;
}

Engine::Combat seaCombatScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Ship::Base> &enemyFleet, bool storyFlee, int fleeRound, int roundLimit)
{
    auto combatResult = Engine::Combat::NONE;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kindoms: Sea Combat");

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto controls = std::vector<Button>();

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (124);
        auto last = offset + limit;

        if (last > enemyFleet.size())
        {
            last = enemyFleet.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto hasAttacked = false;

        if (Engine::VERIFY_CODES(party, {Codes::Type::LAST_IN_COMBAT}))
        {
            hasAttacked = true;

            if (fleeRound == 0)
            {
                fleeRound += 1;
            }
        }

        auto castSpells = std::vector<int>();

        auto combatRound = 0;

        auto current_mode = Control::Type::ATTACK;

        auto canFlee = storyFlee;

        while (Engine::COUNT(enemyFleet) > 0 && Engine::SHIP_INTACT(party) && (roundLimit == -1 || (roundLimit > 0 && combatRound < roundLimit)))
        {
            auto done = false;

            auto current = -1;

            auto selected = false;

            auto scrollUp = false;

            auto scrollDown = false;

            auto hold = false;

            auto scrollSpeed = 1;

            while (!done)
            {
                auto last = offset + limit;

                if (last > enemyFleet.size())
                {
                    last = enemyFleet.size();
                }

                if (Engine::COUNT(enemyFleet) == 0)
                {
                    current_mode = Control::Type::NEXT;
                }
                else if (!hasAttacked)
                {
                    current_mode = Control::Type::ATTACK;
                }
                else
                {
                    current_mode = Control::Type::DEFEND;
                }

                controls = shipList(window, renderer, enemyFleet, offset, last, limit, textx, texty + infoh + text_space, current_mode);

                fillWindow(renderer, intWH);

                if (splash)
                {
                    fitImage(renderer, splash, startx, starty, splashw, text_bounds);
                }

                putHeader(renderer, "Opponents", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

                fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

                renderButtons(renderer, controls, current, intLB, text_space, border_pts);

                if (last - offset > 0)
                {
                    for (auto i = 0; i < last - offset; i++)
                    {
                        if (enemyFleet[offset + i].Health > 0)
                        {
                            if (current + offset == offset + i)
                            {
                                thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                            }
                            else
                            {
                                drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                            }
                        }
                        else
                        {
                            drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                        }
                    }
                }

                putHeader(renderer, "Current Ship", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

                if (party.CurrentShip >= 0 && party.CurrentShip < party.Fleet.size())
                {
                    std::string ship_string = "[" + party.Fleet[party.CurrentShip].Name + "]";
                    ship_string += "\nFighting: " + std::to_string(party.Fleet[party.CurrentShip].Fighting);
                    ship_string += "\nHealth: " + std::to_string(party.Fleet[party.CurrentShip].Health);

                    putText(renderer, ship_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
                }

                if (flash_message)
                {
                    if ((SDL_GetTicks() - start_ticks) < duration)
                    {
                        putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                    }
                    else
                    {
                        flash_message = false;
                    }
                }

                Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold, 200);

                if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
                {
                    if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                    {
                        if (offset > 0)
                        {
                            offset -= scrollSpeed;

                            if (offset < 0)
                            {
                                offset = 0;
                            }

                            last = offset + limit;

                            if (last > enemyFleet.size())
                            {
                                last = enemyFleet.size();
                            }

                            controls = shipList(window, renderer, enemyFleet, offset, last, limit, textx, texty + infoh + text_space, current_mode);

                            SDL_Delay(50);
                        }

                        if (offset <= 0)
                        {
                            current = -1;

                            selected = false;
                        }
                    }
                    else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                    {
                        if (enemyFleet.size() - last > 0)
                        {
                            if (offset < enemyFleet.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > enemyFleet.size() - limit)
                            {
                                offset = enemyFleet.size() - limit;
                            }

                            last = offset + limit;

                            if (last > enemyFleet.size())
                            {
                                last = enemyFleet.size();
                            }

                            controls = shipList(window, renderer, enemyFleet, offset, last, limit, textx, texty + infoh + text_space, current_mode);

                            SDL_Delay(50);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (enemyFleet.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }
                    else if (controls[current].Type == Control::Type::FLEE && !hold)
                    {
                        if (canFlee)
                        {
                            if (fleeRound == -1)
                            {
                                Sound::Play(Sound::Type::BUTTON_CLICK);

                                done = true;

                                combatResult = Engine::Combat::FLEE;
                            }
                            else if (combatRound == fleeRound)
                            {
                                Sound::Play(Sound::Type::BUTTON_CLICK);

                                done = true;

                                combatResult = Engine::Combat::FLEE;
                            }
                            else
                            {
                                if (combatRound < fleeRound)
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage("You cannot flee at this time.", intRD);
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage("You can no longer flee from this battle.", intRD);
                                }
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You cannot flee from this battle.", intRD);
                        }
                    }
                    else if (controls[current].Type == Control::Type::ATTACK && !hold)
                    {
                        if (Engine::SHIP_INTACT(party) && !hasAttacked && Engine::COUNT(enemyFleet) > 0)
                        {
                            if (hasAttacked)
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("Your ship has already attacked this round.", intRD);
                            }
                            else
                            {
                                auto opponent = -1;

                                if (Engine::COUNT(enemyFleet) == 1)
                                {
                                    opponent = Engine::FIRST(enemyFleet);
                                }
                                else
                                {
                                    opponent = selectOpponent(window, renderer, party.Book, enemyFleet, {}, combatRound);
                                }

                                if (opponent >= 0 && opponent < enemyFleet.size() && enemyFleet[opponent].Health > 0)
                                {
                                    seaAttackScreen(window, renderer, party, enemyFleet, opponent, 0);
                                }

                                hasAttacked = true;
                            }
                        }

                        if (hasAttacked)
                        {
                            if (Engine::COUNT(enemyFleet) > 0)
                            {
                                for (auto i = 0; i < enemyFleet.size(); i++)
                                {
                                    if (enemyFleet[i].Health > 0 && Engine::SHIP_INTACT(party))
                                    {
                                        seaAttackScreen(window, renderer, party, enemyFleet, i, 1);
                                    }
                                }
                            }

                            castSpells.clear();

                            hasAttacked = false;
                        }

                        current = -1;

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::SPELL && !hold)
                    {
                        if (!Engine::VERIFY_CODES(party, {Codes::Type::NO_COMBAT_SPELLS}))
                        {
                            if (Engine::SHIP_INTACT(party) && !hasAttacked)
                            {
                                if (Engine::SPELLCASTERS(party) > 0)
                                {
                                    auto combat_spells = 0;

                                    for (auto i = 0; i < party.Members.size(); i++)
                                    {
                                        if (Engine::IS_ALIVE(party.Members[i]) && party.Members[i].SpellCaster)
                                        {
                                            auto spells = Engine::COUNT(party.Members[i].SpellBook, Spells::Scope::SEA_COMBAT);

                                            combat_spells += spells;
                                        }
                                    }

                                    if (combat_spells <= 0)
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage("Your party does not have any usable sea combat spells.", intRD);
                                    }
                                    else if (castSpells.size() >= Engine::SPELLCASTERS(party))
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage("Your party has already cast spells this round.", intRD);
                                    }
                                    else
                                    {
                                        auto caster = castSeaCombatSpell(window, renderer, party, enemyFleet, castSpells, combatRound);

                                        if (caster >= 0 && caster < party.Members.size())
                                        {
                                            castSpells.push_back(caster);

                                            displayMessage(party.Members[caster].Name + " casts a spell!", intLB);
                                        }

                                        selected = false;

                                        current = -1;
                                    }
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage("There are no spell casters in your party!", intRD);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                if (Engine::VERIFY_CODES(party, {Codes::Type::LAST_IN_COMBAT}) && combatRound == 0)
                                {
                                    displayMessage("Your ship does not get to attack first nor cast spells this round!", intRD);
                                }
                                else
                                {
                                    displayMessage("Your ship has already attacked this round.", intRD);
                                }
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You cannot cast spells in this battle!", intRD);
                        }
                    }
                }

                if (!Engine::SHIP_INTACT(party) || Engine::COUNT(enemyFleet) == 0)
                {
                    done = true;
                }
            }

            if (combatResult == Engine::Combat::FLEE)
            {
                break;
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }

        if (combatResult != Engine::Combat::FLEE)
        {
            if (roundLimit > 0 && combatRound >= roundLimit)
            {
                combatResult = Engine::Combat::EXCEED_LIMIT;
            }
            else
            {
                combatResult = Engine::SHIP_INTACT(party) ? Engine::Combat::VICTORY : Engine::Combat::DEFEAT;
            }
        }
    }

    Engine::LOSE_CODES(party, {Codes::Type::LAST_IN_COMBAT, Codes::Type::CANNOT_USE_SHIPWEAPONS});

    if (combatResult != Engine::Combat::NONE)
    {
        Engine::LOSE_CODES(party, {Codes::Type::NO_COMBAT_SPELLS});
    }

    return combatResult;
}

Engine::Combat combatScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Monster::Base> &monsters, std::vector<Allies::Type> &allies, bool storyFlee, int fleeRound, int roundLimit, bool useEquipment)
{
    auto combatResult = Engine::Combat::NONE;

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kindoms: Combat");

        auto allies_attack = false;

        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto allyMessage = [&](std::string msg, Uint32 color)
        {
            allies_attack = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 24);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto controls = std::vector<Button>();

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > monsters.size())
        {
            last = monsters.size();
        }

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto hasAttacked = std::vector<int>();

        if (Engine::VERIFY_CODES(party, {Codes::Type::LAST_IN_COMBAT}))
        {
            for (auto i = 0; i < party.Members.size(); i++)
            {
                if (Engine::IS_ALIVE(party.Members[i]))
                {
                    hasAttacked.push_back(i);
                }
            }

            if (fleeRound == 0)
            {
                fleeRound += 1;
            }
        }

        auto combatRound = 0;

        auto round0_attacks = 0;

        auto spells_cast = 0;

        auto allyAttack = std::vector<Allies::Type>();

        auto current_mode = Control::Type::ATTACK;

        auto canFlee = storyFlee;

        auto done = false;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        auto scrollSpeed = 1;

        Engine::CLEAR_DAMAGES(party);

        while (Engine::COUNT(monsters) > 0 && Engine::COUNT(party, team) > 0 && (roundLimit == -1 || (roundLimit > 0 && combatRound < roundLimit)))
        {
            while (!done)
            {
                if (combatRound == 0 && Engine::VERIFY_CODES_ANY(party, {Codes::Type::ENEMY1_FREEATTACK_ROUND0, Codes::Type::LAST_ENEMY_ATTACK_ROUND0}))
                {
                    if (Engine::IS_ACTIVE(party, party.LastSelected) && monsters.size() > 0)
                    {
                        auto monster_attacking = 0;

                        if (Engine::VERIFY_CODES(party, {Codes::Type::LAST_ENEMY_ATTACK_ROUND0}))
                        {
                            monster_attacking = monsters.size() - 1;
                        }

                        auto free_attack = Engine::COUNT(monsters[monster_attacking].Attack, monsters[monster_attacking].Difficulty);

                        message = "The " + monsters[monster_attacking].Name;

                        if (free_attack > 0)
                        {
                            if (Engine::ARMOUR(party.Members[party.LastSelected]) > 0 && monsters[monster_attacking].Type != Monster::Type::PAPER && monsters[monster_attacking].Type != Monster::Type::NAGA && !Engine::VERIFY_CODES(party, {Codes::Type::ARMOUR_DISABLED}))
                            {
                                free_attack = std::max<int>(0, armourSave(window, renderer, party.Book, party.Members[party.LastSelected], free_attack));
                            }

                            if (free_attack > 0)
                            {
                                message += " deals " + std::to_string(free_attack) + " damage to " + party.Members[party.LastSelected].Name + "!";

                                Engine::GAIN_HEALTH(party.Members[party.LastSelected], -free_attack);

                                Sound::Play(Sound::Type::FAIL);

                                displayMessage(message, intRD);
                            }
                            else
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                message = +"'s attack was ineffective!";

                                displayMessage(message, intLB);
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::SUCCESS);

                            message = +"'s attack was ineffective!";

                            displayMessage(message, intLB);
                        }
                    }

                    if (Engine::VERIFY_CODES(party, {Codes::Type::LAST_ENEMY_ATTACK_ROUND0}))
                    {
                        Engine::LOSE_CODES(party, {Codes::Type::LAST_ENEMY_ATTACK_ROUND0});
                    }
                    else
                    {
                        Engine::LOSE_CODES(party, {Codes::Type::ENEMY1_FREEATTACK_ROUND0});
                    }
                }

                auto last = offset + limit;

                if (last > monsters.size())
                {
                    last = monsters.size();
                }

                if (Engine::COUNT(monsters, combatRound) == 0)
                {
                    current_mode = Control::Type::NEXT;
                }
                else if (hasAttacked.size() < Engine::TEAM_SIZE(party, team))
                {
                    current_mode = Control::Type::ATTACK;
                }
                else
                {
                    current_mode = Control::Type::DEFEND;
                }

                controls = monsterList(window, renderer, monsters, offset, last, limit, textx, texty + infoh + text_space, current_mode);

                fillWindow(renderer, intWH);

                if (splash)
                {
                    fitImage(renderer, splash, startx, starty, splashw, text_bounds);
                }

                putHeader(renderer, "Opponents", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

                fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

                renderButtons(renderer, controls, current, intLB, text_space, border_pts);

                if (last - offset > 0)
                {
                    for (auto i = 0; i < last - offset; i++)
                    {
                        if (monsters[offset + i].Health > 0)
                        {
                            if (combatRound >= monsters[offset + i].Round)
                            {
                                if (current + offset == offset + i)
                                {
                                    thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                                }
                                else
                                {
                                    drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                                }
                            }
                            else
                            {
                                thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intGR, 2);
                            }
                        }
                        else
                        {
                            drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                        }
                    }
                }

                if (team != Team::Type::NONE)
                {
                    if (Engine::IS_CHARACTER(team))
                    {
                        putHeader(renderer, "Current", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space));
                    }
                    else
                    {
                        putHeader(renderer, "Team", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space));
                    }

                    putText(renderer, Team::Descriptions[team], font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + text_bounds - 3 * boxh - infoh - box_space);
                }

                putHeader(renderer, "Party", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

                if (Engine::COUNT(party, team) > 0)
                {
                    std::string party_string = "";

                    auto count = 0;

                    for (auto i = 0; i < party.Members.size(); i++)
                    {
                        if (count > 0)
                        {
                            party_string += "\n";
                        }

                        party_string += party.Members[i].Name;

                        if (Engine::IS_DEAD(party.Members[i]))
                        {
                            party_string += " (D)";
                        }
                        else
                        {
                            if (Engine::HAS_STATUS(party.Members[i], Character::Status::STUNNED))
                            {
                                party_string += " (S)";
                            }
                            else if (Engine::FIND_LIST(hasAttacked, i) >= 0)
                            {
                                if (Engine::HAS_STATUS(party.Members[i], Character::Status::STUNNED))
                                {
                                    party_string += " (S)";
                                }
                                else
                                {
                                    party_string += " (A)";
                                }
                            }
                        }

                        count += 1;
                    }

                    putText(renderer, party_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
                }

                if (flash_message)
                {
                    if ((SDL_GetTicks() - start_ticks) < duration)
                    {
                        putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                    }
                    else
                    {
                        flash_message = false;
                    }
                }

                if (allies_attack)
                {
                    if ((SDL_GetTicks() - start_ticks) < duration)
                    {
                        putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                    }
                    else
                    {
                        allies_attack = false;
                    }
                }

                Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold, 200);

                if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
                {
                    if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                    {
                        if (offset > 0)
                        {
                            offset -= scrollSpeed;

                            if (offset < 0)
                            {
                                offset = 0;
                            }

                            last = offset + limit;

                            if (last > monsters.size())
                            {
                                last = monsters.size();
                            }

                            controls = monsterList(window, renderer, monsters, offset, last, limit, textx, texty + infoh + text_space, current_mode);

                            SDL_Delay(50);
                        }

                        if (offset <= 0)
                        {
                            current = -1;

                            selected = false;
                        }
                    }
                    else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                    {
                        if (monsters.size() - last > 0)
                        {
                            if (offset < monsters.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > monsters.size() - limit)
                            {
                                offset = monsters.size() - limit;
                            }

                            last = offset + limit;

                            if (last > monsters.size())
                            {
                                last = monsters.size();
                            }

                            controls = monsterList(window, renderer, monsters, offset, last, limit, textx, texty + infoh + text_space, current_mode);

                            SDL_Delay(50);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (monsters.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }
                    else if (controls[current].Type == Control::Type::FLEE && !hold)
                    {
                        if (canFlee)
                        {
                            if (fleeRound == -1)
                            {
                                Sound::Play(Sound::Type::BUTTON_CLICK);

                                done = true;

                                combatResult = Engine::Combat::FLEE;
                            }
                            else if (combatRound == fleeRound)
                            {
                                Sound::Play(Sound::Type::BUTTON_CLICK);

                                done = true;

                                combatResult = Engine::Combat::FLEE;
                            }
                            else
                            {
                                if (combatRound < fleeRound)
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    message = "You cannot flee at this time.";
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    message = "You can no longer flee from this battle.";
                                }

                                displayMessage(message, intRD);
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You cannot flee from this battle.", intRD);
                        }
                    }
                    else if (controls[current].Type == Control::Type::PARTY && !hold)
                    {
                        viewParty(window, renderer, party, team, true);

                        selected = false;

                        current = -1;
                    }
                    else if (controls[current].Type == Control::Type::ATTACK && !hold)
                    {
                        if (allies_attack)
                        {
                            allies_attack = false;
                        }

                        if (Engine::COUNT(party, team) > 0 && hasAttacked.size() < Engine::TEAM_SIZE(party, team) && Engine::COUNT(monsters, combatRound) > 0)
                        {
                            auto result = -1;

                            if (Engine::COUNT(party, team, hasAttacked) == 1)
                            {
                                if (team != Team::Type::NONE)
                                {
                                    result = Engine::FIRST(party, team, hasAttacked);
                                }
                                else
                                {
                                    result = Engine::FIRST(party, hasAttacked);
                                }
                            }
                            else
                            {
                                result = selectPartyMember(window, renderer, party, team, Equipment::NONE, Control::Type::COMBAT);
                            }

                            if (Engine::FIND_LIST(hasAttacked, result) >= 0 && !(Engine::HAS_STATUS(party.Members[result], Character::Status::ATTACK2_ENEMY0_ROUND0) && combatRound == 0 && round0_attacks < 2))
                            {
                                if (Engine::HAS_STATUS(party.Members[result], Character::Status::STUNNED))
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    message = party.Members[result].Name + " is stunned!";
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    message = party.Members[result].Name + " already attacked this round.";
                                }

                                displayMessage(message, intRD);
                            }
                            else
                            {
                                if (result >= 0 && result < party.Members.size())
                                {
                                    if (Engine::IS_ALIVE(party.Members[result]))
                                    {
                                        if (Engine::COUNT(monsters, combatRound) > 0)
                                        {
                                            auto opponent = -1;

                                            if (Engine::COUNT(monsters, combatRound) == 1)
                                            {
                                                opponent = Engine::FIRST(monsters, combatRound);
                                            }
                                            else
                                            {
                                                opponent = selectOpponent(window, renderer, party, result, monsters, {}, combatRound, Control::Type::COMBAT);
                                            }

                                            if (opponent >= 0 && opponent < monsters.size())
                                            {
                                                if (Engine::HAS_STATUS(party.Members[result], Character::Status::ATTACK2_ENEMY0_ROUND0) && opponent != 0 && round0_attacks > 0 && combatRound == 0)
                                                {
                                                    Sound::Play(Sound::Type::ERROR);

                                                    displayMessage("You cannot attack another opponent.", intRD);
                                                }
                                                else
                                                {
                                                    auto useWeapons = useEquipment;

                                                    if (monsters[opponent].Type == Monster::Type::BEETLE_SWARM)
                                                    {
                                                        useWeapons = false;
                                                    }

                                                    auto damage = attackScreen(window, renderer, party, team, monsters, result, opponent, 0, combatRound, useWeapons);

                                                    if (damage >= 0)
                                                    {
                                                        if (monsters[opponent].Type != Monster::Type::JUNGLE)
                                                        {
                                                            hasAttacked.push_back(result);

                                                            if (Engine::HAS_STATUS(party.Members[result], Character::Status::ATTACK2_ENEMY0_ROUND0))
                                                            {
                                                                round0_attacks += 1;

                                                                if (opponent != 0 || round0_attacks > 1 || combatRound != 0)
                                                                {
                                                                    Engine::REMOVE_STATUS(party.Members[result], Character::Status::ATTACK2_ENEMY0_ROUND0);
                                                                }
                                                            }

                                                            canFlee = false;
                                                        }
                                                        else
                                                        {
                                                            if (damage == 100 && hasAttacked.size() == (Engine::TEAM_SIZE(party, team) - 1))
                                                            {
                                                                Sound::Play(Sound::Type::ERROR);

                                                                displayMessage("There must be at least 1 attack on the Jungle each round.", intRD);
                                                            }
                                                            else
                                                            {
                                                                hasAttacked.push_back(result);

                                                                if (damage == 100)
                                                                {
                                                                    message = party.Members[result].Name + " did not attack this round.";

                                                                    displayMessage(message, intLB);
                                                                }
                                                                else
                                                                {
                                                                    if (monsters[opponent].Health > 0)
                                                                    {
                                                                        Sound::Play(Sound::Type::FAIL);

                                                                        Engine::GAIN_HEALTH(party.Members[result], -1);

                                                                        message = "The " + monsters[opponent].Name + " deals 1 damage to " + party.Members[result].Name + "!";

                                                                        displayMessage(message, intRD);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                Sound::Play(Sound::Type::FAIL);

                                                displayMessage("The attack has failed!", intRD);
                                            }
                                        }
                                        else
                                        {
                                            Sound::Play(Sound::Type::SUCCESS);

                                            displayMessage("Your party has prevailed!", intLB);
                                        }
                                    }
                                    else
                                    {
                                        Sound::Play(Sound::Type::FAIL);

                                        displayMessage("Your party is dead!", intRD);
                                    }
                                }
                            }
                        }

                        if (hasAttacked.size() >= Engine::COUNT(party, team) || Engine::COUNT(monsters, combatRound) == 0)
                        {
                            if (Engine::HAS_ALLY(allies, Allies::Type::SLAVES) && !Engine::HAS_ALLY(allyAttack, Allies::Type::SLAVES))
                            {
                                if (Engine::HAS_MONSTER(monsters, Monster::Type::ORC))
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    auto slaves_damage = -1;

                                    message = "The slaves attack the orcs! All orcs lose ";

                                    if (Engine::VERIFY_CODES(party, {Codes::Type::SLAVES_DAMAGE_FOR2}))
                                    {
                                        slaves_damage = -2;
                                    }

                                    message += std::to_string(-slaves_damage) + " Health point";

                                    if (std::abs(slaves_damage) > 1)
                                    {
                                        message += "s";
                                    }

                                    message += "!";

                                    Engine::GAIN_HEALTH(monsters, Monster::Type::ORC, slaves_damage);

                                    allyAttack.push_back(Allies::Type::SLAVES);

                                    allyMessage(message, intLB);
                                }
                            }

                            if (Engine::HAS_ALLY(allies, Allies::Type::YU_YUAN) && !Engine::HAS_ALLY(allyAttack, Allies::Type::YU_YUAN))
                            {
                                if (Engine::COUNT(monsters, combatRound) > 0)
                                {
                                    auto target = Engine::FIRST(monsters);

                                    if (target >= 0 && target < monsters.size())
                                    {
                                        auto attack_result = Engine::COUNT(5, monsters[target].Defence);

                                        if (attack_result > 0)
                                        {
                                            Sound::Play(Sound::Type::SUCCESS);

                                            Engine::GAIN_HEALTH(monsters[target], -attack_result);

                                            allyMessage("Yu Yuan deals " + std::to_string(attack_result) + " to the " + monsters[target].Name + "!", intLB);
                                        }
                                        else
                                        {
                                            Sound::Play(Sound::Type::FAIL);

                                            allyMessage("Yu Yuan's attack was ineffective!", intRD);
                                        }
                                    }

                                    allyAttack.push_back(Allies::Type::YU_YUAN);
                                }
                            }

                            if (Engine::COUNT(monsters, combatRound) > 0 && !allies_attack)
                            {
                                Engine::REMOVE_STATUS(party, Character::Status::STUNNED);

                                if (Engine::VERIFY_CODES(party, {Codes::Type::ENEMY_DAZING_LIGHTS}))
                                {
                                    Engine::LOSE_CODES(party, {Codes::Type::ENEMY_DAZING_LIGHTS});
                                }

                                auto everchild_assassin = Engine::FIND_MONSTER(monsters, Monster::Type::EVERCHILD_ASSASSIN);

                                if (everchild_assassin >= 0 && everchild_assassin < monsters.size() && monsters[everchild_assassin].Health > 0 && !monsters[everchild_assassin].Damaged)
                                {
                                    combatResult = Engine::Combat::FAILED_ATTACK;

                                    done = true;
                                }

                                if (!done)
                                {
                                    for (auto i = 0; i < monsters.size(); i++)
                                    {
                                        if (monsters[i].Health > 0 && Engine::COUNT(party, team) > 0 && combatRound >= monsters[i].Round)
                                        {
                                            if (monsters[i].Type != Monster::Type::ZEALOT_HEALER || Engine::COUNT(monsters) == 1)
                                            {
                                                if ((monsters[i].Attack > 0 && monsters[i].Difficulty > 0) || monsters[i].Type == Monster::Type::MONKEY_WITH_SPELLS)
                                                {
                                                    if (monsters[i].Type == Monster::Type::ZEALOT_SORCERER && combatRound == 1)
                                                    {
                                                        displayMessage("The sorcerer casts a Dazing Lights spell!", intRD);

                                                        Engine::GET_CODES(party, {Codes::Type::ENEMY_DAZING_LIGHTS});
                                                    }
                                                    else if (monsters[i].Type == Monster::Type::FASTILON)
                                                    {
                                                        if (!monsters[i].Damaged || spells_cast >= 3)
                                                        {
                                                            if (spells_cast == 2)
                                                            {
                                                                Sound::Play(Sound::Type::FAIL);

                                                                displayMessage("Fastilon a Healing Word! Fastilon recovers 8 Health points!", intRD);

                                                                Engine::GAIN_HEALTH(monsters[i], 8);
                                                            }
                                                            else
                                                            {
                                                                attackScreen(window, renderer, party, team, monsters, -1, i, 1, spells_cast, useEquipment);
                                                            }

                                                            spells_cast += 1;
                                                        }
                                                        else
                                                        {
                                                            attackScreen(window, renderer, party, team, monsters, -1, i, 1, (combatRound < 3 ? 3 : combatRound), useEquipment);
                                                        }
                                                    }
                                                    else
                                                    {
                                                        attackScreen(window, renderer, party, team, monsters, -1, i, 1, combatRound, useEquipment);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            if (!allies_attack)
                            {
                                // After combat round triggers
                                if (Engine::HAS_MONSTER(monsters, Monster::Type::SNAKEMAN_PRIEST))
                                {
                                    Engine::GAIN_HEALTH(party, -1);

                                    Engine::GAIN_HEALTH(monsters, -1);

                                    Sound::Play(Sound::Type::FAIL);

                                    displayMessage("Blocks of stone come raining down from the walls! The priest and each party member loses 1 Health!", intRD);
                                }
                                else if (Engine::HAS_MONSTER(monsters, Monster::Type::SPIDER_WITH_SWARM))
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    Engine::GAIN_HEALTH(party, team, -1);

                                    displayMessage("Swarms of tiny spiders attack the party and deal 1 damage to everyone!", intRD);
                                }
                                else if (Engine::HAS_MONSTER(monsters, Monster::Type::BEETLE_SWARM))
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    Engine::GAIN_HEALTH(party, team, -1);

                                    displayMessage("The beetles deals 1 damage to the entire party!", intRD);
                                }
                                else if (Engine::HAS_MONSTER(monsters, Monster::Type::ZEALOT_HEALER) && Engine::COUNT(monsters) > 1)
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    Engine::GAIN_HEALTH(monsters, 2);

                                    displayMessage("The Zealot Healer heals each Zealot for 2 Health points!", intRD);
                                }
                                else if (Engine::HAS_MONSTER(monsters, Monster::Type::SKELETON_ARCHERS))
                                {
                                    auto result = Engine::FIND_MONSTER(monsters, Monster::Type::SKELETON_ARCHERS);

                                    if (result >= 0 && result < monsters.size() && !monsters[result].Damaged)
                                    {
                                        auto selection = selectPartyMembers(window, renderer, party, team, 2, Control::Type::LOSE_HEALTH);

                                        if (selection.size() > 0)
                                        {
                                            Sound::Play(Sound::Type::FAIL);

                                            message = "The Skeleton Archers deal 2 damage to: ";

                                            for (auto i = 0; i < selection.size(); i++)
                                            {
                                                if (i > 0)
                                                {
                                                    message += ", ";
                                                }

                                                message += party.Members[selection[i]].Name;

                                                Engine::GAIN_HEALTH(party.Members[selection[i]], -2);
                                            }

                                            displayMessage(message, intRD);
                                        }
                                    }
                                }
                                else if (Engine::HAS_MONSTER(monsters, Monster::Type::GOBLIN_ARCHERS))
                                {
                                    auto result = Engine::FIND_MONSTER(monsters, Monster::Type::GOBLIN_ARCHERS);

                                    if (result >= 0 && result < monsters.size() && !monsters[result].Damaged)
                                    {
                                        auto selection = selectPartyMembers(window, renderer, party, team, 2, Control::Type::LOSE_HEALTH);

                                        if (selection.size() > 0)
                                        {
                                            Sound::Play(Sound::Type::FAIL);

                                            message = "The Goblin Archers deal 2 damage to: ";

                                            for (auto i = 0; i < selection.size(); i++)
                                            {
                                                if (i > 0)
                                                {
                                                    message += ", ";
                                                }

                                                message += party.Members[selection[i]].Name;

                                                Engine::GAIN_HEALTH(party.Members[selection[i]], -2);
                                            }

                                            displayMessage(message, intRD);
                                        }
                                    }
                                }
                                else if (Engine::HAS_MONSTER(monsters, Monster::Type::SALT_DRAGON))
                                {
                                    if (!Engine::IS_DAMAGED(party))
                                    {
                                        Sound::Play(Sound::Type::FAIL);

                                        Engine::GAIN_HEALTH(party, -3);

                                        displayMessage("The Salt Dragon is enraged and breathes out a blast of fire. Each member of the party is damaged for 3!", intRD);
                                    }
                                }

                                Engine::LOSE_CODES(party, {Codes::Type::DAZING_LIGHTS});

                                allyAttack.clear();

                                hasAttacked.clear();

                                Engine::CLEAR_DAMAGES(party);

                                canFlee = storyFlee;

                                combatRound += 1;

                                Engine::REMOVE_STATUS(party, Character::Status::EXTRA_MAGIC_ROUND0);

                                Engine::REMOVE_STATUS(party, Character::Status::UNLIMITED_MAGIC_ROUND0);

                                // clear monster damaged flags for next round
                                for (auto i = 0; i < monsters.size(); i++)
                                {
                                    monsters[i].Damaged = false;
                                }

                                // Setup stunned characters
                                for (auto i = 0; i < party.Members.size(); i++)
                                {
                                    if (Engine::IS_ACTIVE(party, i) && Engine::HAS_STATUS(party.Members[i], Character::Status::STUNNED_NEXT_ROUND))
                                    {
                                        Engine::REMOVE_STATUS(party.Members[i], Character::Status::STUNNED_NEXT_ROUND);

                                        Engine::GAIN_STATUS(party.Members[i], Character::Status::STUNNED);

                                        hasAttacked.push_back(i);
                                    }
                                }
                            }
                        }

                        current = -1;

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::SPELL && !hold)
                    {
                        if (!Engine::VERIFY_CODES(party, {Codes::Type::NO_COMBAT_SPELLS}))
                        {
                            if (Engine::COUNT(party, team) > 0 && hasAttacked.size() < Engine::TEAM_SIZE(party, team))
                            {
                                if (Engine::SPELLCASTERS(party) > 0)
                                {
                                    auto combat_spells = 0;

                                    for (auto i = 0; i < party.Members.size(); i++)
                                    {
                                        if (Engine::IS_ALIVE(party.Members[i]) && party.Members[i].SpellCaster && (team == Team::Type::NONE || party.Members[i].Team == team))
                                        {
                                            auto spells = Engine::COUNT(party.Members[i].SpellBook, Spells::Scope::COMBAT) + Engine::COUNT(party.Members[i].SpellBook, Spells::Scope::ADVENTURE_COMBAT);

                                            combat_spells += spells;
                                        }
                                    }

                                    if (combat_spells <= 0)
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage("Your party does not have any usable combat spells.", intRD);
                                    }
                                    else
                                    {
                                        auto result = castCombatSpell(window, renderer, party, team, monsters, hasAttacked, combatRound);

                                        if (result >= 0 && result < party.Members.size())
                                        {
                                            if (Engine::FIND_LIST(hasAttacked, result) < 0)
                                            {
                                                hasAttacked.push_back(result);
                                            }
                                            else
                                            {
                                                if (Engine::HAS_STATUS(party.Members[result], Character::Status::EXTRA_MAGIC_ROUND0))
                                                {
                                                    Engine::REMOVE_STATUS(party.Members[result], Character::Status::EXTRA_MAGIC_ROUND0);
                                                }
                                            }

                                            displayMessage(party.Members[result].Name + " casts a spell!", intLB);
                                        }

                                        selected = false;

                                        current = -1;
                                    }
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage("There are no spell casters in your party!", intRD);
                                }
                            }
                            else
                            {
                                if (Engine::VERIFY_CODES(party, {Codes::Type::LAST_IN_COMBAT}) && combatRound == 0)
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    message = "Your party does not get to attack first nor cast spells this round!";
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    message = "Your entire party has already attacked this round.";
                                }

                                displayMessage(message, intRD);
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You cannot cast spells in this battle!", intRD);
                        }
                    }
                }

                if (Engine::COUNT(party, team) == 0 || Engine::COUNT(monsters) == 0)
                {
                    done = true;
                }

                if (roundLimit > 0 && combatRound >= roundLimit)
                {
                    done = true;
                }
            }

            if (combatResult == Engine::Combat::FLEE || combatResult == Engine::Combat::FAILED_ATTACK)
            {
                break;
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        TTF_Quit();

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }

        if (combatResult != Engine::Combat::FLEE)
        {
            if (roundLimit > 0 && combatRound >= roundLimit)
            {
                combatResult = Engine::Combat::EXCEED_LIMIT;
            }
            else if (combatResult != Engine::Combat::FAILED_ATTACK)
            {
                combatResult = Engine::COUNT(party, team) > 0 ? Engine::Combat::VICTORY : Engine::Combat::DEFEAT;
            }
        }
    }

    if (combatResult != Engine::Combat::NONE)
    {
        Engine::REMOVE_STATUS(party, Character::Status::ARMOUR3);
        Engine::REMOVE_STATUS(party, Character::Status::ENRAGED);
        Engine::REMOVE_STATUS(party, Character::Status::POTION_OF_INVULNERABILITY);
        Engine::REMOVE_STATUS(party, Character::Status::STUNNED);
        Engine::REMOVE_STATUS(party, Character::Status::STUNNED_NEXT_ROUND);
        Engine::REMOVE_STATUS(party, Character::Status::UNARMED_COMBAT);

        Engine::LOSE_CODES(party, {Codes::Type::NO_COMBAT_SPELLS,
                                   Codes::Type::NO_WEAPONS,
                                   Codes::Type::LAST_IN_COMBAT});
    }

    return combatResult;
}

Story::Base *findStory(Engine::Destination destination)
{
    auto next = (Story::Base *)&Story::notImplemented;

    auto bookID = destination.first;

    auto storyID = destination.second;

    if (bookID == Book::Type::BOOK1)
    {
        next = (Story::Base *)Story::FIND_STORY(storyID, Book1::Stories);
    }

    next->BookID = bookID;

    next->ID = storyID;

    return next;
}

std::vector<Button> shopList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Engine::EquipmentPrice> &shop, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (shop.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto item = std::get<0>(shop[index]);

            auto buy = std::get<1>(shop[index]);

            auto sell = std::get<2>(shop[index]);

            auto supply = std::get<3>(shop[index]);

            auto item_string = itemString(item);

            if (supply >= 0)
            {
                if (supply == 0)
                {
                    item_string += ", out of stock";
                }
                else
                {
                    item_string += ", " + std::to_string(supply) + " stock";

                    if (supply > 1)
                    {
                        item_string += "s";
                    }

                    item_string += " remaining";
                }
            }

            item_string += "\nPrice: " + std::string(buy > 0 ? std::to_string(buy) + " silver coins" : "Not available") + ", Sell: " + std::string(sell > 0 ? std::to_string(sell) + " silver coins" : "--");

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, item_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (shop.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (shop.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/shop.png", idx, idx + 1, (shop.size() > 0 ? ((last - start) - 1) : idx), idx, textx, buttony, Control::Type::BUY));
    controls.push_back(Button(idx + 1, "icons/selling.png", idx, idx + 2, (shop.size() > 0 ? ((last - start) - 1) : idx + 1), idx + 1, textx + gridsize, buttony, Control::Type::SELL));
    controls.push_back(Button(idx + 2, "icons/items.png", idx + 1, idx + 3, (shop.size() > 0 ? ((last - start) - 1) : idx + 2), idx + 2, textx + 2 * gridsize, buttony, Control::Type::EQUIPMENT));
    controls.push_back(Button(idx + 3, "icons/previous.png", idx + 2, idx + 4, (shop.size() > 0 ? ((last - start) - 1) : idx + 3), idx + 3, textx + 3 * gridsize, buttony, Control::Type::PREVIOUS_CHARACTER));
    controls.push_back(Button(idx + 4, "icons/next.png", idx + 3, idx + 5, (shop.size() > 0 ? ((last - start) - 1) : idx + 4), idx + 4, textx + 4 * gridsize, buttony, Control::Type::NEXT_CHARACTER));
    controls.push_back(Button(idx + 5, "icons/back-button.png", idx + 4, idx + 5, (shop.size() > 0 ? ((last - start) - 1) : idx + 5), idx + 5, lastx, buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> shopList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Equipment::Base> &equipment, std::vector<Engine::EquipmentPrice> &shop, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (equipment.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto item = equipment[index];

            auto sell = Engine::PRICE_SELL(shop, item.Type);

            auto item_string = itemString(item);

            item_string += "\nSell: " + std::string(sell > 0 ? std::to_string(sell) + " silver coins" : "--");

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, item_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (equipment.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (equipment.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/shop.png", idx, idx + 1, (equipment.size() > 0 ? ((last - start) - 1) : idx), idx, textx, buttony, Control::Type::BUY));
    controls.push_back(Button(idx + 1, "icons/selling.png", idx, idx + 2, (equipment.size() > 0 ? ((last - start) - 1) : idx + 1), idx + 1, textx + gridsize, buttony, Control::Type::SELL));
    controls.push_back(Button(idx + 2, "icons/items.png", idx + 1, idx + 3, (equipment.size() > 0 ? ((last - start) - 1) : idx + 2), idx + 2, textx + 2 * gridsize, buttony, Control::Type::EQUIPMENT));
    controls.push_back(Button(idx + 3, "icons/previous.png", idx + 2, idx + 4, (equipment.size() > 0 ? ((last - start) - 1) : idx + 3), idx + 3, textx + 3 * gridsize, buttony, Control::Type::PREVIOUS_CHARACTER));
    controls.push_back(Button(idx + 4, "icons/next.png", idx + 3, idx + 5, (equipment.size() > 0 ? ((last - start) - 1) : idx + 4), idx + 4, textx + 4 * gridsize, buttony, Control::Type::NEXT_CHARACTER));
    controls.push_back(Button(idx + 5, "icons/back-button.png", idx + 4, idx + 5, (equipment.size() > 0 ? ((last - start) - 1) : idx + 5), idx + 5, lastx, buttony, Control::Type::BACK));

    return controls;
}

bool shipScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Engine::ShipPrices> &shop, Story::Base *harbour)
{
    auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

    auto scrollSpeed = 1;

    auto limit = (text_bounds - 2 * text_space - infoh) / (124);

    auto offset = 0;

    auto last = offset + limit;

    if (last > shop.size())
    {
        last = shop.size();
    }

    std::string message = "";

    auto flash_message = false;

    auto flash_color = intRD;

    Uint32 start_ticks = 0;

    Uint32 duration = 3000;

    auto displayMessage = [&](std::string msg, Uint32 color)
    {
        flash_message = true;

        message = msg;

        flash_color = color;

        start_ticks = SDL_GetTicks();
    };

    auto fg = Color::HEADER(party.Book);

    auto done = false;

    auto offsety = (texty + infoh);

    auto controls = shipList(window, renderer, shop, offset, last, limit, textx, offsety, true, true);

    TTF_Init();

    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
    auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);
    auto font_mason = TTF_OpenFont(FONT_MASON, 24);

    TTF_SetFontKerning(font_dark11, 0);

    auto selected = false;
    auto current = -1;
    auto scrollUp = false;
    auto scrollDown = false;
    auto hold = false;

    auto buy_selection = std::vector<int>();
    auto sell_selection = std::vector<int>();

    auto current_mode = Control::Type::BUY_SHIP;

    while (!done)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Buy/Sell Ships");

        fillWindow(renderer, intWH);

        if (splash)
        {
            fitImage(renderer, splash, startx, starty, splashw, text_bounds);
        }

        putHeader(renderer, "Money", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (5 * bigger_boxh / 2) - 2 * infoh - box_space);

        putText(renderer, (std::to_string(party.Money) + std::string(" silver coins")).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, bigger_boxh / 2, startx, starty + text_bounds - (5 * bigger_boxh / 2) - infoh - box_space);

        if (current >= 0 && current < controls.size())
        {
            if (controls[current].Type == Control::Type::BUY_SHIP)
            {
                if (current_mode != Control::Type::BUY_SHIP)
                {
                    offset = 0;

                    last = offset + limit;

                    if (last > shop.size())
                    {
                        last = shop.size();
                    }

                    current_mode = Control::Type::BUY_SHIP;

                    controls = shipList(window, renderer, shop, offset, last, limit, textx, offsety, true, true);

                    current = FIND_CONTROL(controls, Control::Type::BUY_SHIP);
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::SELL_SHIP)
            {
                if (current_mode != Control::Type::SELL_SHIP)
                {
                    offset = 0;

                    last = offset + limit;

                    if (last > party.Fleet.size())
                    {
                        last = party.Fleet.size();
                    }

                    controls = shipList(window, renderer, party.Fleet, shop, offset, last, limit, textx, offsety, true, true);

                    current_mode = Control::Type::SELL_SHIP;

                    current = FIND_CONTROL(controls, Control::Type::SELL_SHIP);
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::PARTY)
            {
                if (current_mode != Control::Type::PARTY)
                {
                    offset = 0;

                    last = offset + limit;

                    if (last > party.Fleet.size())
                    {
                        last = party.Fleet.size();
                    }

                    controls = shipList(window, renderer, party.Fleet, shop, offset, last, limit, textx, offsety, true, true);

                    current_mode = Control::Type::PARTY;

                    current = FIND_CONTROL(controls, Control::Type::PARTY);
                }

                selected = false;
            }
        }

        if (current_mode == Control::Type::BUY_SHIP)
        {
            putHeader(renderer, (buy_selection.size() > 0 ? (std::string("Selected (") + std::to_string(buy_selection.size()) + std::string(")")).c_str() : "Selected"), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * bigger_boxh + infoh));
        }
        else if (current_mode == Control::Type::SELL_SHIP || current_mode == Control::Type::PARTY)
        {
            putHeader(renderer, (sell_selection.size() > 0 ? (std::string("Selected (") + std::to_string(sell_selection.size()) + std::string(")")).c_str() : "Selected"), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * bigger_boxh + infoh));
        }
        else
        {
            fillRect(renderer, splashw, infoh, startx, starty + text_bounds - (2 * bigger_boxh + infoh), fg);
        }

        if (buy_selection.size() > 0 || sell_selection.size() > 0)
        {
            std::string selection_string = "";

            if (current_mode == Control::Type::BUY_SHIP)
            {
                for (auto i = 0; i < buy_selection.size(); i++)
                {
                    if (buy_selection[i] >= 0 && buy_selection[i] < shop.size())
                    {
                        if (i > 0)
                        {
                            selection_string += ", ";
                        }

                        auto ship = std::get<0>(shop[buy_selection[i]]);

                        selection_string += "[" + ship.Name + "]";
                    }
                }
            }
            else if (current_mode == Control::Type::SELL_SHIP || current_mode == Control::Type::PARTY)
            {
                for (auto i = 0; i < sell_selection.size(); i++)
                {
                    if (sell_selection[i] >= 0 && sell_selection[i] < party.Fleet.size())
                    {
                        if (i > 0)
                        {
                            selection_string += ", ";
                        }

                        auto ship = party.Fleet[sell_selection[i]];

                        selection_string += "[" + ship.Name + "]";
                    }
                }
            }

            fillRect(renderer, splashw, 2 * bigger_boxh, startx, starty + text_bounds - 2 * bigger_boxh, intBE);

            if (selection_string.length() > 0)
            {
                auto text = createText(selection_string.c_str(), FONT_MASON, 24, clrBK, splashw - 2 * text_space, TTF_STYLE_NORMAL);

                if (text)
                {
                    renderText(renderer, text, intBE, startx + text_space, starty + text_bounds - 2 * bigger_boxh + text_space, 2 * (bigger_boxh - text_space), 0);

                    SDL_FreeSurface(text);

                    text = NULL;
                }
            }
        }
        else
        {
            putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * bigger_boxh, startx, starty + text_bounds - 2 * bigger_boxh);
        }

        if (current_mode == Control::Type::BUY_SHIP)
        {
            std::string buy_string = "";

            if (buy_selection.size() > 1)
            {
                buy_string = "Buy these";
            }
            else if (buy_selection.size() == 1)
            {
                buy_string = "Buy this";
            }
            else
            {
                buy_string = "Ships for sale";
            }

            putHeader(renderer, buy_string.c_str(), font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
        }
        else if (current_mode == Control::Type::SELL_SHIP)
        {
            std::string sell_string = "";

            if (sell_selection.size() > 1)
            {
                sell_string = "Sell these";
            }
            else if (sell_selection.size() == 1)
            {
                sell_string = "Sell this";
            }
            else
            {
                sell_string = "Fleet";
            }

            putHeader(renderer, sell_string.c_str(), font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
        }
        else if (current_mode == Control::Type::PARTY)
        {
            putHeader(renderer, "Fleet", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
        }
        else
        {
            fillRect(renderer, textwidth, infoh, textx, texty, fg);
        }

        fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

        if (last - offset > 0)
        {
            for (auto i = 0; i < last - offset; i++)
            {
                if (controls[i].Type == Control::Type::ACTION)
                {
                    if (current_mode == Control::Type::BUY_SHIP)
                    {
                        if (Engine::FIND_LIST(buy_selection, offset + i) >= 0)
                        {
                            thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                        }
                        else
                        {
                            drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                        }
                    }
                    else if (current_mode == Control::Type::SELL_SHIP || current_mode == Control::Type::PARTY)
                    {
                        if (Engine::FIND_LIST(sell_selection, offset + i) >= 0)
                        {
                            thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                        }
                        else
                        {
                            drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                        }
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }
        }

        renderButtons(renderer, controls, current, intLB, text_space, border_pts);

        if (current >= 0 && current < controls.size())
        {
            renderCaption(renderer, font_caption, controls[current]);
        }

        if (flash_message)
        {
            if ((SDL_GetTicks() - start_ticks) < duration)
            {
                putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, bigger_boxh * 2, -1, -1);
            }
            else
            {
                flash_message = false;
            }
        }

        Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

        if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
        {
            if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
            {
                if (current_mode == Control::Type::BUY_SHIP)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > shop.size())
                        {
                            last = shop.size();
                        }

                        controls = shipList(window, renderer, shop, offset, last, limit, textx, offsety, true, true);

                        SDL_Delay(50);
                    }
                }
                else if (current_mode == Control::Type::SELL_SHIP)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > party.Fleet.size())
                        {
                            last = party.Fleet.size();
                        }

                        controls = shipList(window, renderer, party.Fleet, shop, offset, last, limit, textx, offsety, true, true);

                        SDL_Delay(50);
                    }
                }

                if (offset <= 0)
                {
                    current = -1;

                    selected = false;
                }
            }
            else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
            {
                if (current_mode == Control::Type::BUY_SHIP)
                {
                    if (shop.size() - last > 0)
                    {
                        if (offset < shop.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > shop.size() - limit)
                        {
                            offset = shop.size() - limit;
                        }

                        last = offset + limit;

                        if (last > shop.size())
                        {
                            last = shop.size();
                        }

                        controls = shipList(window, renderer, shop, offset, last, limit, textx, offsety, true, true);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (shop.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (current_mode == Control::Type::SELL_SHIP || current_mode == Control::Type::PARTY)
                {
                    if (party.Fleet.size() - last > 0)
                    {
                        if (offset < party.Fleet.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > party.Fleet.size() - limit)
                        {
                            offset = party.Fleet.size() - limit;
                        }

                        last = offset + limit;

                        if (last > party.Fleet.size())
                        {
                            last = party.Fleet.size();
                        }

                        controls = shipList(window, renderer, party.Fleet, shop, offset, last, limit, textx, offsety, true, true);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (party.Fleet.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
            }
            else if (controls[current].Type == Control::Type::ACTION && !hold)
            {
                if (current >= 0 && current < controls.size())
                {
                    if (current_mode == Control::Type::BUY_SHIP)
                    {
                        auto result = Engine::FIND_LIST(buy_selection, offset + current);

                        if (result >= 0)
                        {
                            buy_selection.erase(buy_selection.begin() + result);
                        }
                        else
                        {
                            if (buy_selection.size() < shop.size())
                            {
                                buy_selection.push_back(offset + current);
                            }
                        }
                    }
                    else if (current_mode == Control::Type::SELL_SHIP || current_mode == Control::Type::PARTY)
                    {
                        auto result = Engine::FIND_LIST(sell_selection, offset + current);

                        if (result >= 0)
                        {
                            sell_selection.erase(sell_selection.begin() + result);
                        }
                        else
                        {
                            if (sell_selection.size() < shop.size())
                            {
                                sell_selection.push_back(offset + current);
                            }
                        }
                    }
                }

                current = -1;

                selected = false;
            }
            else if (controls[current].Type == Control::Type::BUY_SHIP && !hold)
            {
                if (buy_selection.size() > 0)
                {
                    auto total = 0;

                    auto ships = std::vector<Ship::Base>();

                    for (auto i = 0; i < buy_selection.size(); i++)
                    {
                        if (buy_selection[i] >= 0 && buy_selection[i] < shop.size())
                        {
                            auto ship = std::get<0>(shop[buy_selection[i]]);

                            auto price = std::get<1>(shop[buy_selection[i]]);

                            if (price > 0)
                            {
                                ships.push_back(ship);

                                total += price;
                            }
                        }
                    }

                    if (ships.size() > 0)
                    {
                        if (party.Money >= total)
                        {
                            Engine::GAIN_MONEY(party, -total);

                            message = "Ship";

                            if (ships.size() > 1)
                            {
                                message += "s";
                            }

                            message += " purchased: ";

                            for (auto i = 0; i < ships.size(); i++)
                            {
                                auto ship = ships[i];

                                ship.Location = harbour->Location;

                                party.Fleet.push_back(ship);

                                if (i > 0)
                                {
                                    message += ", ";
                                }

                                message += "[" + ship.Name + "]";
                            }

                            Sound::Play(Sound::Type::SUCCESS);

                            displayMessage(message, intLB);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have enough silver coins!", intRD);
                        }
                    }
                }
                else
                {
                    Sound::Play(Sound::Type::ERROR);

                    displayMessage("Please select the ships you wish to buy!", intRD);
                }
            }
            else if (controls[current].Type == Control::Type::SELL_SHIP && !hold)
            {
                if (sell_selection.size() > 0)
                {
                    std::string sold_string = "";
                    std::string unsold_string = "";

                    auto sold = 0;
                    auto unsold = 0;

                    auto ship_sold = std::vector<int>();

                    for (auto i = 0; i < sell_selection.size(); i++)
                    {
                        if (sell_selection[i] >= 0 && sell_selection[i] < party.Fleet.size())
                        {
                            auto ship = party.Fleet[sell_selection[i]];

                            auto price = Engine::PRICE_SELL(shop, party.Fleet[sell_selection[i]].Type);

                            if (price > 0)
                            {
                                if (party.Fleet[sell_selection[i]].Location != harbour->Location)
                                {
                                    unsold += 1;

                                    if (unsold_string.length() > 0)
                                    {
                                        unsold_string += ", ";
                                    }

                                    unsold_string += "[" + ship.Name + "]";
                                }
                                else
                                {
                                    ship_sold.push_back(sell_selection[i]);

                                    Engine::GAIN_MONEY(party, price);

                                    sold += 1;

                                    if (sold_string.length() > 0)
                                    {
                                        sold_string += ", ";
                                    }

                                    sold_string += "[" + ship.Name + "]";
                                }
                            }
                            else
                            {
                                unsold += 1;

                                if (unsold_string.length() > 0)
                                {
                                    unsold_string += ", ";
                                }

                                unsold_string += "[" + ship.Name + "]";
                            }
                        }
                    }

                    message = "";

                    if (sold > 0)
                    {
                        message += "Ships sold: " + sold_string;

                        auto fleet = std::vector<Ship::Base>();

                        for (auto i = 0; i < party.Fleet.size(); i++)
                        {
                            if (Engine::FIND_LIST(ship_sold, i) < 0)
                            {
                                fleet.push_back(party.Fleet[i]);
                            }
                        }

                        if (fleet.size() > 0)
                        {
                            party.Fleet = fleet;
                        }
                    }

                    if (unsold > 0)
                    {
                        if (sold > 0)
                        {
                            message += "\n";
                        }

                        message += "Ships not sold: " + unsold_string;
                    }

                    if (sold > unsold)
                    {
                        Sound::Play(Sound::Type::SUCCESS);

                        flash_color = intLB;
                    }
                    else
                    {
                        Sound::Play(Sound::Type::FAIL);

                        flash_color = intRD;
                    }

                    displayMessage(message, flash_color);
                }
                else
                {
                    Sound::Play(Sound::Type::ERROR);

                    displayMessage("Please select the ships you wish to sell!", intRD);
                }
            }
            else if (controls[current].Type == Control::Type::PARTY && !hold)
            {
                Sound::Play(Sound::Type::BUTTON_CLICK);

                viewParty(window, renderer, party, Team::Type::NONE, false);
            }
            else if (controls[current].Type == Control::Type::BACK && !hold)
            {
                Sound::Play(Sound::Type::BUTTON_CLICK);

                done = true;
            }
        }
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    if (font_caption)
    {
        TTF_CloseFont(font_caption);

        font_caption = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    TTF_Quit();

    if (splash)
    {
        SDL_FreeSurface(splash);

        splash = NULL;
    }

    return false;
}

bool shopScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Engine::EquipmentPrice> &shop, int character)
{
    auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

    auto scrollSpeed = 1;

    auto limit = (text_bounds - 2 * text_space - infoh) / (96);

    auto offset = 0;

    auto last = offset + limit;

    if (last > shop.size())
    {
        last = shop.size();
    }

    std::string message = "";

    auto flash_message = false;

    auto flash_color = intRD;

    Uint32 start_ticks = 0;

    Uint32 duration = 3000;

    auto displayMessage = [&](std::string msg, Uint32 color)
    {
        flash_message = true;

        message = msg;

        flash_color = color;

        start_ticks = SDL_GetTicks();
    };

    auto fg = Color::HEADER(party.Book);

    auto done = false;

    auto offsety = (texty + infoh);

    auto controls = shopList(window, renderer, shop, offset, last, limit, textx, offsety);

    TTF_Init();

    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
    auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);
    auto font_mason = TTF_OpenFont(FONT_MASON, 24);

    TTF_SetFontKerning(font_dark11, 0);

    auto selected = false;
    auto current = -1;
    auto scrollUp = false;
    auto scrollDown = false;
    auto hold = false;

    auto buy_selection = std::vector<int>();
    auto sell_selection = std::vector<int>();

    auto current_mode = Control::Type::BUY;

    if (!Engine::VERIFY_EQUIPMENT_LIMIT(party.Members[character]))
    {
        Sound::Play(Sound::Type::ERROR);

        displayMessage("You are carrying too many items! Drop, sell, or transfer excess items.", intRD);
    }

    while (!done)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Buy/Sell Items");

        fillWindow(renderer, intWH);

        if (splash)
        {
            fitImage(renderer, splash, startx, starty, splashw, text_bounds);
        }

        putHeader(renderer, "Money", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (5 * bigger_boxh / 2) - 2 * infoh - box_space);

        putText(renderer, (std::to_string(party.Money) + std::string(" silver coins")).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, bigger_boxh / 2, startx, starty + text_bounds - (5 * bigger_boxh / 2) - infoh - box_space);

        if (current >= 0 && current < controls.size())
        {
            if (controls[current].Type == Control::Type::BUY)
            {
                if (current_mode != Control::Type::BUY)
                {
                    offset = 0;

                    last = offset + limit;

                    if (last > shop.size())
                    {
                        last = shop.size();
                    }

                    controls = shopList(window, renderer, shop, offset, last, limit, textx, offsety);

                    current_mode = Control::Type::BUY;

                    current = FIND_CONTROL(controls, Control::Type::BUY);
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::SELL)
            {
                if (current_mode != Control::Type::SELL)
                {
                    if (current_mode == Control::Type::BUY)
                    {
                        offset = 0;

                        last = offset + limit;

                        if (last > party.Members[character].Equipment.size())
                        {
                            last = party.Members[character].Equipment.size();
                        }

                        controls = shopList(window, renderer, party.Members[character].Equipment, shop, offset, last, limit, textx, offsety);
                    }

                    current_mode = Control::Type::SELL;

                    current = FIND_CONTROL(controls, Control::Type::SELL);
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::EQUIPMENT)
            {
                if (current_mode != Control::Type::EQUIPMENT)
                {
                    if (current_mode == Control::Type::BUY)
                    {
                        offset = 0;

                        last = offset + limit;

                        if (last > party.Members[character].Equipment.size())
                        {
                            last = party.Members[character].Equipment.size();
                        }

                        controls = shopList(window, renderer, party.Members[character].Equipment, shop, offset, last, limit, textx, offsety);
                    }

                    current_mode = Control::Type::EQUIPMENT;

                    current = FIND_CONTROL(controls, Control::Type::EQUIPMENT);
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::PREVIOUS_CHARACTER)
            {
                if (current_mode != Control::Type::PREVIOUS_CHARACTER)
                {
                    if (current_mode == Control::Type::BUY)
                    {
                        offset = 0;

                        last = offset + limit;

                        if (last > party.Members[character].Equipment.size())
                        {
                            last = party.Members[character].Equipment.size();
                        }

                        controls = shopList(window, renderer, party.Members[character].Equipment, shop, offset, last, limit, textx, offsety);
                    }

                    current_mode = Control::Type::PREVIOUS_CHARACTER;

                    current = FIND_CONTROL(controls, Control::Type::PREVIOUS_CHARACTER);
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::NEXT_CHARACTER)
            {
                if (current_mode != Control::Type::NEXT_CHARACTER)
                {
                    if (current_mode == Control::Type::BUY)
                    {
                        offset = 0;

                        last = offset + limit;

                        if (last > party.Members[character].Equipment.size())
                        {
                            last = party.Members[character].Equipment.size();
                        }

                        controls = shopList(window, renderer, party.Members[character].Equipment, shop, offset, last, limit, textx, offsety);
                    }

                    current_mode = Control::Type::NEXT_CHARACTER;

                    current = FIND_CONTROL(controls, Control::Type::NEXT_CHARACTER);
                }

                selected = false;
            }
        }

        if (current_mode == Control::Type::BUY)
        {
            putHeader(renderer, (buy_selection.size() > 0 ? (std::string("Selected (") + std::to_string(buy_selection.size()) + std::string(")")).c_str() : "Selected"), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * bigger_boxh + infoh));
        }
        else if (current_mode == Control::Type::SELL || current_mode == Control::Type::EQUIPMENT || current_mode == Control::Type::PREVIOUS_CHARACTER || current_mode == Control::Type::NEXT_CHARACTER)
        {
            putHeader(renderer, (sell_selection.size() > 0 ? (std::string("Selected (") + std::to_string(sell_selection.size()) + std::string(")")).c_str() : "Selected"), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * bigger_boxh + infoh));
        }
        else
        {
            fillRect(renderer, splashw, infoh, startx, starty + text_bounds - (2 * bigger_boxh + infoh), fg);
        }

        if (buy_selection.size() > 0 || sell_selection.size() > 0)
        {
            std::string selection_string = "";

            if (current_mode == Control::Type::BUY)
            {
                for (auto i = 0; i < buy_selection.size(); i++)
                {
                    if (buy_selection[i] >= 0 && buy_selection[i] < shop.size())
                    {
                        if (i > 0)
                        {
                            selection_string += ", ";
                        }

                        auto item = std::get<0>(shop[buy_selection[i]]);

                        selection_string += item.Name;
                    }
                }
            }
            else if (current_mode == Control::Type::SELL || current_mode == Control::Type::EQUIPMENT || current_mode == Control::Type::PREVIOUS_CHARACTER || current_mode == Control::Type::NEXT_CHARACTER)
            {
                for (auto i = 0; i < sell_selection.size(); i++)
                {
                    if (sell_selection[i] >= 0 && sell_selection[i] < party.Members[character].Equipment.size())
                    {
                        if (i > 0)
                        {
                            selection_string += ", ";
                        }

                        auto item = party.Members[character].Equipment[sell_selection[i]];

                        selection_string += item.Name;
                    }
                }
            }

            fillRect(renderer, splashw, 2 * bigger_boxh, startx, starty + text_bounds - 2 * bigger_boxh, intBE);

            auto text = createText(selection_string.c_str(), FONT_MASON, 24, clrBK, splashw - 2 * text_space, TTF_STYLE_NORMAL);

            if (text)
            {
                renderText(renderer, text, intBE, startx + text_space, starty + text_bounds - 2 * bigger_boxh + text_space, 2 * (bigger_boxh - text_space), 0);

                SDL_FreeSurface(text);

                text = NULL;
            }
        }
        else
        {
            putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * bigger_boxh, startx, starty + text_bounds - 2 * bigger_boxh);
        }

        if (current_mode == Control::Type::BUY)
        {
            std::string buy_string = "";

            if (buy_selection.size() > 1)
            {
                buy_string = "Buy these";
            }
            else if (buy_selection.size() == 1)
            {
                buy_string = "Buy this";
            }
            else
            {
                buy_string = "Items for sale";
            }

            putHeader(renderer, buy_string.c_str(), font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
        }
        else if (current_mode == Control::Type::SELL)
        {
            std::string sell_string = "";

            if (sell_selection.size() > 1)
            {
                sell_string = "Sell these";
            }
            else if (sell_selection.size() == 1)
            {
                sell_string = "Sell this";
            }
            else
            {
                sell_string = party.Members[character].Name + "'s items";
            }

            putHeader(renderer, sell_string.c_str(), font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
        }
        else if (current_mode == Control::Type::EQUIPMENT || current_mode == Control::Type::PREVIOUS_CHARACTER || current_mode == Control::Type::NEXT_CHARACTER)
        {
            std::string view_string = party.Members[character].Name + "'s items";

            putHeader(renderer, view_string.c_str(), font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
        }
        else
        {
            fillRect(renderer, textwidth, infoh, textx, texty, fg);
        }

        fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

        if (last - offset > 0)
        {
            for (auto i = 0; i < last - offset; i++)
            {
                if (controls[i].Type == Control::Type::ACTION)
                {
                    if (current_mode == Control::Type::BUY)
                    {
                        if (Engine::FIND_LIST(buy_selection, offset + i) >= 0)
                        {
                            thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                        }
                        else
                        {
                            drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                        }
                    }
                    else if (current_mode == Control::Type::SELL || current_mode == Control::Type::EQUIPMENT || current_mode == Control::Type::PREVIOUS_CHARACTER || current_mode == Control::Type::NEXT_CHARACTER)
                    {
                        if (Engine::FIND_LIST(sell_selection, offset + i) >= 0)
                        {
                            thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                        }
                        else
                        {
                            drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                        }
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }
        }

        renderButtons(renderer, controls, current, intLB, text_space, border_pts);

        if (current >= 0 && current < controls.size())
        {
            renderCaption(renderer, font_caption, controls[current]);
        }

        if (flash_message)
        {
            if ((SDL_GetTicks() - start_ticks) < duration)
            {
                putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, bigger_boxh * 2, -1, -1);
            }
            else
            {
                flash_message = false;
            }
        }

        Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

        if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
        {
            if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
            {
                if (current_mode == Control::Type::BUY)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > shop.size())
                        {
                            last = shop.size();
                        }

                        controls = shopList(window, renderer, shop, offset, last, limit, textx, offsety);

                        SDL_Delay(50);
                    }
                }
                else if (current_mode == Control::Type::SELL || current_mode == Control::Type::EQUIPMENT || current_mode == Control::Type::NEXT_CHARACTER || current_mode == Control::Type::PREVIOUS_CHARACTER)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > party.Members[character].Equipment.size())
                        {
                            last = party.Members[character].Equipment.size();
                        }

                        controls = shopList(window, renderer, party.Members[character].Equipment, shop, offset, last, limit, textx, offsety);

                        SDL_Delay(50);
                    }
                }

                if (offset <= 0)
                {
                    current = -1;

                    selected = false;
                }
            }
            else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
            {
                if (current_mode == Control::Type::BUY)
                {
                    if (shop.size() - last > 0)
                    {
                        if (offset < shop.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > shop.size() - limit)
                        {
                            offset = shop.size() - limit;
                        }

                        last = offset + limit;

                        if (last > shop.size())
                        {
                            last = shop.size();
                        }

                        controls = shopList(window, renderer, shop, offset, last, limit, textx, offsety);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (shop.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (current_mode == Control::Type::SELL || current_mode == Control::Type::EQUIPMENT || current_mode == Control::Type::PREVIOUS_CHARACTER || current_mode == Control::Type::NEXT_CHARACTER)
                {
                    if (party.Members[character].Equipment.size() - last > 0)
                    {
                        if (offset < party.Members[character].Equipment.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > party.Members[character].Equipment.size() - limit)
                        {
                            offset = party.Members[character].Equipment.size() - limit;
                        }

                        last = offset + limit;

                        if (last > party.Members[character].Equipment.size())
                        {
                            last = party.Members[character].Equipment.size();
                        }

                        controls = shopList(window, renderer, party.Members[character].Equipment, shop, offset, last, limit, textx, offsety);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (party.Members[character].Equipment.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
            }
            else if (controls[current].Type == Control::Type::ACTION && !hold)
            {
                if (current >= 0 && current < controls.size())
                {
                    if (current_mode == Control::Type::BUY)
                    {
                        auto result = Engine::FIND_LIST(buy_selection, offset + current);

                        if (result >= 0)
                        {
                            buy_selection.erase(buy_selection.begin() + result);
                        }
                        else
                        {
                            if ((offset + current) >= 0 && (offset + current) < shop.size())
                            {
                                buy_selection.push_back(offset + current);
                            }
                        }
                    }
                    else if (current_mode == Control::Type::SELL || current_mode == Control::Type::EQUIPMENT || current_mode == Control::Type::NEXT_CHARACTER || current_mode == Control::Type::PREVIOUS_CHARACTER)
                    {
                        auto result = Engine::FIND_LIST(sell_selection, offset + current);

                        if (result >= 0)
                        {
                            sell_selection.erase(sell_selection.begin() + result);
                        }
                        else
                        {
                            if ((offset + current) >= 0 && (offset + current) < party.Members[character].Equipment.size())
                            {
                                sell_selection.push_back(offset + current);
                            }
                        }
                    }
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::BUY && !hold)
            {
                if (buy_selection.size() > 0)
                {
                    auto total = 0;

                    auto items = std::vector<std::tuple<Equipment::Base, int>>();
                    auto codes_gained = std::vector<Codes::Base>();

                    for (auto i = 0; i < buy_selection.size(); i++)
                    {
                        if (buy_selection[i] >= 0 && buy_selection[i] < shop.size())
                        {
                            auto item = std::get<0>(shop[buy_selection[i]]);

                            auto price = std::get<1>(shop[buy_selection[i]]);

                            auto supply = std::get<3>(shop[buy_selection[i]]);

                            if (price > 0 && (supply == -1 || supply > 0))
                            {
                                items.push_back({item, buy_selection[i]});

                                total += price;
                            }
                        }
                    }

                    if (items.size() > 0)
                    {
                        if (party.Money >= total)
                        {
                            if (party.Members[character].Type == Character::Type::SKULLCRACKER)
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("Skullcracker refuses to buy anything!", intRD);
                            }
                            else
                            {
                                Engine::GAIN_MONEY(party, -total);

                                message = "Item";

                                if (items.size() > 1)
                                {
                                    message += "s";
                                }

                                message += " purchased: ";

                                for (auto i = 0; i < items.size(); i++)
                                {
                                    auto item = std::get<0>(items[i]);
                                    auto index = std::get<1>(items[i]);

                                    party.Members[character].Equipment.push_back(item);

                                    if (index >= 0 && index < shop.size())
                                    {
                                        auto supply = std::get<3>(shop[index]);
                                        auto codes = std::get<4>(shop[index]);

                                        if (supply > 0)
                                        {
                                            std::get<3>(shop[index]) = supply - 1;
                                        }

                                        if (codes.size() > 0)
                                        {
                                            if (!Engine::VERIFY_CODES(party, codes))
                                            {
                                                codes_gained.insert(codes_gained.end(), codes.begin(), codes.end());
                                            }

                                            Engine::GET_CODES(party, codes);
                                        }
                                    }

                                    if (i > 0)
                                    {
                                        message += ", ";
                                    }

                                    message += item.Name;
                                }

                                if (codes_gained.size() > 0)
                                {
                                    message += ", Codes gained: ";

                                    for (auto i = 0; i < codes_gained.size(); i++)
                                    {
                                        message += std::string(Codes::Prefix[codes_gained[i].Type]) + std::to_string(codes_gained[i].Code);
                                    }
                                }

                                while (!Engine::VERIFY_EQUIPMENT_LIMIT(party.Members[character]))
                                {
                                    inventoryScreen(window, renderer, party, team, party.Members[character], -1, false);
                                }

                                Sound::Play(Sound::Type::SUCCESS);

                                displayMessage(message, intLB);

                                controls = shopList(window, renderer, shop, offset, last, limit, textx, offsety);

                                buy_selection.clear();
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have enough silver coins!", intRD);
                        }
                    }
                }
                else
                {
                    Sound::Play(Sound::Type::ERROR);

                    displayMessage("Please select the items you wish to buy!", intRD);
                }

                current = FIND_CONTROL(controls, Control::Type::BUY);

                selected = false;
            }
            else if (controls[current].Type == Control::Type::SELL && !hold)
            {
                if (sell_selection.size() > 0)
                {
                    if (party.Members[character].Type == Character::Type::SKULLCRACKER)
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("Skullcracker refuses to sell anything!", intRD);
                    }
                    else
                    {
                        std::string sold_string = "";
                        std::string unsold_string = "";

                        auto sold = 0;
                        auto unsold = 0;

                        auto sold_items = std::vector<int>();

                        for (auto i = 0; i < sell_selection.size(); i++)
                        {
                            if (sell_selection[i] >= 0 && sell_selection[i] < party.Members[character].Equipment.size())
                            {
                                auto item = party.Members[character].Equipment[sell_selection[i]];

                                auto price = Engine::PRICE_SELL(shop, item.Type);

                                if (price > 0)
                                {
                                    if (!Engine::VERIFY_EQUIPMENT(party.Members[character], {item.Type}))
                                    {
                                        unsold += 1;

                                        if (unsold_string.length() > 0)
                                        {
                                            unsold_string += ", ";
                                        }

                                        unsold_string += item.Name;
                                    }
                                    else
                                    {
                                        Engine::GAIN_MONEY(party, price);

                                        sold += 1;

                                        if (sold_string.length() > 0)
                                        {
                                            sold_string += ", ";
                                        }

                                        sold_string += item.Name;

                                        sold_items.push_back(sell_selection[i]);
                                    }
                                }
                                else
                                {
                                    unsold += 1;

                                    if (unsold_string.length() > 0)
                                    {
                                        unsold_string += ", ";
                                    }

                                    unsold_string += item.Name;
                                }
                            }
                        }

                        message = "";

                        if (sold > 0)
                        {
                            message += "Items sold: " + sold_string;
                        }

                        if (unsold > 0)
                        {
                            if (sold > 0)
                            {
                                message += "\n";
                            }

                            message += "Items not sold: " + unsold_string;
                        }

                        if (sold > unsold)
                        {
                            Sound::Play(Sound::Type::SUCCESS);

                            flash_color = intLB;
                        }
                        else
                        {
                            Sound::Play(Sound::Type::FAIL);

                            flash_color = intRD;
                        }

                        displayMessage(message, flash_color);

                        if (sold_items.size() > 0)
                        {
                            auto remaining = std::vector<Equipment::Base>();

                            for (auto i = 0; i < party.Members[character].Equipment.size(); i++)
                            {
                                if (Engine::FIND_LIST(sold_items, i) < 0)
                                {
                                    remaining.push_back(party.Members[character].Equipment[i]);
                                }
                            }

                            party.Members[character].Equipment = remaining;
                        }

                        if (sold > 0)
                        {
                            offset = 0;

                            last = offset + limit;

                            if (last > party.Members[character].Equipment.size())
                            {
                                last = party.Members[character].Equipment.size();
                            }

                            controls = shopList(window, renderer, party.Members[character].Equipment, shop, offset, last, limit, textx, offsety);
                        }
                    }
                }
                else
                {
                    Sound::Play(Sound::Type::ERROR);

                    displayMessage("Please select the items you wish to sell!", intRD);
                }

                sell_selection.clear();

                current = FIND_CONTROL(controls, Control::Type::SELL);

                selected = false;
            }
            else if (controls[current].Type == Control::Type::EQUIPMENT && !hold)
            {
                if (Engine::IS_ACTIVE(party, character))
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    inventoryScreen(window, renderer, party, team, party.Members[character], -1, false);
                }
            }
            else if (controls[current].Type == Control::Type::PREVIOUS_CHARACTER && !hold)
            {
                if (character > 0)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    character -= 1;

                    offset = 0;

                    last = offset + limit;

                    if (last > party.Members[character].Equipment.size())
                    {
                        last = party.Members[character].Equipment.size();
                    }

                    controls = shopList(window, renderer, party.Members[character].Equipment, shop, offset, last, limit, textx, offsety);

                    current_mode = Control::Type::PREVIOUS_CHARACTER;

                    current = FIND_CONTROL(controls, Control::Type::PREVIOUS_CHARACTER);

                    sell_selection.clear();

                    buy_selection.clear();

                    selected = false;
                }
                else
                {
                    Sound::Play(Sound::Type::ERROR);
                }
            }
            else if (controls[current].Type == Control::Type::NEXT_CHARACTER && !hold)
            {
                if (character < party.Members.size() - 1)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    character += 1;

                    offset = 0;

                    last = offset + limit;

                    if (last > party.Members[character].Equipment.size())
                    {
                        last = party.Members[character].Equipment.size();
                    }

                    controls = shopList(window, renderer, party.Members[character].Equipment, shop, offset, last, limit, textx, offsety);

                    current_mode = Control::Type::NEXT_CHARACTER;

                    current = FIND_CONTROL(controls, Control::Type::NEXT_CHARACTER);

                    sell_selection.clear();

                    buy_selection.clear();

                    selected = false;
                }
                else
                {
                    Sound::Play(Sound::Type::ERROR);
                }
            }
            else if (controls[current].Type == Control::Type::BACK && !hold)
            {
                Sound::Play(Sound::Type::BUTTON_CLICK);

                done = true;
            }
        }
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    if (font_caption)
    {
        TTF_CloseFont(font_caption);

        font_caption = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    TTF_Quit();

    if (splash)
    {
        SDL_FreeSurface(splash);

        splash = NULL;
    }

    return false;
}

bool restScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, int RestPrice, bool CanRecharge)
{
    TTF_Init();

    auto font_mason = TTF_OpenFont(FONT_MASON, 24);
    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

    TTF_SetFontKerning(font_dark11, 0);

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Rest and Recovery");

        auto current = -1;

        auto selection = std::vector<int>();

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > party.Members.size())
        {
            last = party.Members.size();
        }

        auto controls = restList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh);

        auto done = false;

        auto scrollUp = false;
        auto selected = false;
        auto scrollDown = false;
        auto hold = false;
        auto scrollSpeed = 1;

        std::string message = "";

        auto flash_message = false;

        auto flash_color = intRD;

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (current >= 0 && current < controls.size())
            {
                auto cost = 0;

                if (selection.size() > 0)
                {
                    for (auto i = 0; i < selection.size(); i++)
                    {
                        if (selection[i] >= 0 && selection[i] < party.Members.size() && RestPrice >= 0)
                        {
                            if (controls[current].Type != Control::Type::FULL_RECOVERY)
                            {
                                cost += (Engine::IS_INJURED(party.Members[selection[i]])) ? RestPrice : 0;
                            }
                            else
                            {
                                cost += (Engine::IS_INJURED(party.Members[selection[i]])) ? RestPrice * (party.Members[selection[i]].MaximumHealth - party.Members[selection[i]].Health) : 0;
                            }
                        }
                    }

                    if (cost > 0 && RestPrice >= 0)
                    {
                        std::string heal_string = "";

                        if (controls[current].Type != Control::Type::FULL_RECOVERY)
                        {
                            heal_string = "Heal (" + std::to_string(cost);
                        }
                        else
                        {
                            heal_string = "Fully Recover (" + std::to_string(cost);
                        }

                        heal_string += ")";

                        putText(renderer, heal_string.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                    }
                    else
                    {
                        putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                    }
                }
                else
                {
                    putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                }
            }
            else
            {
                putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
            }

            std::string party_string = "";

            if (selection.size() > 0)
            {
                for (auto i = 0; i < selection.size(); i++)
                {
                    if (i > 0)
                    {
                        party_string += "\n";
                    }

                    party_string += party.Members[selection[i]].Name;
                }
            }

            putText(renderer, selection.size() > 0 ? party_string.c_str() : "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);

            putHeader(renderer, "Money", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty);
            putText(renderer, (std::to_string(party.Money) + std::string(" silver coins")).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + infoh);

            if (RestPrice >= 0)
            {
                putHeader(renderer, "Healing Costs", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space - 1));
                putText(renderer, (RestPrice > 0 ? std::to_string(RestPrice) + std::string(" silver coins") : std::string("Free")).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + text_bounds - (3 * boxh + infoh + box_space));
            }

            putHeader(renderer, "Party", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (Engine::FIND_LIST(selection, offset + i) >= 0)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, boxh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > party.Members.size())
                        {
                            last = party.Members.size();
                        }

                        controls = restList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (party.Members.size() - last > 0)
                    {
                        if (offset < party.Members.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > party.Members.size() - limit)
                        {
                            offset = party.Members.size() - limit;
                        }

                        last = offset + limit;

                        if (last > party.Members.size())
                        {
                            last = party.Members.size();
                        }

                        controls = restList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (party.Members.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current >= 0 && current < controls.size())
                    {
                        auto result = Engine::FIND_LIST(selection, offset + current);

                        if (result >= 0)
                        {
                            selection.erase(selection.begin() + result);
                        }
                        else
                        {
                            if (selection.size() < party.Members.size())
                            {
                                selection.push_back(offset + current);
                            }
                        }
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::HEAL1 && !hold)
                {
                    if (selection.size() > 0 && RestPrice >= 0)
                    {
                        auto cost = 0;

                        for (auto i = 0; i < selection.size(); i++)
                        {
                            cost += (Engine::IS_INJURED(party.Members[selection[i]])) ? RestPrice : 0;
                        }

                        if (party.Money < cost)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have enough silver coins!", intRD);
                        }
                        else
                        {
                            for (auto i = 0; i < selection.size(); i++)
                            {
                                if (Engine::IS_INJURED(party.Members[selection[i]]))
                                {
                                    Engine::GAIN_HEALTH(party.Members[selection[i]], 1);
                                }
                            }

                            Engine::GAIN_MONEY(party, -cost);

                            if (cost > 0)
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                message = "Your party was healed for " + std::to_string(cost) + " silver coins.";
                            }
                            else
                            {
                                if (RestPrice > 0)
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    message = "None of your party members are injured.";
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    message = "Your party was healed for free.";
                                }
                            }

                            displayMessage(message, intLB);

                            offset = 0;

                            last = offset + limit;

                            if (last > party.Members.size())
                            {
                                last = party.Members.size();
                            }

                            controls = restList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh);
                        }
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::FULL_RECOVERY && !hold)
                {
                    if (selection.size() > 0 && RestPrice >= 0)
                    {
                        auto cost = 0;

                        for (auto i = 0; i < selection.size(); i++)
                        {
                            cost += (Engine::IS_INJURED(party.Members[selection[i]])) ? RestPrice * (party.Members[selection[i]].MaximumHealth - party.Members[selection[i]].Health) : 0;
                        }

                        if (party.Money < cost)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have enough silver coins!", intRD);
                        }
                        else
                        {
                            for (auto i = 0; i < selection.size(); i++)
                            {
                                if (Engine::IS_INJURED(party.Members[selection[i]]))
                                {
                                    Engine::GAIN_HEALTH(party.Members[selection[i]], party.Members[selection[i]].MaximumHealth - party.Members[selection[i]].Health);
                                }
                            }

                            Engine::GAIN_MONEY(party, -cost);

                            if (cost > 0)
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                message = "Your party was healed for " + std::to_string(cost) + " silver coins.";
                            }
                            else
                            {
                                if (RestPrice > 0)
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    message = "None of your party members are injured.";
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    message = "Your party was healed for free.";
                                }
                            }

                            displayMessage(message, intLB);

                            offset = 0;

                            last = offset + limit;

                            if (last > party.Members.size())
                            {
                                last = party.Members.size();
                            }

                            controls = restList(window, renderer, party.Members, offset, last, limit, textx, texty + infoh);
                        }
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::RECHARGE && !hold)
                {
                    if (CanRecharge && Engine::SPELLCASTERS(party) > 0)
                    {
                        auto character = -1;

                        if (Engine::SPELLCASTERS(party) == 1)
                        {
                            character = Engine::FIRST_CASTER(party);
                        }
                        else
                        {
                            character = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, Control::Type::ANY);
                        }

                        if (Engine::IS_ACTIVE(party, character))
                        {
                            if (party.Members[character].SpellCaster)
                            {
                                if (party.Members[character].SpellBook.size() > 0)
                                {
                                    Sound::Play(Sound::Type::BUTTON_CLICK);

                                    rechargeSpells(window, renderer, party, party.Members[character]);
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage(party.Members[character].Name + "'s spellbook is empty!", intRD);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[character].Name + " is not a spell caster!", intRD);
                            }
                        }
                        else
                        {
                            if (character >= 0 && character < party.Members.size())
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[character].Name + " cannot recharge spells!", intRD);
                            }
                        }
                    }
                    else if (Engine::SPELLCASTERS(party) > 0)
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You cannot recharge your spells here!", intRD);
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You do not have any spell casters in your party!", intRD);
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;
                }
            }
        }
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    TTF_Quit();

    return false;
}

bool vaultScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Character::Base &character)
{
    auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

    auto scrollSpeed = 1;

    auto popupw = (int)(0.6 * SCREEN_WIDTH);
    auto popuph = (int)(0.6 * SCREEN_HEIGHT);
    auto popupx = (SCREEN_WIDTH - popupw) / 2;
    auto popupy = ((starty + text_bounds) - popuph) / 2;

    auto offset = 0;
    auto limit = (text_bounds - 2 * text_space - infoh) / (56);
    auto last = offset + limit;

    if (last > party.Vault.size())
    {
        last = party.Vault.size();
    }

    std::string message = "";

    auto flash_message = false;

    auto flash_color = intRD;

    Uint32 start_ticks = 0;

    Uint32 duration = 3000;

    auto displayMessage = [&](std::string msg, Uint32 color)
    {
        flash_message = true;

        message = msg;

        flash_color = color;

        start_ticks = SDL_GetTicks();
    };

    auto fg = Color::HEADER(party.Book);

    auto done = false;

    auto offsety = (texty + infoh);

    std::vector<Button> controls = {};
    std::vector<Button> controls_vault = {};
    std::vector<Button> controls_money = {};

    controls_vault = vaultList(window, renderer, party.Vault, offset, last, limit, offsety, scrolly);
    controls_money = popupMoney(window, renderer, party, popupw, popuph, infoh, popupx, popupy);

    TTF_Init();

    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
    auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);
    auto font_mason = TTF_OpenFont(FONT_MASON, 24);

    TTF_SetFontKerning(font_dark11, 0);

    auto selected = false;
    auto current = -1;
    auto scrollUp = false;
    auto scrollDown = false;
    auto hold = false;
    auto selection = -1;
    auto start_money = 0;

    auto current_mode = Control::Type::EQUIPMENT;

    while (!done)
    {
        last = offset + limit;

        if (last > party.Vault.size())
        {
            last = party.Vault.size();
        }

        SDL_SetWindowTitle(window, "Legendary Kingdoms: The Vault");

        fillWindow(renderer, intWH);

        if (splash)
        {
            fitImage(renderer, splash, startx, starty, splashw, text_bounds);
        }

        putHeader(renderer, "Money in Vault", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - 2 * (bigger_boxh + infoh) - box_space);

        putText(renderer, (std::to_string(party.VaultMoney) + " silver coins").c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, bigger_boxh, startx, starty + text_bounds - 2 * bigger_boxh - infoh - box_space);

        putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (bigger_boxh + infoh));

        if (selection >= 0 && selection < party.Vault.size())
        {
            auto item_string = itemString(party.Vault[selection]);

            putText(renderer, item_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, bigger_boxh, startx, starty + text_bounds - bigger_boxh);
        }
        else
        {
            putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, bigger_boxh, startx, starty + text_bounds - bigger_boxh);
        }

        if (selection >= 0 && selection < party.Vault.size())
        {
            auto item = party.Vault[selection];

            if (current_mode == Control::Type::EQUIPMENT)
            {
                if (current >= 0 && current < controls_vault.size())
                {
                    if (controls_vault[current].Type == Control::Type::USE)
                    {
                        putHeader(renderer, (std::string("Use the ") + item.Name).c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                    }
                    else if (controls_vault[current].Type == Control::Type::TRANSFER)
                    {
                        putHeader(renderer, (std::string("Transfer the ") + item.Name).c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                    }
                    else if (controls_vault[current].Type == Control::Type::MONEY)
                    {
                        putHeader(renderer, "Access money in vault", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                    }
                    else
                    {
                        putHeader(renderer, "Items inside the Vault", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                    }
                }
                else
                {
                    putHeader(renderer, "Items inside the Vault", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
            }
            else
            {
                putHeader(renderer, "Items inside the Vault", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
        }
        else
        {
            if (current_mode == Control::Type::EQUIPMENT)
            {
                if (current >= 0 && current < controls_vault.size())
                {
                    if (controls_vault[current].Type == Control::Type::USE)
                    {
                        putHeader(renderer, "Use item", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                    }
                    else if (controls_vault[current].Type == Control::Type::TRANSFER)
                    {
                        putHeader(renderer, "Transfer item to another party member", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                    }
                    else if (controls_vault[current].Type == Control::Type::MONEY)
                    {
                        putHeader(renderer, "Access money in vault", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                    }
                    else
                    {
                        putHeader(renderer, "Items inside the Vault", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                    }
                }
                else
                {
                    putHeader(renderer, "Items inside the Vault", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
            }
            else
            {
                putHeader(renderer, "Items inside the Vault", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
        }

        fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

        if (last - offset > 0)
        {
            for (auto i = 0; i < last - offset; i++)
            {
                if (selection != offset + i)
                {
                    drawRect(renderer, controls_vault[i].W + border_space, controls_vault[i].H + border_space, controls_vault[i].X - border_pts, controls_vault[i].Y - border_pts, intBK);
                }
                else
                {
                    thickRect(renderer, controls_vault[i].W + border_pts, controls_vault[i].H + border_pts, controls_vault[i].X - 2, controls_vault[i].Y - 2, intLB, 2);
                }
            }
        }

        if (current_mode == Control::Type::EQUIPMENT)
        {
            renderButtons(renderer, controls_vault, current, intLB, text_space, border_pts);

            controls = controls_vault;
        }
        else
        {
            renderButtons(renderer, controls_vault, -1, intLB, text_space, border_pts);

            fillRect(renderer, popupw, popuph, popupx, popupy, intBE);

            drawRect(renderer, popupw, popuph, popupx, popupy, intBK);

            putHeader(renderer, "Transfer money", font_dark11, text_space, clrWH, intDB, TTF_STYLE_NORMAL, popupw, infoh, popupx, popupy);

            drawRect(renderer, controls_money[0].W + border_space, controls_money[0].H + border_space, controls_money[0].X - border_pts, controls_money[0].Y - border_pts, intBK);
            drawRect(renderer, controls_money[1].W + border_space, controls_money[1].H + border_space, controls_money[1].X - border_pts, controls_money[1].Y - border_pts, intBK);

            renderButtons(renderer, controls_money, current, intLB, border_space, border_pts);

            controls = controls_money;
        }

        if (current >= 0 && current < controls.size())
        {
            renderCaption(renderer, font_caption, controls[current]);
        }

        if (flash_message)
        {
            if ((SDL_GetTicks() - start_ticks) < duration)
            {
                putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, bigger_boxh * 2, -1, -1);
            }
            else
            {
                flash_message = false;
            }
        }

        Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

        if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
        {
            if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
            {
                if (offset > 0)
                {
                    offset -= scrollSpeed;

                    if (offset < 0)
                    {
                        offset = 0;
                    }

                    last = offset + limit;

                    if (last > party.Vault.size())
                    {
                        last = party.Vault.size();
                    }

                    controls_vault = vaultList(window, renderer, party.Vault, offset, last, limit, offsety, scrolly);

                    SDL_Delay(50);
                }

                if (offset <= 0)
                {
                    current = -1;

                    selected = false;
                }
            }
            else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
            {
                if (party.Vault.size() - last > 0)
                {
                    if (offset < party.Vault.size() - limit)
                    {
                        offset += scrollSpeed;
                    }

                    if (offset > party.Vault.size() - limit)
                    {
                        offset = party.Vault.size() - limit;
                    }

                    last = offset + limit;

                    if (last > party.Vault.size())
                    {
                        last = party.Vault.size();
                    }

                    controls_vault = vaultList(window, renderer, party.Vault, offset, last, limit, offsety, scrolly);

                    SDL_Delay(50);

                    if (offset > 0)
                    {
                        current = FIND_CONTROL(controls_vault, Control::Type::SCROLL_DOWN);
                    }
                }

                if (party.Vault.size() - last <= 0)
                {
                    selected = false;

                    current = -1;
                }
            }
            else if (controls[current].Type == Control::Type::ACTION && !hold)
            {
                if (current_mode == Control::Type::EQUIPMENT)
                {
                    if ((current + offset >= 0) && (current + offset) < party.Vault.size())
                    {
                        if (selection == current + offset)
                        {
                            selection = -1;
                        }
                        else
                        {
                            selection = current + offset;
                        }
                    }
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::USE && !hold)
            {
                if (selection >= 0 && selection < party.Vault.size())
                {
                    auto used_up = false;

                    auto item = party.Vault[selection];

                    if (item.Type == Equipment::Type::HEALING_POTION)
                    {
                        if (character.Health < character.MaximumHealth)
                        {
                            Sound::Play(Sound::Type::SUCCESS);

                            displayMessage(character.Name + " recovers up to 5 Health points!", intLB);

                            Engine::GAIN_HEALTH(character, 5);

                            used_up = true;
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(character.Name + " is not injured!", intRD);
                        }
                    }

                    if (used_up)
                    {
                        if (party.Vault.size() > 0)
                        {
                            party.Vault.erase(party.Vault.begin() + selection);

                            if (offset > 0)
                            {
                                offset -= 1;
                            }

                            last = offset + limit;

                            if (last > party.Vault.size())
                            {
                                last = party.Vault.size();
                            }

                            controls_vault = vaultList(window, renderer, party.Vault, offset, last, limit, offsety, scrolly);
                        }

                        selection = -1;

                        current = -1;

                        selected = false;
                    }
                }
            }
            else if (controls[current].Type == Control::Type::TRANSFER && !hold)
            {
                if (selection >= 0 && selection < party.Vault.size())
                {
                    auto item = party.Vault[selection];

                    if (Engine::COUNT(party) > 1)
                    {
                        if (character.Team != Team::Type::SOLO)
                        {
                            auto target = selectPartyMember(window, renderer, party, character.Team, item, Control::Type::EQUIPMENT);

                            if (target >= 0 && target < party.Members.size() && party.Members[target].Type != Character::Type::SKULLCRACKER)
                            {
                                party.Vault.erase(party.Vault.begin() + selection);

                                party.Members[target].Equipment.push_back(item);

                                if (offset > 0)
                                {
                                    offset -= 1;
                                }

                                last = offset + limit;

                                if (last > party.Vault.size())
                                {
                                    last = party.Vault.size();
                                }

                                controls_vault = vaultList(window, renderer, party.Vault, offset, last, limit, offsety, scrolly);

                                message = itemString(item);

                                message += " transferred to " + party.Members[target].Name + "!";

                                displayMessage(message, intLB);

                                selected = false;

                                current = -1;

                                selection = -1;

                                Sound::Play(Sound::Type::SUCCESS);
                            }
                            else if (target >= 0 && target < party.Members.size() && party.Members[target].Type == Character::Type::SKULLCRACKER)
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[target].Name + " refuses to accept it!", intRD);

                                selected = false;

                                current = -1;

                                selection = -1;
                            }
                        }
                        else
                        {
                            party.Vault.erase(party.Vault.begin() + selection);

                            character.Equipment.push_back(item);

                            if (offset > 0)
                            {
                                offset -= 1;
                            }

                            last = offset + limit;

                            if (last > party.Vault.size())
                            {
                                last = party.Vault.size();
                            }

                            controls_vault = vaultList(window, renderer, party.Vault, offset, last, limit, offsety, scrolly);

                            message = itemString(item);

                            message += " transferred to " + character.Name + "!";

                            displayMessage(message, intLB);

                            selected = false;

                            current = -1;

                            selection = -1;

                            Sound::Play(Sound::Type::SUCCESS);
                        }
                    }
                    else
                    {
                        party.Vault.erase(party.Vault.begin() + selection);

                        character.Equipment.push_back(item);

                        if (offset > 0)
                        {
                            offset -= 1;
                        }

                        last = offset + limit;

                        if (last > party.Vault.size())
                        {
                            last = party.Vault.size();
                        }

                        controls_vault = vaultList(window, renderer, party.Vault, offset, last, limit, offsety, scrolly);

                        message = itemString(item);

                        message += " transferred to " + character.Name + "!";

                        displayMessage(message, intLB);

                        selected = false;

                        current = -1;

                        selection = -1;

                        Sound::Play(Sound::Type::SUCCESS);
                    }
                }
            }
            else if (controls[current].Type == Control::Type::MONEY && !hold)
            {
                if (current_mode == Control::Type::EQUIPMENT)
                {
                    start_money = party.Money;

                    current_mode = Control::Type::MONEY;

                    current = -1;
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::CONFIRM && !hold)
            {
                if (current_mode == Control::Type::MONEY)
                {
                    if (party.Money != start_money)
                    {
                        Sound::Play(Sound::Type::SUCCESS);

                        auto diff = start_money - party.Money;

                        if (party.Money < start_money)
                        {
                            if (diff > 1)
                            {
                                displayMessage(std::to_string(diff) + " silver coins stored in The Vault.", intLB);
                            }
                            else
                            {
                                displayMessage("One silver coin stored in The Vault.", intLB);
                            }
                        }
                        else if (party.Money > start_money)
                        {
                            if (diff < -1)
                            {
                                displayMessage(std::to_string(-diff) + " silver coins withdrawn from The Vault.", intLB);
                            }
                            else
                            {
                                displayMessage("One silver coin withdrawn from The Vault.", intLB);
                            }
                        }
                    }

                    current_mode = Control::Type::EQUIPMENT;

                    current = -1;
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::PLUS && !hold)
            {
                if (current_mode == Control::Type::MONEY)
                {
                    if (party.Money > 0)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        auto store = std::min<int>(party.Money, 10);

                        party.VaultMoney += store;

                        party.Money -= store;
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You do not have any silver to store in the vault", intRD);
                    }

                    controls_money = popupMoney(window, renderer, party, popupw, popuph, infoh, popupx, popupy);
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::MINUS && !hold)
            {
                if (current_mode == Control::Type::MONEY)
                {
                    if (party.VaultMoney > 0)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        auto withdraw = std::min<int>(party.VaultMoney, 10);

                        party.VaultMoney -= withdraw;

                        party.Money += withdraw;
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You do not have any silver to withdraw from the vault", intRD);
                    }

                    controls_money = popupMoney(window, renderer, party, popupw, popuph, infoh, popupx, popupy);
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::BACK && !hold)
            {
                Sound::Play(Sound::Type::BUTTON_CLICK);

                done = true;
            }
        }
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    if (font_caption)
    {
        TTF_CloseFont(font_caption);

        font_caption = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    TTF_Quit();

    if (splash)
    {
        SDL_FreeSurface(splash);

        splash = NULL;
    }

    return false;
}

std::vector<Button> repairList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (ships.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            std::string ship_string = shipString(ships[index], true);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, ship_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (ships.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (ships.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "REPAIR 1", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, ships.size() > 0 ? (last - start) - 1 : idx, idx, startx, text_buttony, Control::Type::REPAIR1));
    controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "FULLY REPAIR", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, ships.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::FULL_REPAIR));
    controls.push_back(Button(idx + 2, createHeaderButton(window, FONT_DARK11, 22, "BACK", clrWH, intDB, text_buttonw, 48, -1), idx + 1, idx + 2, ships.size() > 0 ? (last - start) - 1 : idx + 2, idx + 2, startx + 2 * text_gridsize, text_buttony, Control::Type::BACK));

    return controls;
}

bool repairScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Story::Base *harbour)
{
    TTF_Init();

    auto font_mason = TTF_OpenFont(FONT_MASON, 24);
    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

    TTF_SetFontKerning(font_dark11, 0);

    if (window && renderer)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Repairs");

        auto current = -1;

        auto selection = std::vector<int>();

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > party.Fleet.size())
        {
            last = party.Fleet.size();
        }

        auto controls = repairList(window, renderer, party.Fleet, offset, last, limit, textx, texty + infoh);

        auto done = false;
        auto scrollUp = false;
        auto selected = false;
        auto scrollDown = false;
        auto hold = false;
        auto scrollSpeed = 1;

        std::string message = "";

        auto flash_message = false;

        auto flash_color = intRD;

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        while (!done)
        {
            fillWindow(renderer, intWH);

            if (current >= 0 && current < controls.size())
            {
                auto cost = 0;

                if (selection.size() > 0)
                {
                    for (auto i = 0; i < selection.size(); i++)
                    {
                        if (selection[i] >= 0 && selection[i] < party.Fleet.size() && harbour->ShipRepairPrice >= 0)
                        {
                            if (controls[current].Type != Control::Type::FULL_REPAIR)
                            {
                                cost += ((Engine::IS_DAMAGED(party.Fleet[selection[i]])) ? harbour->ShipRepairPrice : 0);
                            }
                            else
                            {
                                cost += ((Engine::IS_DAMAGED(party.Fleet[selection[i]])) ? harbour->ShipRepairPrice * (party.Fleet[selection[i]].MaximumHealth - party.Fleet[selection[i]].Health) : 0);
                            }
                        }
                    }

                    if (cost > 0 && harbour->ShipRepairPrice >= 0)
                    {
                        std::string repair_string = "";

                        if (controls[current].Type != Control::Type::FULL_REPAIR)
                        {
                            repair_string = "Repair (" + std::to_string(cost);
                        }
                        else
                        {
                            repair_string = "Fully Repair (" + std::to_string(cost);
                        }

                        repair_string += ")";

                        putText(renderer, repair_string.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                    }
                    else
                    {
                        putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                    }
                }
                else
                {
                    putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                }
            }
            else
            {
                putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
            }

            std::string fleet_string = "";

            if (selection.size() > 0)
            {
                for (auto i = 0; i < selection.size(); i++)
                {
                    if (i > 0)
                    {
                        fleet_string += "\n";
                    }

                    fleet_string += "[" + party.Fleet[selection[i]].Name + "]";
                }
            }

            putText(renderer, selection.size() > 0 ? fleet_string.c_str() : "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);

            putHeader(renderer, "Money", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty);
            putText(renderer, (std::to_string(party.Money) + std::string(" silver coins")).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + infoh);

            if (harbour->ShipRepairPrice >= 0)
            {
                putHeader(renderer, "Repair Costs", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space - 1));

                putText(renderer, (harbour->ShipRepairPrice > 0 ? std::to_string(harbour->ShipRepairPrice) + std::string(" silver coins") : std::string("Free")).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + text_bounds - (3 * boxh + infoh + box_space));
            }

            putHeader(renderer, "Fleet", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (Engine::FIND_LIST(selection, offset + i) >= 0)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, boxh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > party.Fleet.size())
                        {
                            last = party.Fleet.size();
                        }

                        controls = repairList(window, renderer, party.Fleet, offset, last, limit, textx, texty + infoh);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (party.Fleet.size() - last > 0)
                    {
                        if (offset < party.Fleet.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > party.Fleet.size() - limit)
                        {
                            offset = party.Fleet.size() - limit;
                        }

                        last = offset + limit;

                        if (last > party.Fleet.size())
                        {
                            last = party.Fleet.size();
                        }

                        controls = repairList(window, renderer, party.Fleet, offset, last, limit, textx, texty + infoh);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (party.Fleet.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current >= 0 && current < controls.size())
                    {
                        auto result = Engine::FIND_LIST(selection, offset + current);

                        if (result >= 0)
                        {
                            selection.erase(selection.begin() + result);
                        }
                        else
                        {
                            if (party.Fleet[offset + current].Location != harbour->Location)
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("The [" + party.Fleet[offset + current].Name + "] is not docked at " + std::string(Location::Description[harbour->Location]) + "!", intRD);
                            }
                            else if (party.Fleet[offset + current].Health >= party.Fleet[offset + current].MaximumHealth)
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("The [" + party.Fleet[offset + current].Name + "] is not damaged!", intRD);
                            }
                            else if (party.Fleet[offset + current].Health <= 0)
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("The [" + party.Fleet[offset + current].Name + "] is damaged beyond repair!", intRD);
                            }
                            else if (selection.size() < party.Fleet.size())
                            {
                                selection.push_back(offset + current);
                            }
                        }
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::REPAIR1 && !hold)
                {
                    if (selection.size() > 0 && harbour->ShipRepairPrice >= 0)
                    {
                        auto cost = 0;

                        for (auto i = 0; i < selection.size(); i++)
                        {
                            cost += (Engine::IS_DAMAGED(party.Fleet[selection[i]])) ? harbour->ShipRepairPrice : 0;
                        }

                        if (party.Money < cost)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have enough silver coins!", intRD);
                        }
                        else
                        {
                            for (auto i = 0; i < selection.size(); i++)
                            {
                                if (Engine::IS_DAMAGED(party.Fleet[selection[i]]))
                                {
                                    Engine::GAIN_HEALTH(party.Fleet[selection[i]], 1);
                                }
                            }

                            Engine::GAIN_MONEY(party, -cost);

                            if (cost > 0)
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                message = "Your ships were repaired for " + std::to_string(cost) + " silver coins.";
                            }
                            else
                            {
                                if (harbour->ShipRepairPrice > 0)
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    message = "None of your ships are damaged.";
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    message = "Your ships were repaired for free.";
                                }
                            }

                            displayMessage(message, intLB);

                            offset = 0;

                            last = offset + limit;

                            if (last > party.Fleet.size())
                            {
                                last = party.Fleet.size();
                            }

                            controls = repairList(window, renderer, party.Fleet, offset, last, limit, textx, texty + infoh);
                        }
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::FULL_REPAIR && !hold)
                {
                    if (selection.size() > 0 && harbour->ShipRepairPrice >= 0)
                    {
                        auto cost = 0;

                        for (auto i = 0; i < selection.size(); i++)
                        {
                            cost += (Engine::IS_DAMAGED(party.Fleet[selection[i]])) ? harbour->ShipRepairPrice * (party.Fleet[selection[i]].MaximumHealth - party.Fleet[selection[i]].Health) : 0;
                        }

                        if (party.Money < cost)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have enough silver coins!", intRD);
                        }
                        else
                        {
                            for (auto i = 0; i < selection.size(); i++)
                            {
                                if (Engine::IS_DAMAGED(party.Fleet[selection[i]]))
                                {
                                    Engine::GAIN_HEALTH(party.Fleet[selection[i]], party.Fleet[selection[i]].MaximumHealth - party.Fleet[selection[i]].Health);
                                }
                            }

                            Engine::GAIN_MONEY(party, -cost);

                            if (cost > 0)
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                message = "Your ships were repaired for " + std::to_string(cost) + " silver coins.";
                            }
                            else
                            {
                                if (harbour->ShipRepairPrice > 0)
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    message = "None of your ships are damaged.";
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    message = "Your ships were repaired for free.";
                                }
                            }

                            displayMessage(message, intLB);

                            offset = 0;

                            last = offset + limit;

                            if (last > party.Fleet.size())
                            {
                                last = party.Fleet.size();
                            }

                            controls = repairList(window, renderer, party.Fleet, offset, last, limit, textx, texty + infoh);
                        }
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;
                }
            }
        }
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    TTF_Quit();

    return false;
}

bool inventoryScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, Character::Base &character, int equipment_limit, bool InCombat)
{
    auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

    auto scrollSpeed = 1;

    auto limit = (text_bounds - 2 * text_space - infoh) / (56);

    auto offset = 0;

    auto last = offset + limit;

    if (last > character.Equipment.size())
    {
        last = character.Equipment.size();
    }

    std::string message = "";

    auto flash_message = false;

    auto flash_color = intRD;

    Uint32 start_ticks = 0;

    Uint32 duration = 3000;

    auto displayMessage = [&](std::string msg, Uint32 color)
    {
        flash_message = true;

        message = msg;

        flash_color = color;

        start_ticks = SDL_GetTicks();
    };

    auto fg = Color::HEADER(party.Book);

    auto done = false;

    auto offsety = (texty + infoh);

    auto controls = equipmentList(window, renderer, character.Equipment, offset, last, limit, offsety, scrolly);

    TTF_Init();

    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
    auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);
    auto font_mason = TTF_OpenFont(FONT_MASON, 24);

    TTF_SetFontKerning(font_dark11, 0);

    auto selected = false;
    auto current = -1;
    auto scrollUp = false;
    auto scrollDown = false;
    auto hold = false;

    auto selection = -1;

    if (!Engine::VERIFY_EQUIPMENT_LIMIT(character) || (equipment_limit > -1 && !Engine::VERIFY_EQUIPMENT_LIMIT(character, equipment_limit)))
    {
        if (equipment_limit > -1)
        {
            if (equipment_limit > 0)
            {
                message = "You are carrying more than " + std::to_string(equipment_limit) + " item";

                if (equipment_limit > 1)
                {
                    message += "s";
                }

                message += ". Drop or transfer excess items.";
            }
            else
            {
                message = "Drop all your items.";
            }
        }
        else
        {
            message = "You are carrying too many items! Drop or transfer excess items.";
        }

        Sound::Play(Sound::Type::ERROR);

        displayMessage(message, intRD);
    }

    while (!done)
    {
        SDL_SetWindowTitle(window, "Legendary Kingdoms: Items");

        fillWindow(renderer, intWH);

        if (splash)
        {
            fitImage(renderer, splash, startx, starty, splashw, text_bounds);
        }

        putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (bigger_boxh + infoh));

        if (selection >= 0 && selection < character.Equipment.size())
        {
            putText(renderer, itemString(character.Equipment[selection]).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, bigger_boxh, startx, starty + text_bounds - bigger_boxh);
        }
        else
        {
            putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, bigger_boxh, startx, starty + text_bounds - bigger_boxh);
        }

        if (selection >= 0 && selection < character.Equipment.size())
        {
            auto item = character.Equipment[selection];

            if (current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::USE)
                {
                    putHeader(renderer, (std::string("Use the ") + item.Name).c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else if (controls[current].Type == Control::Type::DROP)
                {
                    putHeader(renderer, (std::string("Drop the ") + item.Name).c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else if (controls[current].Type == Control::Type::TRANSFER)
                {
                    putHeader(renderer, (std::string("Transfer the ") + item.Name).c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else if (controls[current].Type == Control::Type::VAULT)
                {
                    putHeader(renderer, (std::string("Send the ") + item.Name + " to the vault").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else
                {
                    putHeader(renderer, (character.Name + "'s items").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
            }
            else
            {
                putHeader(renderer, (character.Name + "'s items").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
        }
        else
        {
            if (current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::USE)
                {
                    putHeader(renderer, "Use item", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else if (controls[current].Type == Control::Type::DROP)
                {
                    putHeader(renderer, "Drop item", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else if (controls[current].Type == Control::Type::TRANSFER)
                {
                    putHeader(renderer, "Transfer item to another party member", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else if (controls[current].Type == Control::Type::VAULT)
                {
                    putHeader(renderer, "Access magic vault", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else
                {
                    putHeader(renderer, (character.Name + "'s items").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
            }
            else
            {
                putHeader(renderer, (character.Name + "'s items").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
        }

        fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

        if (last - offset > 0)
        {
            for (auto i = 0; i < last - offset; i++)
            {
                if (selection != offset + i)
                {
                    drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                }
                else
                {
                    thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                }
            }
        }

        renderButtons(renderer, controls, current, intLB, text_space, border_pts);

        if (current >= 0 && current < controls.size())
        {
            renderCaption(renderer, font_caption, controls[current]);
        }

        if (flash_message)
        {
            if ((SDL_GetTicks() - start_ticks) < duration)
            {
                putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, bigger_boxh * 2, -1, -1);
            }
            else
            {
                flash_message = false;
            }
        }

        Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

        if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
        {
            if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
            {
                if (offset > 0)
                {
                    offset -= scrollSpeed;

                    if (offset < 0)
                    {
                        offset = 0;
                    }

                    last = offset + limit;

                    if (last > character.Equipment.size())
                    {
                        last = character.Equipment.size();
                    }

                    controls = equipmentList(window, renderer, character.Equipment, offset, last, limit, offsety, scrolly);

                    SDL_Delay(50);
                }

                if (offset <= 0)
                {
                    current = -1;

                    selected = false;
                }
            }
            else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
            {
                if (character.Equipment.size() - last > 0)
                {
                    if (offset < character.Equipment.size() - limit)
                    {
                        offset += scrollSpeed;
                    }

                    if (offset > character.Equipment.size() - limit)
                    {
                        offset = character.Equipment.size() - limit;
                    }

                    last = offset + limit;

                    if (last > character.Equipment.size())
                    {
                        last = character.Equipment.size();
                    }

                    controls = equipmentList(window, renderer, character.Equipment, offset, last, limit, offsety, scrolly);

                    SDL_Delay(50);

                    if (offset > 0)
                    {
                        current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                    }
                }

                if (character.Equipment.size() - last <= 0)
                {
                    selected = false;

                    current = -1;
                }
            }
            else if (controls[current].Type == Control::Type::ACTION && !hold)
            {
                if ((current + offset >= 0) && (current + offset) < character.Equipment.size())
                {
                    if (selection == current + offset)
                    {
                        selection = -1;
                    }
                    else
                    {
                        selection = current + offset;
                    }
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::USE && !hold)
            {
                if (selection >= 0 && selection < character.Equipment.size())
                {
                    auto used_up = false;

                    auto item = character.Equipment[selection];

                    if (item.Type == Equipment::Type::SCROLL_OF_RAGE)
                    {
                        if (InCombat)
                        {
                            used_up = true;

                            for (auto i = 0; i < party.Members.size(); i++)
                            {
                                Engine::GAIN_STATUS(party.Members[i], Character::Status::ENRAGED);
                            }

                            Sound::Play(Sound::Type::SUCCESS);

                            displayMessage("Your party gains +1 Fighting score until end of combat!", intLB);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You cannot use the " + item.Name + " when not in combat!", intRD);
                        }
                    }
                    else if (item.Type == Equipment::Type::POTION_OF_INVULNERABILITY)
                    {
                        if (InCombat)
                        {
                            used_up = true;

                            Engine::GAIN_STATUS(character, Character::Status::POTION_OF_INVULNERABILITY);

                            displayMessage(character.Name + " becomes Invulnerable!", intLB);

                            Sound::Play(Sound::Type::SUCCESS);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You cannot use the " + item.Name + " when not in combat!", intRD);
                        }
                    }
                    else if (item.Type == Equipment::Type::HEALING_POTION)
                    {
                        if (character.Health < character.MaximumHealth)
                        {
                            displayMessage(character.Name + " recovers up to 5 Health points!", intLB);

                            Engine::GAIN_HEALTH(character, 5);

                            used_up = true;

                            Sound::Play(Sound::Type::SUCCESS);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(character.Name + " is not injured!", intRD);
                        }
                    }

                    if (used_up)
                    {
                        if (character.Equipment.size() > 0)
                        {
                            character.Equipment.erase(character.Equipment.begin() + selection);

                            if (offset > 0)
                            {
                                offset -= 1;
                            }

                            last = offset + limit;

                            if (last > character.Equipment.size())
                            {
                                last = character.Equipment.size();
                            }

                            controls = equipmentList(window, renderer, character.Equipment, offset, last, limit, offsety, scrolly);
                        }

                        selection = -1;

                        current = -1;
                    }

                    selected = false;
                }
            }
            else if (controls[current].Type == Control::Type::DROP && !hold)
            {
                if (selection >= 0 && selection < character.Equipment.size())
                {
                    if (InCombat)
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You cannot drop items while in combat!", intRD);
                    }
                    else if (character.Type != Character::Type::SKULLCRACKER)
                    {
                        auto item = character.Equipment[selection];

                        character.Equipment.erase(character.Equipment.begin() + selection);

                        if (offset > 0)
                        {
                            offset -= 1;
                        }

                        last = offset + limit;

                        if (last > character.Equipment.size())
                        {
                            last = character.Equipment.size();
                        }

                        controls = equipmentList(window, renderer, character.Equipment, offset, last, limit, offsety, scrolly);

                        message = itemString(item);

                        message += " dropped!";

                        displayMessage(message, intRD);

                        Sound::Play(Sound::Type::FAIL);
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("Skullcracker refuses!", intRD);
                    }

                    selected = false;

                    current = -1;

                    selection = -1;
                }
            }
            else if (controls[current].Type == Control::Type::TRANSFER && !hold)
            {
                if (selection >= 0 && selection < character.Equipment.size())
                {
                    if (Engine::COUNT(party) > 1)
                    {
                        if (InCombat)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You cannot transfer items while in combat!", intRD);
                        }
                        else if (character.Team != Team::Type::SOLO)
                        {
                            auto item = character.Equipment[selection];

                            if (character.Type != Character::Type::SKULLCRACKER)
                            {
                                auto target = selectPartyMember(window, renderer, party, character.Team, item, Control::Type::EQUIPMENT);

                                if (target >= 0 && target < party.Members.size())
                                {
                                    if (party.Members[target].Type != character.Type && party.Members[target].Type != Character::Type::SKULLCRACKER && (team == Team::Type::NONE || party.Members[target].Team == team))
                                    {
                                        character.Equipment.erase(character.Equipment.begin() + selection);

                                        party.Members[target].Equipment.push_back(item);

                                        if (offset > 0)
                                        {
                                            offset -= 1;
                                        }

                                        last = offset + limit;

                                        if (last > character.Equipment.size())
                                        {
                                            last = character.Equipment.size();
                                        }

                                        controls = equipmentList(window, renderer, character.Equipment, offset, last, limit, offsety, scrolly);

                                        message = itemString(item);

                                        message += " transferred to " + party.Members[target].Name + "!";

                                        displayMessage(message, intLB);

                                        selected = false;

                                        current = -1;

                                        selection = -1;

                                        Sound::Play(Sound::Type::SUCCESS);
                                    }
                                    else
                                    {
                                        if (party.Members[target].Type != Character::Type::SKULLCRACKER)
                                        {
                                            if (party.Members[target].Team != team)
                                            {
                                                Sound::Play(Sound::Type::ERROR);

                                                displayMessage("You can only transfer to another party member!", intRD);
                                            }
                                            else
                                            {
                                                Sound::Play(Sound::Type::ERROR);

                                                displayMessage("You can only transfer to another party member within the same team!", intRD);
                                            }
                                        }
                                        else
                                        {
                                            Sound::Play(Sound::Type::ERROR);

                                            displayMessage("Skullcracker refuses!", intRD);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("Skullcracker refuses!", intRD);
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(character.Name + " is alone right now!", intRD);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("There is no one else in your party!", intRD);
                    }
                }
            }
            else if (controls[current].Type == Control::Type::VAULT && !hold)
            {
                if (Engine::VERIFY_CODES(party, {Codes::Type::MAGIC_VAULT}))
                {
                    if (!InCombat)
                    {
                        if (selection >= 0 && selection < character.Equipment.size())
                        {
                            auto item = character.Equipment[selection];

                            character.Equipment.erase(character.Equipment.begin() + selection);

                            party.Vault.push_back(item);

                            if (offset > 0)
                            {
                                offset -= 1;
                            }

                            last = offset + limit;

                            if (last > character.Equipment.size())
                            {
                                last = character.Equipment.size();
                            }

                            controls = equipmentList(window, renderer, character.Equipment, offset, last, limit, offsety, scrolly);

                            message = itemString(item);

                            message += " transferred to the Vault!";

                            displayMessage(message, intLB);

                            selected = false;

                            current = -1;

                            selection = -1;

                            Sound::Play(Sound::Type::SUCCESS);
                        }
                        else
                        {
                            vaultScreen(window, renderer, party, character);

                            offset = 0;

                            last = offset + limit;

                            if (last > character.Equipment.size())
                            {
                                last = character.Equipment.size();
                            }

                            controls = equipmentList(window, renderer, character.Equipment, offset, last, limit, offsety, scrolly);

                            current = -1;

                            selection = -1;
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You cannot access The Vault while in combat!", intRD);
                    }
                }
                else
                {
                    Sound::Play(Sound::Type::ERROR);

                    displayMessage("The Vault is not accessible at this time!", intRD);
                }
            }
            else if (controls[current].Type == Control::Type::BACK && !hold)
            {
                if ((equipment_limit > -1 && !Engine::VERIFY_EQUIPMENT_LIMIT(character, equipment_limit)) || !Engine::VERIFY_EQUIPMENT_LIMIT(character))
                {
                    Sound::Play(Sound::Type::ERROR);

                    displayMessage("You are carrying too many items! Drop or transfer excess items.", intRD);
                }
                else
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;
                }
            }
        }
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    if (font_caption)
    {
        TTF_CloseFont(font_caption);

        font_caption = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    TTF_Quit();

    if (splash)
    {
        SDL_FreeSurface(splash);

        splash = NULL;
    }

    return false;
}

bool spellBook(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Character::Base &character, int spells_limit)
{
    auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

    auto font_size = 28;

    auto scrollSpeed = 1;
    auto limit = (int)((booksize - 2 * text_space) / (96));

    auto offset = 0;

    auto last = offset + limit;

    if (last > character.SpellBook.size())
    {
        last = character.SpellBook.size();
    }

    std::string message = "";

    auto flash_message = false;

    auto flash_color = intRD;

    Uint32 start_ticks = 0;

    Uint32 duration = 3000;

    auto displayMessage = [&](std::string msg, Uint32 color)
    {
        flash_message = true;

        message = msg;

        flash_color = color;

        start_ticks = SDL_GetTicks();
    };

    auto fg = Color::HEADER(party.Book);

    auto done = false;

    auto offsety = (texty + infoh);

    auto controls = spellList(window, renderer, character.SpellBook, offset, last, limit, textx, offsety, spelly);

    TTF_Init();

    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, font_size);
    auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);
    auto font_mason = TTF_OpenFont(FONT_MASON, 24);

    TTF_SetFontKerning(font_dark11, 0);

    auto selected = false;
    auto current = -1;
    auto scrollUp = false;
    auto scrollDown = false;
    auto hold = false;

    auto selection = -1;

    while (!done)
    {
        if (!Engine::VERIFY_SPELL_LIMIT(character) || (spells_limit > -1 && !Engine::VERIFY_SPELL_LIMIT(character, spells_limit)))
        {
            if (spells_limit > -1)
            {
                if (spells_limit > 0)
                {
                    message = "Your spellbook is holding more than " + std::to_string(spells_limit) + " spell";

                    if (spells_limit > 1)
                    {
                        message += "s";
                    }

                    message += ". Unlearn some spells from your spellbook.";
                }
                else
                {
                    message = "Unlearn all of your spells.";
                }
            }
            else
            {
                message = "Your spellbook is holding too many spells! You must unlearn spells from your spellbook.";
            }

            Sound::Play(Sound::Type::ERROR);

            displayMessage(message, intRD);
        }

        last = offset + limit;

        if (last > character.SpellBook.size())
        {
            last = character.SpellBook.size();
        }

        SDL_SetWindowTitle(window, "Legendary Kingdoms: Spellbook");

        fillWindow(renderer, intWH);

        if (splash)
        {
            fitImage(renderer, splash, startx, starty, splashw, text_bounds);
        }

        putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * bigger_boxh + infoh));

        if (selection >= 0 && selection < character.SpellBook.size())
        {
            putText(renderer, character.SpellBook[selection].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * bigger_boxh, startx, starty + text_bounds - 2 * bigger_boxh);
        }
        else
        {
            putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * bigger_boxh, startx, starty + text_bounds - 2 * bigger_boxh);
        }

        if (selection >= 0 && selection < character.SpellBook.size())
        {
            auto spell = character.SpellBook[selection];

            if (current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::SPELL)
                {
                    putHeader(renderer, (std::string("Cast ") + spell.Name).c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else if (controls[current].Type == Control::Type::UNLEARN)
                {
                    putHeader(renderer, (std::string("Unlearn ") + spell.Name).c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else
                {
                    putHeader(renderer, (character.Name + "'s spells").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
            }
            else
            {
                putHeader(renderer, (character.Name + "'s spellbook").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
        }
        else
        {
            if (current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::SPELL)
                {
                    putHeader(renderer, "Cast spell", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else if (controls[current].Type == Control::Type::UNLEARN)
                {
                    putHeader(renderer, "Unlearn Spell", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else
                {
                    putHeader(renderer, (character.Name + "'s spellbook").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
            }
            else
            {
                putHeader(renderer, (character.Name + "'s spellbook").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
        }

        fillRect(renderer, textwidth, booksize, textx, texty + infoh, intBE);

        if (last - offset > 0)
        {
            for (auto i = 0; i < last - offset; i++)
            {
                if (selection != offset + i)
                {
                    if (character.SpellBook[offset + i].Charged)
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                    }
                }
                else
                {
                    thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                }
            }
        }

        if (current >= 0 && current < controls.size() && controls[current].Type == Control::Type::ACTION)
        {
            if ((current + offset) >= 0 && (current + offset) < character.SpellBook.size())
            {
                fillRect(renderer, textwidth, text_bounds / 3, textx, texty + 2 * text_bounds / 3, intLB);

                auto text = createText(character.SpellBook[current + offset].Description.c_str(), FONT_GARAMOND, font_size, clrWH, listwidth, TTF_STYLE_NORMAL);

                renderText(renderer, text, intLB, textx + text_space, texty + 2 * text_bounds / 3 + text_space, text_bounds / 3 - 2 * text_space, 0);

                SDL_FreeSurface(text);

                text = NULL;
            }
        }
        else if (selection >= 0 && selection <= character.SpellBook.size())
        {
            fillRect(renderer, textwidth, text_bounds / 3, textx, texty + 2 * text_bounds / 3, intLB);

            auto text = createText(character.SpellBook[selection].Description.c_str(), FONT_GARAMOND, font_size, clrWH, listwidth, TTF_STYLE_NORMAL);

            renderText(renderer, text, intLB, textx + text_space, texty + 2 * text_bounds / 3 + text_space, text_bounds / 3 - 2 * text_space, 0);

            SDL_FreeSurface(text);

            text = NULL;
        }

        renderButtons(renderer, controls, current, intLB, text_space, border_pts);

        if (current >= 0 && current < controls.size())
        {
            renderCaption(renderer, font_caption, controls[current]);
        }

        if (flash_message)
        {
            if ((SDL_GetTicks() - start_ticks) < duration)
            {
                putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, bigger_boxh * 2, -1, -1);
            }
            else
            {
                flash_message = false;
            }
        }

        Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

        if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
        {
            if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
            {
                if (offset > 0)
                {
                    offset -= scrollSpeed;

                    if (offset < 0)
                    {
                        offset = 0;
                    }

                    last = offset + limit;

                    if (last > character.SpellBook.size())
                    {
                        last = character.SpellBook.size();
                    }

                    controls = spellList(window, renderer, character.SpellBook, offset, last, limit, textx, offsety, spelly);

                    SDL_Delay(50);
                }

                if (offset <= 0)
                {
                    current = -1;

                    selected = false;
                }
            }
            else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
            {
                if (character.SpellBook.size() - last > 0)
                {
                    if (offset < character.SpellBook.size() - limit)
                    {
                        offset += scrollSpeed;
                    }

                    if (offset > character.SpellBook.size() - limit)
                    {
                        offset = character.SpellBook.size() - limit;
                    }

                    last = offset + limit;

                    if (last > character.SpellBook.size())
                    {
                        last = character.SpellBook.size();
                    }

                    controls = spellList(window, renderer, character.SpellBook, offset, last, limit, textx, offsety, spelly);

                    SDL_Delay(50);

                    if (offset > 0)
                    {
                        current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                    }
                }

                if (character.SpellBook.size() - last <= 0)
                {
                    selected = false;

                    current = -1;
                }
            }
            else if (controls[current].Type == Control::Type::ACTION && !hold)
            {
                if ((current + offset >= 0) && (current + offset) < character.SpellBook.size())
                {
                    if (selection == current + offset)
                    {
                        selection = -1;
                    }
                    else
                    {
                        selection = current + offset;
                    }
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::SPELL && !hold)
            {
                if (selection >= 0 && selection < character.SpellBook.size())
                {
                    auto used_up = false;

                    if (character.SpellBook[selection].Charged && Engine::CAN_SPEAK(character))
                    {
                        if (character.SpellBook[selection].Type == Spells::Type::MAGIC_CABINET)
                        {
                            if (!Engine::VERIFY_CODES(party, {Codes::Type::MAGIC_VAULT}))
                            {
                                if (!Engine::VERIFY_CODES(party, {Codes::Type::NO_VAULT_ACCESS}))
                                {
                                    used_up = true;

                                    Engine::GET_CODES(party, {Codes::Type::MAGIC_VAULT});
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage("The Vault is not accessible at this time!", intRD);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("The Vault is already accessible!", intRD);
                            }
                        }
                        else if (character.SpellBook[selection].Type == Spells::Type::SOOTHING_TOUCH)
                        {
                            auto target = -1;

                            if (Engine::COUNT(party) == 1)
                            {
                                target = Engine::FIRST(party);
                            }
                            else
                            {
                                target = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, Control::Type::SPELL_TARGET);
                            }

                            if (target >= 0 && target < party.Members.size())
                            {
                                if (party.Members[target].Health <= 0 || party.Members[target].Health == party.Members[target].MaximumHealth || Engine::IS_CAPTURED(party.Members[target]))
                                {
                                    message = party.Members[target].Name;

                                    if (party.Members[target].Health <= 0)
                                    {
                                        message += " is dead!";
                                    }
                                    else if (Engine::IS_CAPTURED(party.Members[target]))
                                    {
                                        message += " has been captured!";
                                    }
                                    else
                                    {
                                        message += " is not injured!";
                                    }

                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage(message, intRD);
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    Engine::GAIN_HEALTH(party.Members[target], 5);

                                    used_up = true;
                                }
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage(character.Name + " cannot cast " + character.SpellBook[selection].Name + " at this time!", intRD);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage(character.Name + " cannot cast " + character.SpellBook[selection].Name + " at this time!", intRD);
                    }

                    if (used_up)
                    {
                        displayMessage(character.Name + " casts " + character.SpellBook[selection].Name, intLB);

                        character.SpellBook[selection].Charged = false;
                    }
                }

                selection = -1;

                current = -1;

                selected = false;
            }
            else if (controls[current].Type == Control::Type::UNLEARN && !hold)
            {
                if (selection >= 0 && selection < character.SpellBook.size())
                {
                    auto spell = character.SpellBook[selection];

                    character.SpellBook.erase(character.SpellBook.begin() + selection);

                    if (offset > 0)
                    {
                        offset -= 1;
                    }

                    last = offset + limit;

                    if (last > character.SpellBook.size())
                    {
                        last = character.SpellBook.size();
                    }

                    controls = spellList(window, renderer, character.SpellBook, offset, last, limit, textx, offsety, spelly);

                    message = spell.Name;

                    message += " erased from spellbook!";

                    displayMessage(message, intRD);

                    selected = false;

                    current = -1;

                    selection = -1;

                    Sound::Play(Sound::Type::FAIL);
                }
            }
            else if (controls[current].Type == Control::Type::BACK && !hold)
            {
                if (!Engine::VERIFY_SPELL_LIMIT(character))
                {
                    Sound::Play(Sound::Type::ERROR);

                    displayMessage("Your spellbook is holding too many spells! You must unlearn spells from your spellbook.", intRD);
                }
                else
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;
                }
            }
        }
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    if (font_caption)
    {
        TTF_CloseFont(font_caption);

        font_caption = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    TTF_Quit();

    if (splash)
    {
        SDL_FreeSurface(splash);

        splash = NULL;
    }

    return false;
}

bool rechargeSpells(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Character::Base &character)
{
    auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

    auto font_size = 28;

    auto scrollSpeed = 1;
    auto limit = (int)((booksize - 2 * text_space) / (96));

    auto offset = 0;

    auto last = offset + limit;

    if (last > character.SpellBook.size())
    {
        last = character.SpellBook.size();
    }

    std::string message = "";

    auto flash_message = false;

    auto flash_color = intRD;

    Uint32 start_ticks = 0;

    Uint32 duration = 3000;

    auto displayMessage = [&](std::string msg, Uint32 color)
    {
        flash_message = true;

        message = msg;

        flash_color = color;

        start_ticks = SDL_GetTicks();
    };

    auto fg = Color::HEADER(party.Book);

    auto done = false;

    auto offsety = (texty + infoh);

    auto controls = rechargeList(window, renderer, character.SpellBook, offset, last, limit, textx, offsety, spelly);

    TTF_Init();

    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, font_size);
    auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);
    auto font_mason = TTF_OpenFont(FONT_MASON, 24);

    TTF_SetFontKerning(font_dark11, 0);

    auto selected = false;
    auto current = -1;
    auto scrollUp = false;
    auto scrollDown = false;
    auto hold = false;

    auto selection = -1;

    if (Engine::VERIFY_CODES(party, {Codes::Type::RECHARGE_COSTS_HALF}))
    {
        displayMessage("The Everchild will sponsor your spellcasters, allowing you to recharge your spells at half the usual cost.", intLB);

        Sound::Play(Sound::Type::SUCCESS);
    }

    while (!done)
    {
        last = offset + limit;

        if (last > character.SpellBook.size())
        {
            last = character.SpellBook.size();
        }

        SDL_SetWindowTitle(window, "Legendary Kingdoms: Recharge Spells");

        fillWindow(renderer, intWH);

        if (splash)
        {
            fitImage(renderer, splash, startx, starty, splashw, text_bounds);
        }

        putHeader(renderer, "Money", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * bigger_boxh + 2 * infoh + box_space - 1));
        putText(renderer, (std::to_string(party.Money) + std::string(" silver coins")).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, bigger_boxh, startx, starty + text_bounds - (3 * bigger_boxh + infoh + box_space));

        putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * bigger_boxh + infoh));

        if (selection >= 0 && selection < character.SpellBook.size())
        {
            putText(renderer, character.SpellBook[selection].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * bigger_boxh, startx, starty + text_bounds - 2 * bigger_boxh);
        }
        else
        {
            putText(renderer, "(None)", font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * bigger_boxh, startx, starty + text_bounds - 2 * bigger_boxh);
        }

        if (selection >= 0 && selection < character.SpellBook.size())
        {
            auto spell = character.SpellBook[selection];

            if (current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::RECHARGE)
                {
                    putHeader(renderer, (std::string("Recharge ") + spell.Name).c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else
                {
                    putHeader(renderer, (character.Name + "'s spells").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
            }
            else
            {
                putHeader(renderer, (character.Name + "'s spellbook").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
        }
        else
        {
            if (current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::RECHARGE)
                {
                    putHeader(renderer, "Recharge spell", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
                else
                {
                    putHeader(renderer, (character.Name + "'s spellbook").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
                }
            }
            else
            {
                putHeader(renderer, (character.Name + "'s spellbook").c_str(), font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);
            }
        }

        fillRect(renderer, textwidth, booksize, textx, texty + infoh, intBE);

        if (last - offset > 0)
        {
            for (auto i = 0; i < last - offset; i++)
            {
                if (selection != offset + i)
                {
                    if (character.SpellBook[offset + i].Charged)
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intRD);
                    }
                }
                else
                {
                    thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                }
            }
        }

        if (current >= 0 && current < controls.size() && controls[current].Type == Control::Type::ACTION)
        {
            if ((current + offset) >= 0 && (current + offset) < character.SpellBook.size())
            {
                fillRect(renderer, textwidth, text_bounds / 3, textx, texty + 2 * text_bounds / 3, intLB);

                auto text = createText(character.SpellBook[current + offset].Description.c_str(), FONT_GARAMOND, font_size, clrWH, listwidth, TTF_STYLE_NORMAL);

                renderText(renderer, text, intLB, textx + text_space, texty + 2 * text_bounds / 3 + text_space, text_bounds / 3 - 2 * text_space, 0);

                SDL_FreeSurface(text);

                text = NULL;
            }
        }
        else if (selection >= 0 && selection < character.SpellBook.size())
        {
            fillRect(renderer, textwidth, text_bounds / 3, textx, texty + 2 * text_bounds / 3, intLB);

            auto text = createText(character.SpellBook[selection].Description.c_str(), FONT_GARAMOND, font_size, clrWH, listwidth, TTF_STYLE_NORMAL);

            renderText(renderer, text, intLB, textx + text_space, texty + 2 * text_bounds / 3 + text_space, text_bounds / 3 - 2 * text_space, 0);

            SDL_FreeSurface(text);

            text = NULL;
        }

        renderButtons(renderer, controls, current, intLB, text_space, border_pts);

        if (current >= 0 && current < controls.size())
        {
            renderCaption(renderer, font_caption, controls[current]);
        }

        if (flash_message)
        {
            if ((SDL_GetTicks() - start_ticks) < duration)
            {
                putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, bigger_boxh * 2, -1, -1);
            }
            else
            {
                flash_message = false;
            }
        }

        Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

        if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
        {
            if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
            {
                if (offset > 0)
                {
                    offset -= scrollSpeed;

                    if (offset < 0)
                    {
                        offset = 0;
                    }

                    last = offset + limit;

                    if (last > character.SpellBook.size())
                    {
                        last = character.SpellBook.size();
                    }

                    controls = rechargeList(window, renderer, character.SpellBook, offset, last, limit, textx, offsety, spelly);

                    SDL_Delay(50);
                }

                if (offset <= 0)
                {
                    current = -1;

                    selected = false;
                }
            }
            else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
            {
                if (character.SpellBook.size() - last > 0)
                {
                    if (offset < character.SpellBook.size() - limit)
                    {
                        offset += scrollSpeed;
                    }

                    if (offset > character.SpellBook.size() - limit)
                    {
                        offset = character.SpellBook.size() - limit;
                    }

                    last = offset + limit;

                    if (last > character.SpellBook.size())
                    {
                        last = character.SpellBook.size();
                    }

                    controls = rechargeList(window, renderer, character.SpellBook, offset, last, limit, textx, offsety, spelly);

                    SDL_Delay(50);

                    if (offset > 0)
                    {
                        current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                    }
                }

                if (character.SpellBook.size() - last <= 0)
                {
                    selected = false;

                    current = -1;
                }
            }
            else if (controls[current].Type == Control::Type::ACTION && !hold)
            {
                if ((current + offset >= 0) && (current + offset) < character.SpellBook.size())
                {
                    if (selection == current + offset)
                    {
                        selection = -1;
                    }
                    else
                    {
                        selection = current + offset;
                    }
                }

                selected = false;
            }
            else if (controls[current].Type == Control::Type::RECHARGE && !hold)
            {
                if (selection >= 0 && selection < character.SpellBook.size())
                {
                    if (!character.SpellBook[selection].Charged)
                    {
                        auto recharge_cost = character.SpellBook[selection].Recharge;

                        if (Engine::VERIFY_CODES(party, {Codes::Type::RECHARGE_COSTS_HALF}))
                        {
                            recharge_cost /= 2;
                        }

                        if (party.Money >= recharge_cost)
                        {
                            Engine::GAIN_MONEY(party, -recharge_cost);

                            character.SpellBook[selection].Charged = true;

                            displayMessage(character.SpellBook[selection].Name + " charged!", intLB);

                            Sound::Play(Sound::Type::SUCCESS);

                            controls = rechargeList(window, renderer, character.SpellBook, offset, last, limit, textx, offsety, spelly);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You cannot afford to recharge " + character.SpellBook[selection].Name + "!", intRD);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage(character.SpellBook[selection].Name + " is charged!", intRD);
                    }
                }

                selection = -1;

                current = -1;

                selected = false;
            }
            else if (controls[current].Type == Control::Type::BACK && !hold)
            {
                done = true;
            }
        }
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    if (font_caption)
    {
        TTF_CloseFont(font_caption);

        font_caption = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    TTF_Quit();

    if (splash)
    {
        SDL_FreeSurface(splash);

        splash = NULL;
    }

    return false;
}

std::vector<int> selectArmyUnits(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, std::vector<Army::Base> army, Location::Type garrison, int num_limit)
{
    auto selected_units = std::vector<int>();

    if (army.size() > 0)
    {
        auto font_size = 28;

        auto scrollSpeed = 1;
        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (124);
        auto last = offset + limit;

        if (last > army.size())
        {
            last = army.size();
        }

        std::string message = "";

        auto flash_message = false;

        auto flash_color = intRD;

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(book);

        auto controls = armyList(window, renderer, army, offset, last, limit, textx, texty + infoh, false);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, font_size);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto selected = false;
        auto current = -1;
        auto scrollUp = false;
        auto scrollDown = false;
        auto hold = false;

        auto selection = std::vector<int>();

        auto done = false;

        while (!done)
        {
            last = offset + limit;

            if (last > army.size())
            {
                last = army.size();
            }

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Select Army Units");

            fillWindow(renderer, intWH);

            std::string army_string = "";

            if (selection.size() > 0)
            {
                for (auto i = 0; i < selection.size(); i++)
                {
                    if (i > 0)
                    {
                        army_string += ", ";
                    }

                    std::string description = army[selection[i]].Name;

                    army_string += description;
                }
            }

            putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + infoh - 1));
            putText(renderer, selection.size() > 0 ? army_string.c_str() : "(None)", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 3 * boxh, startx, starty + text_bounds - 3 * boxh);

            putHeader(renderer, "Select units", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (Engine::FIND_LIST(selection, offset + i) >= 0)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, boxh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > army.size())
                        {
                            last = army.size();
                        }

                        controls = armyList(window, renderer, army, offset, last, limit, textx, texty + infoh, false);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (army.size() - last > 0)
                    {
                        if (offset < army.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > army.size() - limit)
                        {
                            offset = army.size() - limit;
                        }

                        last = offset + limit;

                        if (last > army.size())
                        {
                            last = army.size();
                        }

                        controls = armyList(window, renderer, army, offset, last, limit, textx, texty + infoh, false);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (army.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    auto result = Engine::FIND_LIST(selection, offset + current);

                    if (result >= 0 && result < army.size())
                    {
                        selection.erase(selection.begin() + result);
                    }
                    else
                    {
                        if (offset + current >= 0 && offset + current < army.size())
                        {
                            if (garrison == Location::Type::NONE || army[offset + current].Garrison == garrison)
                            {
                                if (selection.size() < num_limit)
                                {
                                    selection.push_back(offset + current);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("You can only select units from the " + std::string(Location::Description[garrison]) + " garrison!", intRD);
                            }
                        }
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    if (selection.size() > 0)
                    {
                        if (selection.size() >= num_limit || selection.size() >= Engine::COUNT(army, garrison))
                        {
                            selected_units = selection;

                            done = true;
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("Please complete your selection!", intRD);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("Please complete your selection!", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    selected_units = {};

                    done = true;
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        TTF_Quit();
    }

    return selected_units;
}

std::vector<int> selectArmyUnits(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Location::Type garrison, int num_limit)
{
    return selectArmyUnits(window, renderer, party.Book, party.Army, garrison, num_limit);
}

std::vector<int> selectShips(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, std::vector<Ship::Base> ships, Location::Type harbour, int num_limit, bool back_button)
{
    auto selected_units = std::vector<int>();

    if (ships.size() > 0)
    {
        auto font_size = 28;

        auto scrollSpeed = 1;
        auto offset = 0;

        auto limit = (text_bounds - 2 * text_space - infoh) / (124);
        auto last = offset + limit;

        if (last > ships.size())
        {
            last = ships.size();
        }

        std::string message = "";

        auto flash_message = false;

        auto flash_color = intRD;

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(book);

        auto controls = shipList(window, renderer, ships, offset, last, limit, textx, texty + infoh, true, true, back_button);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, font_size);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto selected = false;
        auto current = -1;
        auto scrollUp = false;
        auto scrollDown = false;
        auto hold = false;

        auto selection = std::vector<int>();

        auto done = false;

        while (!done)
        {
            last = offset + limit;

            if (last > ships.size())
            {
                last = ships.size();
            }

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Select Ships");

            fillWindow(renderer, intWH);

            std::string fleet_string = "";

            if (selection.size() > 0)
            {
                for (auto i = 0; i < selection.size(); i++)
                {
                    if (i > 0)
                    {
                        fleet_string += ", ";
                    }

                    std::string description = ships[selection[i]].Name;

                    fleet_string += description;
                }
            }

            putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + infoh - 1));
            putText(renderer, selection.size() > 0 ? fleet_string.c_str() : "(None)", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 3 * boxh, startx, starty + text_bounds - 3 * boxh);

            putHeader(renderer, "Select ships", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (Engine::FIND_LIST(selection, offset + i) >= 0)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, boxh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > ships.size())
                        {
                            last = ships.size();
                        }

                        controls = shipList(window, renderer, ships, offset, last, limit, textx, texty + infoh, true, true, back_button);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (ships.size() - last > 0)
                    {
                        if (offset < ships.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > ships.size() - limit)
                        {
                            offset = ships.size() - limit;
                        }

                        last = offset + limit;

                        if (last > ships.size())
                        {
                            last = ships.size();
                        }

                        controls = shipList(window, renderer, ships, offset, last, limit, textx, texty + infoh, true, true, back_button);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (ships.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    auto result = Engine::FIND_LIST(selection, offset + current);

                    if (result >= 0 && result < ships.size())
                    {
                        selection.erase(selection.begin() + result);
                    }
                    else
                    {
                        if (offset + current >= 0 && offset + current < ships.size())
                        {
                            if (harbour == Location::Type::NONE || ships[offset + current].Location == harbour)
                            {
                                if (selection.size() < num_limit)
                                {
                                    selection.push_back(offset + current);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("You can only select ships docked at " + std::string(Location::Description[harbour]) + " !", intRD);
                            }
                        }
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    if (selection.size() > 0)
                    {
                        if (selection.size() >= num_limit || selection.size() >= Engine::COUNT(ships, harbour))
                        {
                            selected_units = selection;

                            done = true;
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("Please complete your selection!", intRD);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("Please complete your selection!", intRD);
                    }
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    selected_units = {};

                    done = true;
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        TTF_Quit();
    }

    return selected_units;
}

bool IsValidTransfer(Party::Base &party, Location::Type src, Location::Type dst)
{
    bool valid = false;

    if (Engine::VERIFY_CODES(party, {Codes::A(33)}))
    {
        if (dst == Location::Type::SALTDAD)
        {
            valid = true;
        }
    }

    if (Engine::VERIFY_CODES(party, {Codes::A(100)}))
    {
        if (src == Location::Type::SALTDAD)
        {
            valid = true;
        }
    }

    return valid;
}

bool armyTransfer(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party)
{
    if (window && renderer && party.Army.size() > 0)
    {
        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto selected = false;
        auto current = -1;
        auto scrollUp = false;
        auto scrollDown = false;
        auto hold = false;

        std::string message = "";

        auto flash_message = false;

        auto flash_color = intRD;

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        // This will be expanded to include barracks from other lands (books)
        std::vector<Location::Type> barracks = {Location::Type::LUUTANESH, Location::Type::SALTDAD};

        auto popupw = (int)(0.6 * SCREEN_WIDTH);
        auto popuph = (int)(0.6 * SCREEN_HEIGHT);
        auto popupx = (SCREEN_WIDTH - popupw) / 2;
        auto popupy = ((starty + text_bounds) - popuph) / 2;

        auto popup_speed = 1;
        auto popup_offset = 0;
        auto popup_limit = (popuph - infoh - buttonh - button_space) / (96);
        auto popup_last = popup_offset + popup_limit;

        if (popup_last > barracks.size())
        {
            popup_last = barracks.size();
        }

        auto controls_popup = popupList(window, renderer, barracks, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy);

        auto scrollSpeed = 1;
        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > party.Army.size())
        {
            last = party.Army.size();
        }

        auto controls = std::vector<Button>();

        auto controls_army = armyList(window, renderer, party.Army, offset, last, limit, textx, texty + infoh);

        auto selection = -1;

        auto destination = -1;

        auto current_mode = Control::Type::ARMY;

        auto done = false;

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        while (!done)
        {
            last = offset + limit;

            if (last > party.Army.size())
            {
                last = party.Army.size();
            }

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Transfer Army Units");

            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            std::string army_string = "";

            if (selection >= 0 && selection < party.Army.size())
            {
                army_string = party.Army[selection].Name;
            }

            putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + infoh - 1));

            putText(renderer, (selection >= 0 && selection < party.Army.size()) ? army_string.c_str() : "(None)", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 3 * boxh, startx, starty + text_bounds - 3 * boxh);

            putHeader(renderer, "Troop Transfer", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (selection == (offset + i))
                    {
                        thickRect(renderer, controls_army[i].W + border_pts, controls_army[i].H + border_pts, controls_army[i].X - 2, controls_army[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls_army[i].W + border_space, controls_army[i].H + border_space, controls_army[i].X - border_pts, controls_army[i].Y - border_pts, intBK);
                    }
                }
            }

            if (current_mode == Control::Type::ARMY)
            {
                controls = controls_army;
            }
            else if (current_mode == Control::Type::TRANSFER)
            {
                renderButtons(renderer, controls_army, -1, intLB, border_space, border_pts);

                fillRect(renderer, popupw, popuph, popupx, popupy, intBE);

                drawRect(renderer, popupw, popuph, popupx, popupy, intBK);

                putHeader(renderer, "Select Destination", font_dark11, text_space, clrWH, intDB, TTF_STYLE_NORMAL, popupw, infoh, popupx, popupy);

                if (popup_last - popup_offset > 0)
                {
                    for (auto i = 0; i < popup_last - popup_offset; i++)
                    {
                        if (destination == popup_offset + i)
                        {
                            thickRect(renderer, controls_popup[i].W + border_pts, controls_popup[i].H + border_pts, controls_popup[i].X - 2, controls_popup[i].Y - 2, intLB, 2);
                        }
                        else
                        {
                            drawRect(renderer, controls_popup[i].W + border_space, controls_popup[i].H + border_space, controls_popup[i].X - border_pts, controls_popup[i].Y - border_pts, intBK);
                        }
                    }
                }

                controls = controls_popup;
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, boxh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (current_mode == Control::Type::ARMY)
                    {
                        if (offset > 0)
                        {
                            offset -= scrollSpeed;

                            if (offset < 0)
                            {
                                offset = 0;
                            }

                            last = offset + limit;

                            if (last > party.Army.size())
                            {
                                last = party.Army.size();
                            }

                            controls_army = armyList(window, renderer, party.Army, offset, last, limit, textx, texty + infoh);

                            SDL_Delay(50);
                        }

                        if (offset <= 0)
                        {
                            current = -1;

                            selected = false;
                        }
                    }
                    else if (current_mode == Control::Type::TRANSFER)
                    {
                        if (popup_offset > 0)
                        {
                            popup_offset -= popup_speed;

                            if (popup_offset < 0)
                            {
                                popup_offset = 0;
                            }

                            popup_last = popup_offset + popup_limit;

                            if (popup_last > barracks.size())
                            {
                                popup_last = barracks.size();
                            }

                            controls_popup = popupList(window, renderer, barracks, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy);

                            SDL_Delay(50);
                        }

                        if (popup_offset <= 0)
                        {
                            current = -1;

                            selected = false;
                        }
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (current_mode == Control::Type::ARMY)
                    {
                        if (party.Army.size() - last > 0)
                        {
                            if (offset < party.Army.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > party.Army.size() - limit)
                            {
                                offset = party.Army.size() - limit;
                            }

                            last = offset + limit;

                            if (last > party.Army.size())
                            {
                                last = party.Army.size();
                            }

                            controls_army = armyList(window, renderer, party.Army, offset, last, limit, textx, texty + infoh);

                            SDL_Delay(50);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls_army, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (party.Army.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }
                    else if (current_mode == Control::Type::TRANSFER)
                    {
                        if (barracks.size() - popup_last > 0)
                        {
                            if (popup_offset < barracks.size() - popup_limit)
                            {
                                popup_offset += popup_speed;
                            }

                            if (popup_offset > barracks.size() - popup_limit)
                            {
                                popup_offset = barracks.size() - popup_limit;
                            }

                            popup_last = popup_offset + popup_limit;

                            if (popup_last > barracks.size())
                            {
                                popup_last = barracks.size();
                            }

                            controls_popup = popupList(window, renderer, barracks, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy);

                            SDL_Delay(50);

                            if (popup_offset > 0)
                            {
                                current = FIND_CONTROL(controls_popup, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (barracks.size() - popup_last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current >= 0 && current < controls.size())
                    {
                        auto unit = offset + current;

                        if (current_mode == Control::Type::ARMY)
                        {
                            if (unit >= 0 && unit < party.Army.size())
                            {
                                if (selection == unit)
                                {
                                    selection = -1;
                                }
                                else
                                {
                                    selection = unit;

                                    current_mode = Control::Type::TRANSFER;
                                }
                            }
                        }
                        else if (current_mode == Control::Type::TRANSFER)
                        {
                            auto transfer = popup_offset + current;

                            if (transfer >= 0 && transfer < barracks.size())
                            {
                                if (destination == transfer)
                                {
                                    destination = -1;
                                }
                                else
                                {
                                    destination = transfer;
                                }
                            }
                        }
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    if (current_mode == Control::Type::TRANSFER)
                    {
                        if (selection >= 0 && selection <= party.Army.size() && destination >= 0 && destination < barracks.size())
                        {
                            auto src = party.Army[selection].Garrison;
                            auto dst = barracks[destination];

                            // verify Validity of transfer
                            if (src == dst)
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("The " + party.Army[selection].Name + " is already garrisoned at " + std::string(Location::Description[dst]) + "!", intRD);
                            }
                            else if (IsValidTransfer(party, src, dst))
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                displayMessage(party.Army[selection].Name + " from " + std::string(Location::Description[src]) + " barracks transferred to " + std::string(Location::Description[dst]) + ".", intLB);

                                party.Army[selection].Garrison = dst;

                                controls_army = armyList(window, renderer, party.Army, offset, last, limit, textx, texty + infoh);

                                destination = -1;

                                selection = -1;

                                current_mode = Control::Type::ARMY;
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("It is not possible to transfer the " + party.Army[selection].Name + " from " + std::string(Location::Description[src]) + " barracks to " + std::string(Location::Description[dst]) + " at this time.", intRD);
                            }
                        }
                        else if (selection >= 0 && selection <= party.Army.size())
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("Please select destination!", intRD);
                        }
                        else if (destination >= 0 && destination <= barracks.size())
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("Please select army unit to transfer!", intRD);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("Please select army unit and destination!", intRD);
                        }
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    if (current_mode == Control::Type::ARMY)
                    {
                        done = true;

                        Sound::Play(Sound::Type::BUTTON_CLICK);
                    }
                    else if (current_mode == Control::Type::TRANSFER)
                    {
                        current_mode = Control::Type::ARMY;

                        current = -1;

                        selection = -1;

                        destination = -1;

                        selected = false;

                        controls_army = armyList(window, renderer, party.Army, offset, last, limit, textx, texty + infoh);

                        Sound::Play(Sound::Type::BUTTON_CLICK);
                    }
                }
            }
        }

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        TTF_Quit();
    }

    return false;
}

bool armyScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Army::Base> army)
{
    auto done = false;

    if (army.size() > 0)
    {
        auto scrollSpeed = 1;

        auto offset = 0;

        auto limit = (text_bounds - 2 * text_space - infoh) / (124);

        auto last = offset + limit;

        if (last > army.size())
        {
            last = army.size();
        }

        std::string message = "";

        auto flash_message = false;

        auto flash_color = intRD;

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        auto controls = armyList(window, renderer, army, offset, last, limit, textx, texty + infoh, false);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto selected = false;
        auto current = -1;
        auto scrollUp = false;
        auto scrollDown = false;
        auto hold = false;

        auto selection = std::vector<int>();

        while (!done)
        {
            last = offset + limit;

            if (last > army.size())
            {
                last = army.size();
            }

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Add Army Units");

            fillWindow(renderer, intWH);

            std::string army_string = "";

            if (selection.size() > 0)
            {
                for (auto i = 0; i < selection.size(); i++)
                {
                    if (i > 0)
                    {
                        army_string += ", ";
                    }

                    std::string description = army[selection[i]].Name;

                    army_string += description;
                }
            }

            putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + infoh - 1));
            putText(renderer, selection.size() > 0 ? army_string.c_str() : "(None)", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 3 * boxh, startx, starty + text_bounds - 3 * boxh);

            putHeader(renderer, "Select the units to add to your army", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (Engine::FIND_LIST(selection, offset + i) >= 0)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, boxh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > army.size())
                        {
                            last = army.size();
                        }

                        controls = armyList(window, renderer, army, offset, last, limit, textx, texty + infoh, false);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (army.size() - last > 0)
                    {
                        if (offset < army.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > army.size() - limit)
                        {
                            offset = army.size() - limit;
                        }

                        last = offset + limit;

                        if (last > army.size())
                        {
                            last = army.size();
                        }

                        controls = armyList(window, renderer, army, offset, last, limit, textx, texty + infoh, false);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (army.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current >= 0 && current < controls.size())
                    {
                        auto result = Engine::FIND_LIST(selection, offset + current);

                        if (result >= 0)
                        {
                            selection.erase(selection.begin() + result);
                        }
                        else
                        {
                            if (selection.size() < army.size())
                            {
                                if (army[offset + current].Unique && Engine::HAS_UNIT(party, army[offset + current].Type))
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage("You already command the " + army[offset + current].Name + "!", intRD);
                                }
                                else
                                {
                                    selection.push_back(offset + current);
                                }
                            }
                        }
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    if (selection.size() > 0)
                    {
                        for (auto i = 0; i < selection.size(); i++)
                        {
                            if ((!army[selection[i]].Unique) || (army[selection[i]].Unique && !Engine::HAS_UNIT(party, army[selection[i]].Type)))
                            {
                                party.Army.push_back(army[selection[i]]);
                            }
                        }
                    }

                    done = true;
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = false;

                    break;
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        TTF_Quit();
    }

    return done;
}

bool spellScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, std::vector<Spells::Base> spells, bool back_button)
{
    auto done = false;

    if (spells.size() > 0)
    {
        auto font_size = 28;

        auto scrollSpeed = 1;
        auto offset = 0;

        auto limit = (int)((booksize - 2 * text_space) / (96));
        auto last = offset + limit;

        if (last > spells.size())
        {
            last = spells.size();
        }

        std::string message = "";

        auto flash_message = false;

        auto flash_color = intRD;

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        auto controls = spellList(window, renderer, spells, offset, last, limit, textx, texty + infoh, spelly, true, true);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, font_size);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto selected = false;
        auto current = -1;
        auto scrollUp = false;
        auto scrollDown = false;
        auto hold = false;

        auto selection = std::vector<int>();

        while (!done)
        {
            last = offset + limit;

            if (last > spells.size())
            {
                last = spells.size();
            }

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Learn Spells");

            fillWindow(renderer, intWH);

            std::string spell_string = "";

            if (selection.size() > 0)
            {
                for (auto i = 0; i < selection.size(); i++)
                {
                    if (i > 0)
                    {
                        spell_string += ", ";
                    }

                    std::string description = spells[selection[i]].Name;

                    spell_string += description;
                }
            }

            putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + infoh - 1));
            putText(renderer, selection.size() > 0 ? spell_string.c_str() : "(None)", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 3 * boxh, startx, starty + text_bounds - 3 * boxh);

            putHeader(renderer, "You can copy the following spells", font_garamond, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, booksize, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (Engine::FIND_LIST(selection, offset + i) >= 0)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }

            if (current >= 0 && current < controls.size() && controls[current].Type == Control::Type::ACTION)
            {
                fillRect(renderer, textwidth, text_bounds / 3, textx, texty + 2 * text_bounds / 3, intLB);

                auto text = createText(spells[current + offset].Description.c_str(), FONT_GARAMOND, font_size, clrWH, listwidth, TTF_STYLE_NORMAL);

                renderText(renderer, text, intLB, textx + text_space, texty + 2 * text_bounds / 3 + text_space, text_bounds / 3 - 2 * text_space, 0);

                SDL_FreeSurface(text);

                text = NULL;
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, boxh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > spells.size())
                        {
                            last = spells.size();
                        }

                        controls = spellList(window, renderer, spells, offset, last, limit, textx, texty + infoh, spelly, true, true);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (spells.size() - last > 0)
                    {
                        if (offset < spells.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > spells.size() - limit)
                        {
                            offset = spells.size() - limit;
                        }

                        last = offset + limit;

                        if (last > spells.size())
                        {
                            last = spells.size();
                        }

                        controls = spellList(window, renderer, spells, offset, last, limit, textx, texty + infoh, spelly, true, true);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (spells.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current >= 0 && current < controls.size())
                    {
                        auto result = Engine::FIND_LIST(selection, offset + current);

                        if (result >= 0)
                        {
                            selection.erase(selection.begin() + result);
                        }
                        else
                        {
                            if (selection.size() < spells.size())
                            {
                                selection.push_back(offset + current);
                            }
                        }
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    if (selection.size() > 0)
                    {
                        auto learn = std::vector<Spells::Base>();

                        for (auto i = 0; i < selection.size(); i++)
                        {
                            learn.push_back(spells[selection[i]]);
                        }

                        auto character = -1;

                        if (Engine::SPELLCASTERS(party) == 1)
                        {
                            character = Engine::FIRST_CASTER(party);
                        }
                        else
                        {
                            character = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, Control::Type::LEARN_SPELL);
                        }

                        if (character >= 0 && character < party.Members.size())
                        {
                            if (party.Members[character].SpellCaster)
                            {
                                auto learned = false;

                                for (auto i = 0; i < learn.size(); i++)
                                {
                                    if (Engine::VERIFY_SPELL(party.Members[character], {learn[i].Type}))
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        learned = true;

                                        displayMessage(party.Members[character].Name + " already knows the " + learn[i].Name + " spell!", intRD);

                                        break;
                                    }
                                }

                                if (learned)
                                {
                                    current = -1;

                                    selected = false;
                                }
                                else
                                {
                                    for (auto i = 0; i < learn.size(); i++)
                                    {
                                        party.Members[character].SpellBook.push_back(learn[i]);
                                    }

                                    while (!Engine::VERIFY_SPELL_LIMIT(party.Members[character]))
                                    {
                                        auto spell_selection = selectSpell(window, renderer, party.Book, party.Members[character], party.Members[character].SpellBook, party.Members[character].SpellBook.size() - party.Members[character].SpellBookLimit, Spells::Select::UNLEARN);

                                        if (spell_selection.size() > 0)
                                        {
                                            auto newSpellBook = std::vector<Spells::Base>();

                                            for (auto i = 0; i < party.Members[character].SpellBook.size(); i++)
                                            {
                                                if (Engine::FIND_LIST(spell_selection, i) < 0)
                                                {
                                                    newSpellBook.push_back(party.Members[character].SpellBook[i]);
                                                }
                                            }

                                            party.Members[character].SpellBook = newSpellBook;
                                        }
                                    }

                                    message = "Spell";

                                    if (selection.size() > 1)
                                    {
                                        message += "s";
                                    }

                                    message += " copied to " + party.Members[character].Name += "'s spellbook!";

                                    displayMessage(message, intLB);

                                    current = -1;

                                    selected = false;

                                    selection.clear();

                                    Sound::Play(Sound::Type::SUCCESS);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage(party.Members[character].Name + " is not a SpellCaster!", intRD);

                                current = -1;

                                selected = false;
                            }
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        done = true;
                    }
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = false;
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        TTF_Quit();
    }

    return done;
}

bool takeScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Team::Type team, std::vector<Equipment::Base> equipment, int TakeLimit, bool back_button)
{
    auto done = false;

    if (TakeLimit > 0)
    {
        auto scrollSpeed = 1;
        auto limit = (text_bounds - 2 * text_space) / (56);
        auto offset = 0;
        auto last = offset + limit;

        if (last > equipment.size())
        {
            last = equipment.size();
        }

        const char *message = NULL;

        auto error = false;

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto controls = equipmentList(window, renderer, equipment, offset, last, limit, true, back_button);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);

        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto selected = false;
        auto current = -1;
        auto scrollUp = false;
        auto scrollDown = false;
        auto hold = false;

        auto selection = std::vector<int>();

        auto fg = Color::HEADER(party.Book);

        while (!done)
        {
            SDL_SetWindowTitle(window, "Legendary Kingdoms: Take Items");

            fillWindow(renderer, intWH);

            std::string take = "";

            if (selection.size() > 0)
            {
                for (auto i = 0; i < selection.size(); i++)
                {
                    if (i > 0)
                    {
                        take += ", ";
                    }

                    std::string description = equipment[selection[i]].Name;

                    take += description;
                }
            }

            putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + infoh - 1));
            putText(renderer, selection.size() > 0 ? take.c_str() : "(None)", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 3 * boxh, startx, starty + text_bounds - 3 * boxh);

            fillRect(renderer, textwidth, text_bounds, textx, texty, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (Engine::FIND_LIST(selection, offset + i) >= 0)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + text_space, controls[i].H + text_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            if (error)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putText(renderer, message, font_garamond, text_space, clrWH, intRD, TTF_STYLE_NORMAL, splashw, boxh * 2, startx, starty);
                }
                else
                {
                    error = false;
                }
            }

            if (!error)
            {
                std::string take_message = "";

                if (equipment.size() > 1)
                {
                    if (TakeLimit > 1)
                    {
                        if (TakeLimit == equipment.size())
                        {
                            take_message = "You can take any number of items.";
                        }
                        else
                        {
                            take_message = "You can take up to " + std::to_string(TakeLimit) + " items.";
                        }
                    }
                    else
                    {
                        take_message = "Choose an item to keep.";
                    }
                }
                else
                {
                    take_message = "Keep this item?";
                }

                putText(renderer, take_message.c_str(), font_garamond, text_space, clrWH, intLB, TTF_STYLE_NORMAL, splashw, boxh, startx, starty);
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > equipment.size())
                        {
                            last = equipment.size();
                        }

                        controls = equipmentList(window, renderer, equipment, offset, last, limit, true, back_button);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (equipment.size() - last > 0)
                    {
                        if (offset < equipment.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > equipment.size() - limit)
                        {
                            offset = equipment.size() - limit;
                        }

                        last = offset + limit;

                        if (last > equipment.size())
                        {
                            last = equipment.size();
                        }

                        controls = equipmentList(window, renderer, equipment, offset, last, limit, true, back_button);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (equipment.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current >= 0 && current < controls.size())
                    {
                        auto result = Engine::FIND_LIST(selection, offset + current);

                        if (result >= 0 && result < selection.size())
                        {
                            selection.erase(selection.begin() + result);
                        }
                        else
                        {
                            if (selection.size() < TakeLimit)
                            {
                                selection.push_back(offset + current);
                            }
                        }
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    for (auto i = 0; i < selection.size(); i++)
                    {
                        if (equipment[selection[i]].Type == Equipment::Type::SILVER_COINS)
                        {
                            Engine::GAIN_MONEY(party, equipment[selection[i]].Value);
                        }
                        else
                        {
                            auto character = -1;

                            while (character < 0 || character > party.Members.size())
                            {
                                if (Engine::COUNT(party) == 1)
                                {
                                    character = Engine::FIRST(party);
                                }
                                else
                                {
                                    party.CurrentCharacter = Engine::FIND_SOLO(party);

                                    if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                                    {
                                        character = party.CurrentCharacter;
                                    }
                                    else
                                    {
                                        character = selectPartyMember(window, renderer, party, team, equipment[selection[i]], Control::Type::EQUIPMENT);
                                    }
                                }

                                if (Engine::IS_ACTIVE(party, character) && party.Members[character].Type != Character::Type::SKULLCRACKER)
                                {
                                    Engine::GET_EQUIPMENT(party.Members[character], {equipment[selection[i]]});

                                    while (!Engine::VERIFY_EQUIPMENT_LIMIT(party.Members[character]))
                                    {
                                        inventoryScreen(window, renderer, party, team, party.Members[character], -1, false);
                                    }
                                }
                            }
                        }
                    }

                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = false;
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        TTF_Quit();
    }

    return done;
}

bool loseItems(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Character::Type character, Team::Type team, std::vector<Equipment::Base> equipment, std::vector<Equipment::Class> exceptions, int LoseLimit, bool back_button)
{
    auto done = false;

    if (LoseLimit > 0)
    {
        auto scrollSpeed = 1;
        auto limit = (text_bounds - 2 * text_space) / (56);
        auto offset = 0;
        auto last = offset + limit;

        if (last > equipment.size())
        {
            last = equipment.size();
        }

        const char *message = NULL;

        auto error = false;

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto fg = Color::HEADER(party.Book);

        auto controls = equipmentList(window, renderer, equipment, offset, last, limit, true, back_button);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);

        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        auto selected = false;
        auto current = -1;
        auto scrollUp = false;
        auto scrollDown = false;
        auto hold = false;

        auto selection = std::vector<int>();

        while (!done)
        {
            SDL_SetWindowTitle(window, "Legendary Kingdoms: Lose Items");

            fillWindow(renderer, intWH);

            std::string lose = "";

            if (selection.size() > 0)
            {
                for (auto i = 0; i < selection.size(); i++)
                {
                    if (i > 0)
                    {
                        lose += ", ";
                    }

                    std::string description = equipment[selection[i]].Name;

                    lose += description;
                }
            }

            putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + infoh - 1));
            putText(renderer, selection.size() > 0 ? lose.c_str() : "(None)", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 3 * boxh, startx, starty + text_bounds - 3 * boxh);

            fillRect(renderer, textwidth, text_bounds, textx, texty, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (Engine::FIND_LIST(selection, offset + i) >= 0)
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + text_space, controls[i].H + text_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            if (error)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putText(renderer, message, font_garamond, text_space, clrWH, intRD, TTF_STYLE_NORMAL, splashw, boxh * 2, startx, starty);
                }
                else
                {
                    error = false;
                }
            }

            if (!error)
            {
                std::string lose_message = "";

                if (equipment.size() > 1)
                {
                    if (LoseLimit > 1)
                    {
                        if (LoseLimit == equipment.size())
                        {
                            lose_message = "You must lose all items.";
                        }
                        else
                        {
                            lose_message = "You must lose up to " + std::to_string(LoseLimit) + " items.";
                        }
                    }
                    else
                    {
                        lose_message = "Choose an item to lose.";
                    }
                }
                else
                {
                    lose_message = "Lose this item?";
                }

                putText(renderer, lose_message.c_str(), font_garamond, text_space, clrWH, intLB, TTF_STYLE_NORMAL, splashw, boxh, startx, starty);
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > equipment.size())
                        {
                            last = equipment.size();
                        }

                        controls = equipmentList(window, renderer, equipment, offset, last, limit, true, back_button);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (equipment.size() - last > 0)
                    {
                        if (offset < equipment.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > equipment.size() - limit)
                        {
                            offset = equipment.size() - limit;
                        }

                        last = offset + limit;

                        if (last > equipment.size())
                        {
                            last = equipment.size();
                        }

                        controls = equipmentList(window, renderer, equipment, offset, last, limit, true, back_button);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (equipment.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current >= 0 && current < controls.size())
                    {
                        auto result = Engine::FIND_LIST(selection, offset + current);

                        if (result >= 0)
                        {
                            selection.erase(selection.begin() + result);
                        }
                        else
                        {
                            if (selection.size() < LoseLimit)
                            {
                                if (exceptions.size() > 0)
                                {
                                    if (Engine::FIND_LIST(exceptions, equipment[offset + current].Class) < 0)
                                    {
                                        selection.push_back(offset + current);
                                    }
                                    else
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        error = true;

                                        message = "You cannot drop this item!";

                                        start_ticks = SDL_GetTicks();
                                    }
                                }
                                else
                                {
                                    selection.push_back(offset + current);
                                }
                            }
                        }
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    if (selection.size() >= LoseLimit)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        auto items = std::vector<Equipment::Type>();

                        for (auto i = 0; i < selection.size(); i++)
                        {
                            items.push_back(equipment[selection[i]].Type);
                        }

                        if (character != Character::Type::NONE)
                        {
                            Engine::LOSE_EQUIPMENT(party, team, items);
                        }
                        else
                        {
                            auto find_character = Engine::FIND_CHARACTER(party, character);

                            if (Engine::IS_ACTIVE(party, find_character))
                            {
                                Engine::LOSE_EQUIPMENT(party.Members[find_character], items);
                            }
                        }

                        done = true;

                        current = -1;

                        selected = false;

                        Sound::Play(Sound::Type::FAIL);
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        error = true;

                        message = "You must lose up to the required number of items!";

                        start_ticks = SDL_GetTicks();
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = false;
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        TTF_Quit();
    }

    return done;
}

std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Engine::ShipPrices> &ships, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (ships.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto ship = std::get<0>(ships[index]);

            auto buy = std::get<1>(ships[index]);

            auto sell = std::get<2>(ships[index]);

            std::string ship_string = "[" + ship.Name + "] Fighting: " + std::to_string(ship.Fighting) + ", Health: " + std::to_string(ship.Health) + ", Cargo: " + std::to_string(ship.MaximumCargo) + " unit(s)";

            ship_string += "\nPrice: " + std::string(buy > 0 ? std::to_string(buy) + " silver coins" : "Not available") + ", Sell: " + std::string(sell > 0 ? std::to_string(sell) + " silver coins" : "--");

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, ship_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (ships.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (ships.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "BUY/SELL SHIPS", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, ships.size() > 0 ? (last - start) - 1 : idx, idx, startx, text_buttony, Control::Type::BUY_SELL_SHIP));
    controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "REPAIR SHIP", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, ships.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::REPAIR_SHIP));
    controls.push_back(Button(idx + 2, createHeaderButton(window, FONT_DARK11, 22, "BUY/SELL CARGO", clrWH, intDB, text_buttonw, 48, -1), idx + 1, idx + 3, ships.size() > 0 ? (last - start) - 1 : idx + 2, idx + 2, startx + 2 * text_gridsize, text_buttony, Control::Type::BUY_SELL_CARGO));
    controls.push_back(Button(idx + 3, createHeaderButton(window, FONT_DARK11, 22, "BACK", clrWH, intDB, text_buttonw, 48, -1), idx + 2, idx + 3, ships.size() > 0 ? (last - start) - 1 : idx + 3, idx + 3, startx + 3 * text_gridsize, text_buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, std::vector<Engine::ShipPrices> &shop, int start, int last, int limit, int offsetx, int offsety, bool buy_button, bool sell_button)
{
    auto controls = std::vector<Button>();

    if (ships.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto ship = ships[index];

            auto sell = Engine::PRICE_SELL(shop, ship.Type);

            std::string ship_string = "[" + ship.Name + "] Fighting: " + std::to_string(ship.Fighting) + ", Health: " + std::to_string(ship.Health) + ", Cargo: " + std::to_string(ship.MaximumCargo) + " unit(s)";

            ship_string += "\nSell: " + std::string(sell > 0 ? std::to_string(sell) + " silver coins" : "--");

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, ship_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (ships.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (ships.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    if (buy_button)
    {
        controls.push_back(Button(idx, "icons/shop.png", idx, idx + 1, (ships.size() > 0 ? ((last - start) - 1) : idx), idx, textx, buttony, Control::Type::BUY_SHIP));

        idx += 1;
    }

    if (sell_button)
    {
        controls.push_back(Button(idx, "icons/selling.png", buy_button ? idx - 1 : idx, idx + 1, (ships.size() > 0 ? ((last - start) - 1) : idx), idx, (buy_button ? (textx + gridsize) : textx), buttony, Control::Type::SELL_SHIP));

        idx += 1;
    }

    auto grid_offset = 0;

    if (buy_button && sell_button)
    {
        grid_offset = 2;
    }
    else if (buy_button || sell_button)
    {
        grid_offset = 1;
    }

    controls.push_back(Button(idx, "icons/user.png", ((buy_button || sell_button) ? idx - 1 : idx), idx + 1, (ships.size() > 0 ? (last - start) - 1 : idx), idx, textx + grid_offset * gridsize, buttony, Control::Type::PARTY));
    controls.push_back(Button(idx + 1, "icons/back-button.png", idx, idx + 1, (ships.size() > 0 ? ((last - start) - 1) : idx + 1), idx + 1, lastx, buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> shipList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Engine::ShipPrices> &ships, int start, int last, int limit, int offsetx, int offsety, bool buy_button, bool sell_button)
{
    auto controls = std::vector<Button>();

    if (ships.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto ship = std::get<0>(ships[index]);

            auto buy = std::get<1>(ships[index]);

            auto sell = std::get<2>(ships[index]);

            std::string ship_string = "[" + ship.Name + "] Fighting: " + std::to_string(ship.Fighting) + ", Health: " + std::to_string(ship.Health) + ", Cargo: " + std::to_string(ship.MaximumCargo) + " unit(s)";

            ship_string += "\nPrice: " + std::string(buy > 0 ? std::to_string(buy) + " silver coins" : "Not available") + ", Sell: " + std::string(sell > 0 ? std::to_string(sell) + " silver coins" : "--");

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, ship_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (ships.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (ships.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    if (buy_button)
    {
        controls.push_back(Button(idx, "icons/shop.png", idx, idx + 1, (ships.size() > 0 ? ((last - start) - 1) : idx), idx, textx, buttony, Control::Type::BUY_SHIP));

        idx += 1;
    }

    if (sell_button)
    {
        controls.push_back(Button(idx, "icons/selling.png", buy_button ? idx - 1 : idx, idx + 1, (ships.size() > 0 ? ((last - start) - 1) : idx), idx, (buy_button ? (textx + gridsize) : textx), buttony, Control::Type::SELL_SHIP));

        idx += 1;
    }

    auto grid_offset = 0;

    if (buy_button && sell_button)
    {
        grid_offset = 2;
    }
    else if (buy_button || sell_button)
    {
        grid_offset = 1;
    }

    controls.push_back(Button(idx, "icons/user.png", ((buy_button || sell_button) ? idx - 1 : idx), idx + 1, (ships.size() > 0 ? (last - start) - 1 : idx), idx, textx + grid_offset * gridsize, buttony, Control::Type::PARTY));
    controls.push_back(Button(idx + 1, "icons/back-button.png", idx, idx + 1, (ships.size() > 0 ? ((last - start) - 1) : idx + 1), idx + 1, lastx, buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> cargoList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Engine::CargoPrices> &cargo, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (cargo.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto cargo_unit = std::get<0>(cargo[index]);

            auto buy = std::get<1>(cargo[index]);

            auto sell = std::get<2>(cargo[index]);

            std::string cargo_string = Cargo::Description[cargo_unit];

            cargo_string += "\nPrice: " + std::string(buy > 0 ? std::to_string(buy) + " silver coins" : "Not available") + " Sell: " + std::string(sell > 0 ? std::to_string(sell) + " silver coins" : "--");

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, cargo_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (cargo.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (cargo.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "BUY/SELL SHIPS", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, cargo.size() > 0 ? (last - start) - 1 : idx, idx, startx, text_buttony, Control::Type::BUY_SELL_SHIP));
    controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "REPAIR SHIP", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, cargo.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::REPAIR_SHIP));
    controls.push_back(Button(idx + 2, createHeaderButton(window, FONT_DARK11, 22, "BUY/SELL CARGO", clrWH, intDB, text_buttonw, 48, -1), idx + 1, idx + 3, cargo.size() > 0 ? (last - start) - 1 : idx + 2, idx + 2, startx + 2 * text_gridsize, text_buttony, Control::Type::BUY_SELL_CARGO));
    controls.push_back(Button(idx + 3, createHeaderButton(window, FONT_DARK11, 22, "BACK", clrWH, intDB, text_buttonw, 48, -1), idx + 2, idx + 3, cargo.size() > 0 ? (last - start) - 1 : idx + 3, idx + 3, startx + 3 * text_gridsize, text_buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> buyCargo(SDL_Window *window, SDL_Renderer *renderer, std::vector<Engine::CargoPrices> &cargo, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (cargo.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto cargo_unit = std::get<0>(cargo[index]);

            auto buy = std::get<1>(cargo[index]);

            auto sell = std::get<2>(cargo[index]);

            std::string cargo_string = Cargo::Description[cargo_unit];

            cargo_string += "\nPrice: " + std::string(buy > 0 ? std::to_string(buy) + " silver coins" : "Not available") + " Sell: " + std::string(sell > 0 ? std::to_string(sell) + " silver coins" : "--");

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, cargo_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (cargo.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (cargo.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/selling.png", idx, idx + 1, (cargo.size() > 0 ? (last - start) - 1 : idx), idx, textx, buttony, Control::Type::SELL_CARGO));
    controls.push_back(Button(idx + 1, "icons/shop.png", idx, idx + 2, (cargo.size() > 0 ? (last - start) - 1 : idx + 1), idx + 1, textx + gridsize, buttony, Control::Type::BUY_CARGO));
    controls.push_back(Button(idx + 2, "icons/user.png", idx + 1, idx + 3, (cargo.size() > 0 ? (last - start) - 1 : idx + 2), idx + 2, textx + 2 * gridsize, buttony, Control::Type::PARTY));
    controls.push_back(Button(idx + 3, "icons/back-button.png", idx + 2, idx + 3, (cargo.size() > 0 ? (last - start) - 1 : idx + 3), idx + 3, lastx, buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> cargoList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &ships, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (ships.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            std::string cargo_string = shipString(ships[index], true);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, cargo_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (ships.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (ships.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/selling.png", idx, idx + 1, (ships.size() > 0 ? (last - start) - 1 : idx), idx, textx, buttony, Control::Type::SELL_CARGO));
    controls.push_back(Button(idx + 1, "icons/shop.png", idx, idx + 2, (ships.size() > 0 ? (last - start) - 1 : idx + 1), idx + 1, textx + gridsize, buttony, Control::Type::BUY_CARGO));
    controls.push_back(Button(idx + 2, "icons/user.png", idx + 1, idx + 3, (ships.size() > 0 ? (last - start) - 1 : idx + 2), idx + 2, textx + 2 * gridsize, buttony, Control::Type::PARTY));
    controls.push_back(Button(idx + 3, "icons/back-button.png", idx + 2, idx + 3, (ships.size() > 0 ? (last - start) - 1 : idx + 3), idx + 3, lastx, buttony, Control::Type::BACK));

    return controls;
}

std::vector<Button> harbourControls(SDL_Window *window, SDL_Renderer *renderer)
{
    auto controls = std::vector<Button>();

    auto idx = 0;

    controls.push_back(Button(idx, createHeaderButton(window, FONT_DARK11, 22, "BUY/SELL SHIPS", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 1, idx, idx, startx, text_buttony, Control::Type::BUY_SELL_SHIP));
    controls.push_back(Button(idx + 1, createHeaderButton(window, FONT_DARK11, 22, "REPAIR SHIP", clrWH, intDB, text_buttonw, 48, -1), idx, idx + 2, idx + 1, idx + 1, startx + text_gridsize, text_buttony, Control::Type::REPAIR_SHIP));
    controls.push_back(Button(idx + 2, createHeaderButton(window, FONT_DARK11, 22, "BUY/SELL CARGO", clrWH, intDB, text_buttonw, 48, -1), idx + 1, idx + 3, idx + 2, idx + 2, startx + 2 * text_gridsize, text_buttony, Control::Type::BUY_SELL_CARGO));
    controls.push_back(Button(idx + 3, createHeaderButton(window, FONT_DARK11, 22, "BACK", clrWH, intDB, text_buttonw, 48, -1), idx + 2, idx + 3, idx + 3, idx + 3, startx + 3 * text_gridsize, text_buttony, Control::Type::BACK));

    return controls;
}

bool cargoScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Story::Base *harbour)
{
    TTF_Init();

    auto font_mason = TTF_OpenFont(FONT_MASON, 24);
    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
    auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

    TTF_SetFontKerning(font_dark11, 0);

    if (window && renderer)
    {
        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(harbour->BookID);

        SDL_SetWindowTitle(window, "Legendary Kingdoms: Buy/Sell Cargo");

        auto current = 0;

        auto selected = false;

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (124);
        auto last = offset + limit;

        if (last > party.Fleet.size())
        {
            last = party.Fleet.size();
        }

        auto controls = cargoList(window, renderer, party.Fleet, offset, last, limit, textx, (texty + infoh));

        auto current_mode = Control::Type::SELL_CARGO;

        auto hold = false;
        auto done = false;
        auto scrollUp = false;
        auto scrollDown = false;
        auto scrollSpeed = 1;
        auto selected_ship = -1;
        auto selected_cargo = std::vector<int>();

        while (!done)
        {
            fillWindow(renderer, intWH);

            putHeader(renderer, "Harbour", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty);

            putText(renderer, Location::Description[party.Location], font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + infoh);

            putHeader(renderer, "Money", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space - 1));
            putText(renderer, (std::to_string(party.Money) + std::string(" silver coins")).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + text_bounds - (3 * boxh + infoh + box_space));

            putHeader(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (current_mode == Control::Type::SELL_CARGO)
            {
                if (selected_ship >= 0 && selected_ship < party.Fleet.size())
                {
                    putText(renderer, party.Fleet[selected_ship].Name.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
                }
            }
            else if (current_mode == Control::Type::BUY_CARGO)
            {
                if (selected_cargo.size() > 0)
                {
                    std::string cargo_string = "";

                    for (auto i = 0; i < selected_cargo.size(); i++)
                    {
                        auto cargo = std::get<0>(harbour->Cargo[selected_cargo[i]]);

                        if (i > 0)
                        {
                            cargo_string += ", ";
                        }

                        cargo_string += Cargo::Description[cargo];
                    }

                    putText(renderer, cargo_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
                }
            }
            else
            {
                fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
            }

            if (current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::SELL_CARGO)
                {
                    if (current_mode != Control::Type::SELL_CARGO)
                    {
                        offset = 0;

                        last = offset + limit;

                        if (last > party.Fleet.size())
                        {
                            last = party.Fleet.size();
                        }

                        controls = cargoList(window, renderer, party.Fleet, offset, last, limit, textx, (texty + infoh));

                        for (auto i = 0; i < controls.size(); i++)
                        {
                            if (controls[i].Type == Control::Type::SELL_CARGO)
                            {
                                current = i;

                                break;
                            }
                        }
                    }

                    current_mode = Control::Type::SELL_CARGO;
                }
                else if (controls[current].Type == Control::Type::BUY_CARGO)
                {
                    if (current_mode != Control::Type::BUY_CARGO)
                    {
                        offset = 0;

                        last = offset + limit;

                        if (last > harbour->Cargo.size())
                        {
                            last = harbour->Cargo.size();
                        }

                        controls = buyCargo(window, renderer, harbour->Cargo, offset, last, limit, textx, texty + infoh);

                        for (auto i = 0; i < controls.size(); i++)
                        {
                            if (controls[i].Type == Control::Type::BUY_CARGO)
                            {
                                current = i;

                                break;
                            }
                        }
                    }

                    current_mode = Control::Type::BUY_CARGO;
                }
            }

            if (current_mode == Control::Type::SELL_CARGO)
            {
                putHeader(renderer, "Your Fleet", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

                fillRect(renderer, textwidth, (text_bounds - infoh), textx, (texty + infoh), intBE);

                if (party.Fleet.size() == 0)
                {
                    putText(renderer, "\nYou do not have any ships", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, textwidth, text_bounds - infoh, textx, texty + infoh);
                }
            }
            else if (current_mode == Control::Type::BUY_CARGO)
            {
                putHeader(renderer, "Cargo Prices", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

                fillRect(renderer, textwidth, (text_bounds - infoh), textx, (texty + infoh), intBE);

                if (harbour->Cargo.size() == 0)
                {
                    putText(renderer, "You cannot buy nor sell any goods here", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, textwidth, text_bounds - infoh, textx, texty + infoh);
                }
            }
            else
            {
                fillRect(renderer, textwidth, infoh, textx, texty, fg);

                fillRect(renderer, textwidth, (text_bounds - infoh), textx, (texty + infoh), intBE);
            }

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if ((current_mode == Control::Type::BUY_CARGO && (Engine::FIND_LIST(selected_cargo, offset + i) >= 0)) || (current_mode == Control::Type::SELL_CARGO && selected_ship == (offset + i)))
                    {
                        thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, border_space, border_pts);

            if (current >= 0 && current < controls.size())
            {
                renderCaption(renderer, font_caption, controls[current]);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (current_mode == Control::Type::SELL_CARGO)
                        {
                            if (last > party.Fleet.size())
                            {
                                last = party.Fleet.size();
                            }

                            controls = cargoList(window, renderer, party.Fleet, offset, last, limit, textx, texty + infoh);
                        }
                        else if (current_mode == Control::Type::BUY_CARGO)
                        {
                            if (last > harbour->Cargo.size())
                            {
                                last = harbour->Cargo.size();
                            }

                            controls = buyCargo(window, renderer, harbour->Cargo, offset, last, limit, textx, texty + infoh);
                        }

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (current_mode == Control::Type::SELL_CARGO)
                    {
                        if (party.Fleet.size() - last > 0)
                        {
                            if (offset < party.Fleet.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > party.Fleet.size() - limit)
                            {
                                offset = party.Fleet.size() - limit;
                            }

                            last = offset + limit;

                            if (last > party.Fleet.size())
                            {
                                last = party.Fleet.size();
                            }

                            controls = cargoList(window, renderer, party.Fleet, offset, last, limit, textx, texty + infoh);

                            SDL_Delay(50);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (party.Fleet.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }
                    else if (current_mode == Control::Type::BUY_CARGO)
                    {
                        if (harbour->Cargo.size() - last > 0)
                        {
                            if (offset < harbour->Cargo.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > harbour->Cargo.size() - limit)
                            {
                                offset = harbour->Cargo.size() - limit;
                            }

                            last = offset + limit;

                            if (last > harbour->Cargo.size())
                            {
                                last = harbour->Cargo.size();
                            }

                            controls = buyCargo(window, renderer, harbour->Cargo, offset, last, limit, textx, texty + infoh);

                            SDL_Delay(50);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (harbour->Cargo.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }

                    SDL_Delay(50);

                    if (offset > 0)
                    {
                        current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current_mode == Control::Type::SELL_CARGO)
                    {
                        if ((offset + current) >= 0 && (offset + current) < party.Fleet.size())
                        {
                            if (Engine::HAS_SHIP(party, harbour->Location))
                            {
                                if (selected_ship == offset + current)
                                {
                                    selected_ship = -1;
                                }
                                else if (party.Fleet[offset + current].Location != harbour->Location)
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage("The [" + party.Fleet[offset + current].Name + "] is not docked at this harbour!", intRD);
                                }
                                else if (party.Fleet[offset + current].Cargo.size() <= 0)
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage("The [" + party.Fleet[offset + current].Name + "] is not carrying any cargo!", intRD);
                                }
                                else if (party.Fleet[offset + current].Health > 0 && party.Fleet[offset + current].Cargo.size() > 0)
                                {
                                    selected_ship = offset + current;
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("You do not have a ship docked at this harbour!", intRD);
                            }
                        }

                        selected = false;
                    }
                    else if (current_mode == Control::Type::BUY_CARGO)
                    {
                        if (Engine::HAS_SHIP(party, harbour->Location))
                        {
                            auto found_cargo = Engine::FIND_LIST(selected_cargo, offset + current);

                            if (found_cargo >= 0 && found_cargo < selected_cargo.size())
                            {
                                selected_cargo.erase(selected_cargo.begin() + found_cargo);
                            }
                            else if ((offset + current) >= 0 && (offset + current) < harbour->Cargo.size())
                            {
                                auto cargo = std::get<0>(harbour->Cargo[offset + current]);

                                auto price = std::get<1>(harbour->Cargo[offset + current]);

                                if (price >= 0)
                                {
                                    selected_cargo.push_back(offset + current);
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::ERROR);

                                    displayMessage(std::string(Cargo::Description[cargo]) + " not available at this harbour!", intRD);
                                }
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have a ship docked at this harbour!", intRD);
                        }
                    }
                }
                else if (controls[current].Type == Control::Type::SELL_CARGO && !hold)
                {
                    if (selected_ship >= 0 && selected_ship < party.Fleet.size())
                    {
                        if (party.Fleet[selected_ship].Cargo.size() > 0)
                        {
                            auto sold = 0;
                            auto unsold = 0;

                            std::string sold_string = "";
                            std::string unsold_string = "";

                            auto revenue = 0;

                            auto cargo = std::vector<Cargo::Type>();

                            for (auto i = 0; i < party.Fleet[selected_ship].Cargo.size(); i++)
                            {
                                cargo.push_back(party.Fleet[selected_ship].Cargo[i]);
                            }

                            for (auto i = 0; i < cargo.size(); i++)
                            {
                                auto price = Engine::PRICE_SELL(harbour->Cargo, cargo[i]);

                                if (price >= 0)
                                {
                                    if (sold > 0)
                                    {
                                        sold_string += ", ";
                                    }

                                    sold_string += std::string(Cargo::Description[cargo[i]]);

                                    revenue += price;

                                    sold += 1;

                                    Engine::LOSE_CARGO(party.Fleet[selected_ship], cargo[i]);
                                }
                                else
                                {
                                    if (unsold > 0)
                                    {
                                        unsold_string += ", ";
                                    }

                                    unsold_string += std::string(Cargo::Description[cargo[i]]);

                                    unsold += 1;
                                }
                            }

                            if (sold > unsold)
                            {
                                Sound::Play(Sound::Type::SUCCESS);

                                flash_color = intLB;
                            }
                            else
                            {
                                Sound::Play(Sound::Type::FAIL);

                                flash_color = intRD;
                            }

                            message = "";

                            if (sold > 0)
                            {
                                message = "Cargo sold: " + sold_string;
                            }

                            if (unsold > 0)
                            {
                                if (sold > 0)
                                {
                                    message += "\n";
                                }

                                message += "Unsold cargo: " + unsold_string;
                            }

                            message += "\nRevenue: " + std::to_string(revenue) + " silver coins";

                            Engine::GAIN_MONEY(party, revenue);

                            displayMessage(message, flash_color);

                            controls = cargoList(window, renderer, party.Fleet, offset, last, limit, textx, (texty + infoh));
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("The [" + party.Fleet[selected_ship].Name + "] is not carrying any cargo!", intRD);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("Please select the ship containing the cargo you want to sell", intRD);
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::BUY_CARGO && !hold)
                {
                    if (selected_cargo.size() > 0)
                    {
                        if (party.Fleet.size() <= 0)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have any ships!", intRD);
                        }
                        else if (Engine::HAS_SHIP(party, harbour->Location, selected_cargo.size()))
                        {
                            auto price = 0;

                            auto cargo = std::vector<Cargo::Type>();

                            for (auto i = 0; i < selected_cargo.size(); i++)
                            {
                                auto goods = std::get<0>(harbour->Cargo[selected_cargo[i]]);

                                price += Engine::PRICE_BUY(harbour->Cargo, goods);

                                cargo.push_back(goods);
                            }

                            if (party.Money >= price)
                            {
                                auto ship = -1;

                                if (Engine::COUNT(party, harbour->Location, cargo.size()) > 1)
                                {
                                    ship = selectShip(window, renderer, party.Book, party.Fleet, harbour->Location, cargo, Control::Type::CARGO);
                                }
                                else
                                {
                                    ship = Engine::FIND_SHIP(party, harbour->Location, cargo.size());
                                }

                                if (ship >= 0 && ship < party.Fleet.size())
                                {
                                    party.Fleet[ship].Cargo.insert(party.Fleet[ship].Cargo.end(), cargo.begin(), cargo.end());

                                    Engine::GAIN_MONEY(party, -price);

                                    std::string delivery_message = "";

                                    for (auto i = 0; i < cargo.size(); i++)
                                    {
                                        if (i > 0)
                                        {
                                            delivery_message += ", ";
                                        }

                                        delivery_message += std::string(Cargo::Description[cargo[i]]);
                                    }

                                    Sound::Play(Sound::Type::SUCCESS);

                                    displayMessage(delivery_message + " delivered aboard the [" + party.Fleet[ship].Name + "]!", intLB);
                                }
                            }
                            else
                            {
                                Sound::Play(Sound::Type::ERROR);

                                displayMessage("You do not have enough silver coins!", intRD);
                            }
                        }
                        else if (Engine::HAS_SHIP(party, harbour->Location))
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have enough space in your ships!", intRD);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have a ship docked at this harbour!", intRD);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("Please select the cargo you wish to buy", intRD);
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::BACK)
                {
                    done = true;
                }
            }
        }
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    if (font_caption)
    {
        TTF_CloseFont(font_caption);

        font_caption = NULL;
    }

    TTF_Quit();

    return false;
}

bool harbourScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Story::Base *harbour)
{
    TTF_Init();

    auto font_mason = TTF_OpenFont(FONT_MASON, 24);
    auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
    auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

    TTF_SetFontKerning(font_dark11, 0);

    if (window && renderer)
    {
        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        SDL_SetWindowTitle(window, "Legendary Kingdoms: Harbour");

        auto current = 0;

        auto selected = false;

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (124);
        auto last = offset + limit;

        if (last > harbour->Ships.size())
        {
            last = harbour->Ships.size();
        }

        auto controls = shipList(window, renderer, harbour->Ships, offset, last, limit, textx, (texty + infoh));

        auto current_mode = Control::Type::BUY_SELL_SHIP;

        auto scrollUp = false;
        auto scrollDown = false;
        auto scrollSpeed = 1;
        auto hold = false;

        auto done = false;

        while (!done)
        {
            fillWindow(renderer, intWH);

            putHeader(renderer, "Location", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty);
            putText(renderer, Location::Description[party.Location], font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + infoh);

            putHeader(renderer, "Money", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space - 1));
            putText(renderer, (std::to_string(party.Money) + std::string(" silver coins")).c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + text_bounds - (3 * boxh + infoh + box_space));

            putHeader(renderer, "Party", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

            if (Engine::COUNT(party) > 0)
            {
                std::string party_string = "";

                auto count = 0;

                for (auto i = 0; i < party.Members.size(); i++)
                {
                    if (count > 0)
                    {
                        party_string += "\n";
                    }

                    party_string += party.Members[i].Name;

                    if (Engine::IS_DEAD(party.Members[i]))
                    {
                        party_string += " (D)";
                    }
                    else if (Engine::IS_CURSED(party.Members[i]))
                    {
                        party_string += " (C)";
                    }

                    count += 1;
                }

                putText(renderer, party_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            if (current >= 0 && current < controls.size())
            {
                if (controls[current].Type == Control::Type::BUY_SELL_SHIP)
                {
                    if (current_mode != Control::Type::BUY_SELL_SHIP)
                    {
                        offset = 0;

                        last = offset + limit;

                        if (last > harbour->Ships.size())
                        {
                            last = harbour->Ships.size();
                        }

                        controls = shipList(window, renderer, harbour->Ships, offset, last, limit, textx, texty + infoh);

                        current = FIND_CONTROL(controls, Control::Type::BUY_SELL_SHIP);
                    }

                    current_mode = Control::Type::BUY_SELL_SHIP;
                }
                else if (controls[current].Type == Control::Type::REPAIR_SHIP)
                {
                    if (current_mode != Control::Type::REPAIR_SHIP)
                    {
                        offset = 0;

                        last = 0;

                        controls = harbourControls(window, renderer);

                        current = FIND_CONTROL(controls, Control::Type::REPAIR_SHIP);
                    }

                    current_mode = Control::Type::REPAIR_SHIP;
                }
                else if (controls[current].Type == Control::Type::BUY_SELL_CARGO)
                {
                    if (current_mode != Control::Type::BUY_SELL_CARGO)
                    {
                        offset = 0;

                        last = offset + limit;

                        if (last > harbour->Cargo.size())
                        {
                            last = harbour->Cargo.size();
                        }

                        controls = cargoList(window, renderer, harbour->Cargo, offset, last, limit, textx, texty + infoh);

                        current = FIND_CONTROL(controls, Control::Type::BUY_SELL_CARGO);
                    }

                    current_mode = Control::Type::BUY_SELL_CARGO;
                }
            }

            if (current_mode == Control::Type::BUY_SELL_SHIP)
            {
                putHeader(renderer, "Ship Prices", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

                fillRect(renderer, textwidth, (text_bounds - infoh), textx, (texty + infoh), intBE);

                if (harbour->Ships.size() == 0)
                {
                    putText(renderer, "\nYou cannot buy nor sell ships here.", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, textwidth, text_bounds - infoh, textx, texty + infoh);
                }
            }
            else if (current_mode == Control::Type::REPAIR_SHIP)
            {
                putHeader(renderer, "Repair Costs", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

                fillRect(renderer, textwidth, (text_bounds - infoh), textx, (texty + infoh), intBE);

                if (harbour->ShipRepairPrice >= 0)
                {
                    std::string repair_string = "\n";

                    if (harbour->ShipRepairPrice == 0)
                    {
                        repair_string = "\nYou can repair any ship you have here. It costs nothing to restore each Health point. You can restore your ship up to its starting Health value.";
                    }
                    else
                    {
                        repair_string = "\nYou can repair any ship you have here. It costs " + std::to_string(harbour->ShipRepairPrice) + " silver coins to restore each Health point. You can restore your ship up to its starting Health value.";
                    }

                    putText(renderer, repair_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, textwidth, text_bounds - infoh, textx, texty + infoh);
                }
                else
                {
                    putText(renderer, "\nShip repair services are not available here.", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, textwidth, text_bounds - infoh, textx, texty + infoh);
                }
            }
            else if (current_mode == Control::Type::BUY_SELL_CARGO)
            {
                putHeader(renderer, "Cargo Prices", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

                fillRect(renderer, textwidth, (text_bounds - infoh), textx, (texty + infoh), intBE);

                if (harbour->Cargo.size() == 0)
                {
                    putText(renderer, "\nYou cannot buy nor sell cargo here.", font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, textwidth, text_bounds - infoh, textx, texty + infoh);
                }
            }
            else
            {
                fillRect(renderer, textwidth, infoh, textx, texty, fg);
            }

            for (auto i = offset; i < last; i++)
            {
                auto index = i - offset;

                if (current != index)
                {
                    if (index >= 0 && index < controls.size())
                    {
                        drawRect(renderer, controls[index].W + (2 * text_space), controls[index].H + (2 * text_space), controls[index].X - text_space, controls[index].Y - text_space, intBK);
                    }
                }
            }

            renderButtons(renderer, controls, current, intLB, border_space, border_pts);

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (current_mode == Control::Type::BUY_SELL_SHIP)
                        {
                            if (last > harbour->Ships.size())
                            {
                                last = harbour->Ships.size();
                            }

                            controls = shipList(window, renderer, harbour->Ships, offset, last, limit, textx, texty + infoh);
                        }
                        else if (current_mode == Control::Type::BUY_SELL_CARGO)
                        {
                            if (last > harbour->Cargo.size())
                            {
                                last = harbour->Cargo.size();
                            }

                            controls = cargoList(window, renderer, harbour->Cargo, offset, last, limit, textx, texty + infoh);
                        }

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (current_mode == Control::Type::BUY_SELL_SHIP)
                    {
                        if (harbour->Ships.size() - last > 0)
                        {
                            if (offset < harbour->Ships.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > harbour->Ships.size() - limit)
                            {
                                offset = harbour->Ships.size() - limit;
                            }

                            last = offset + limit;

                            if (last > harbour->Ships.size())
                            {
                                last = harbour->Ships.size();
                            }

                            controls = shipList(window, renderer, harbour->Ships, offset, last, limit, textx, texty + infoh);

                            SDL_Delay(50);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (harbour->Ships.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }
                    else if (current_mode == Control::Type::BUY_SELL_CARGO)
                    {
                        if (harbour->Cargo.size() - last > 0)
                        {
                            if (offset < harbour->Cargo.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > harbour->Cargo.size() - limit)
                            {
                                offset = harbour->Cargo.size() - limit;
                            }

                            last = offset + limit;

                            if (last > harbour->Cargo.size())
                            {
                                last = harbour->Cargo.size();
                            }

                            controls = cargoList(window, renderer, harbour->Cargo, offset, last, limit, textx, texty + infoh);

                            SDL_Delay(50);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (harbour->Cargo.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }

                    SDL_Delay(50);

                    if (offset > 0)
                    {
                        current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                    }
                }
                else if (controls[current].Type == Control::Type::BUY_SELL_SHIP && !hold)
                {
                    if (harbour->Ships.size() > 0)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        shipScreen(window, renderer, party, Team::Type::NONE, harbour->Ships, harbour);
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("Ships cannot be sold nor bought at this harbour!", intRD);
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::BUY_SELL_CARGO && !hold)
                {
                    if (Engine::HAS_SHIP(party, harbour->Location))
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        cargoScreen(window, renderer, party, harbour);
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("You do not have a ship docked at " + std::string(Location::Description[harbour->Location]) + "!", intRD);
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::REPAIR_SHIP && !hold)
                {
                    if (harbour->ShipRepairPrice >= 0)
                    {
                        if (Engine::HAS_SHIP(party, harbour->Location))
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            repairScreen(window, renderer, party, harbour);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have a ship docked at " + std::string(Location::Description[harbour->Location]) + "!", intRD);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("It is not possible to repair ships at this harbour!", intRD);
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::BACK)
                {
                    done = true;
                }
            }
        }
    }

    if (font_mason)
    {
        TTF_CloseFont(font_mason);

        font_mason = NULL;
    }

    if (font_dark11)
    {
        TTF_CloseFont(font_dark11);

        font_dark11 = NULL;
    }

    if (font_garamond)
    {
        TTF_CloseFont(font_garamond);

        font_garamond = NULL;
    }

    TTF_Quit();

    return false;
}

void renderArmy(SDL_Renderer *renderer, TTF_Font *font, std::vector<Army::Base> &army, int boxw, int army_boxh, int offsety, SDL_Color fg, Uint32 bg)
{
    if (army.size() > 0)
    {
        std::string left_front = "";
        std::string left_support = "";

        std::string center_front = "";
        std::string center_support = "";

        std::string right_front = "";
        std::string right_support = "";

        for (auto i = 0; i < army.size(); i++)
        {
            if (army[i].Position == Location::BattleField::LEFT_FLANK_FRONT || army[i].Position == Location::BattleField::CENTER_FRONT || army[i].Position == Location::BattleField::RIGHT_FLANK_FRONT)
            {
                if (army[i].Position == Location::BattleField::LEFT_FLANK_FRONT)
                {
                    left_front = "[" + army[i].Name + "]\nStrength: " + std::to_string(army[i].Strength) + " Morale: " + std::to_string(army[i].Morale);
                }
                else if (army[i].Position == Location::BattleField::CENTER_FRONT)
                {
                    center_front = "[" + army[i].Name + "]\nStrength: " + std::to_string(army[i].Strength) + " Morale: " + std::to_string(army[i].Morale);
                }
                else if (army[i].Position == Location::BattleField::RIGHT_FLANK_FRONT)
                {
                    right_front = "[" + army[i].Name + "]\nStrength: " + std::to_string(army[i].Strength) + " Morale: " + std::to_string(army[i].Morale);
                }
            }
            else if (army[i].Position == Location::BattleField::LEFT_FLANK_SUPPORT || army[i].Position == Location::BattleField::CENTER_SUPPORT || army[i].Position == Location::BattleField::RIGHT_FLANK_SUPPORT)
            {
                if (army[i].Position == Location::BattleField::LEFT_FLANK_SUPPORT)
                {
                    left_support = "\n\nSupport:\n[" + army[i].Name + "]\nStrength: " + std::to_string(army[i].Strength) + " Morale: " + std::to_string(army[i].Morale);
                }
                else if (army[i].Position == Location::BattleField::CENTER_SUPPORT)
                {
                    center_support = "\n\nSupport:\n[" + army[i].Name + "]\nStrength: " + std::to_string(army[i].Strength) + " Morale: " + std::to_string(army[i].Morale);
                }
                else if (army[i].Position == Location::BattleField::RIGHT_FLANK_SUPPORT)
                {
                    right_support = "\n\nSupport:\n[" + army[i].Name + "]\nStrength: " + std::to_string(army[i].Strength) + " Morale: " + std::to_string(army[i].Morale);
                }
            }
        }

        auto left_flank = left_front + left_support;
        auto center = center_front + center_support;
        auto right_flank = right_front + right_support;

        if (left_flank.length() > 0)
        {
            putText(renderer, left_flank.c_str(), font, text_space, fg, bg, TTF_STYLE_NORMAL, boxw - 2 * text_space, army_boxh - 4 * text_space, startx + text_space, offsety + 2 * text_space);
        }

        if (center.length() > 0)
        {
            putText(renderer, center.c_str(), font, text_space, fg, bg, TTF_STYLE_NORMAL, boxw - 2 * text_space, army_boxh - 4 * text_space, startx + (boxw + box_space) + text_space, offsety + 2 * text_space);
        }

        if (right_flank.length() > 0)
        {
            putText(renderer, right_flank.c_str(), font, text_space, fg, bg, TTF_STYLE_NORMAL, boxw - 2 * text_space, army_boxh - 4 * text_space, startx + 2 * (boxw + box_space) + text_space, offsety + 2 * text_space);
        }
    }
}

std::vector<Button> popupConfirm(int popupw, int popuph, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    controls.push_back(Button(0, "icons/yes.png", 0, 1, 0, 0, offsetx + button_space, offsety + popuph - button_space - buttonh, Control::Type::CONFIRM));
    controls.push_back(Button(1, "icons/no.png", 0, 1, 1, 1, offsetx + popupw - buttonw - button_space, offsety + popuph - button_space - buttonh, Control::Type::BACK));

    return controls;
}

template <typename T>
void popupScrolls(std::vector<Button> &controls, std::vector<T> &list, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety, bool back_button)
{
    auto idx = (int)controls.size();

    if (list.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, offsetx + (popupw - arrow_size - button_space), offsety + infoh + 7 * border_space / 2, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (list.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, offsetx + (popupw - arrow_size - button_space), offsety + (popuph - arrow_size - 2 * border_space - buttonh - infoh), Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/yes.png", idx, back_button ? idx + 1 : idx, list.size() > 0 ? (last - start) - 1 : idx, idx, offsetx + button_space, offsety + popuph - button_space - buttonh, Control::Type::CONFIRM));

    if (back_button)
    {
        controls.push_back(Button(idx + 1, "icons/no.png", idx, idx + 1, list.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, offsetx + popupw - buttonw - button_space, offsety + popuph - button_space - buttonh, Control::Type::BACK));
    }
}

std::vector<Button> popupMoney(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, int popupw, int popuph, int infoh, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    controls.push_back(Button(0, createHeaderButton(window, FONT_GARAMOND, 24, (std::string("Vault Money: " + std::to_string(party.VaultMoney) + " silver coins")).c_str(), clrBK, intBE, popupw - 3 * button_space / 2 - button_space - arrow_size - border_space, list_buttonh, text_space), 0, 0, 0, 0, offsetx + 2 * text_space, offsety + infoh + 3 * text_space, Control::Type::ACTION));
    controls[0].W = controls[0].Surface->w;
    controls[0].H = controls[0].Surface->h;

    controls.push_back(Button(1, createHeaderButton(window, FONT_GARAMOND, 24, (std::string("Party Money: " + std::to_string(party.Money) + " silver coins")).c_str(), clrBK, intBE, popupw - 3 * button_space / 2 - button_space - arrow_size - border_space, list_buttonh, text_space), 1, 1, 1, 1, offsetx + 2 * text_space, controls[0].Y + controls[0].H + 3 * text_space, Control::Type::ACTION));
    controls[1].W = controls[1].Surface->w;
    controls[1].H = controls[1].Surface->h;

    auto idx = (int)controls.size();

    controls.push_back(Button(idx, "icons/yes.png", idx, idx + 1, idx, idx, offsetx + button_space, offsety + popuph - button_space - buttonh, Control::Type::CONFIRM));
    controls.push_back(Button(idx + 1, "icons/add.png", idx, idx + 2, idx + 1, idx + 1, offsetx + button_space + gridsize, offsety + popuph - button_space - buttonh, Control::Type::PLUS));
    controls.push_back(Button(idx + 2, "icons/minus.png", idx + 1, idx + 2, idx + 2, idx + 2, offsetx + button_space + 2 * gridsize, offsety + popuph - button_space - buttonh, Control::Type::MINUS));

    return controls;
}

std::vector<Button> popupList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Army::Base> &list, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety, bool back_button)
{
    auto controls = std::vector<Button>();

    if (list.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto unit = list[index];

            std::string list_string = "[" + unit.Name + "] Strength: " + std::to_string(unit.Strength) + ", Morale: " + std::to_string(unit.Morale);

            list_string += "\nPosition: " + std::string(Location::BattleFieldDescription[unit.Position]) + ", Garrison: " + std::string(Location::Description[unit.Garrison]);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + infoh + 3 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, list_string.c_str(), clrBK, intBE, popupw - 3 * button_space / 2 - button_space - arrow_size - border_space, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    popupScrolls(controls, list, start, last, limit, popupw, popuph, infoh, offsetx, offsety, back_button);

    return controls;
}

std::vector<Button> popupArmy(SDL_Window *window, SDL_Renderer *renderer, std::vector<Army::Base> &army, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety)
{
    return popupList(window, renderer, army, start, last, limit, popupw, popuph, infoh, offsetx, offsety, true);
}

std::vector<Button> popupList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Monster::Base> &list, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (list.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            std::string list_string = monsterString(list[index]);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + infoh + 3 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, list_string.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    popupScrolls(controls, list, start, last, limit, popupw, popuph, infoh, offsetx, offsety, false);

    return controls;
}

std::vector<Button> popupList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Ship::Base> &list, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (list.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto ship = list[index];

            std::string list_string = "[" + ship.Name + "] Fighting: " + std::to_string(ship.Fighting) + ", Health: " + std::to_string(ship.Health);

            if (ship.MaximumCargo > 0)
            {
                list_string += ", Cargo Units: " + std::to_string(ship.MaximumCargo);
            }

            list_string += "\nLocation: " + std::string(Location::Description[ship.Location]);

            if (ship.MaximumCargo > 0 && ship.Cargo.size() > 0)
            {
                list_string += " Cargo: ";

                for (auto j = 0; j < ship.Cargo.size(); j++)
                {
                    if (j > 0)
                    {
                        list_string += ", ";
                    }

                    list_string += Cargo::Description[ship.Cargo[j]];
                }
            }

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + infoh + 3 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, list_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    popupScrolls(controls, list, start, last, limit, popupw, popuph, infoh, offsetx, offsety, false);

    return controls;
}

std::vector<Button> popupList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Location::Type> &list, int start, int last, int limit, int popupw, int popuph, int infoh, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (list.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            std::string list_string = Location::Description[list[index]];

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + infoh + 3 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, list_string.c_str(), clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    popupScrolls(controls, list, start, last, limit, popupw, popuph, infoh, offsetx, offsety, true);

    return controls;
}

bool moraleCheck(SDL_Window *window, SDL_Renderer *renderer, Book::Type book, Army::Base &unit, int combatRound)
{
    auto morale_result = false;

    if (window && renderer)
    {
        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(book);

        auto headerw = (int)(boxwidth * 0.75);

        auto done = false;

        auto stage = Engine::MassCombat::START;

        SDL_SetWindowTitle(window, "Legendary Kingdoms: Morale Check");

        TTF_Init();

        auto font_mason = TTF_OpenFont(FONT_MASON, 32);

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);

        auto font_size = 28;

        const char *choices_morale[1] = {"Check Morale"};
        const char *choices_end[1] = {"Done"};

        SDL_Surface *dice[6];

        dice[0] = createImage("images/dice/dice1.png");
        dice[1] = createImage("images/dice/dice2.png");
        dice[2] = createImage("images/dice/dice3.png");
        dice[3] = createImage("images/dice/dice4.png");
        dice[4] = createImage("images/dice/dice5.png");
        dice[5] = createImage("images/dice/dice6.png");

        auto controls_morale = createFixedTextButtons(choices_morale, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
        controls_morale[0].Type = Control::Type::CONFIRM;

        auto controls_end = createFixedTextButtons(choices_end, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
        controls_end[0].Type = Control::Type::BACK;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        std::vector<int> morale = {};

        auto morale_score = 0;

        auto size_dice = 64;

        auto cols = (fullwidth - 2 * box_space) / (size_dice + box_space);

        auto controls = std::vector<TextButton>();

        auto morale_checked = false;

        auto offsety = starty + infoh + boxh + box_space + infoh + box_space;
        auto offsetx = startx + box_space;

        std::string mass_combat = "Round " + std::to_string(combatRound + 1) + " - Morale Check Results";

        while (!done)
        {
            fillWindow(renderer, intWH);

            putHeader(renderer, mass_combat.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, fullwidth, infoh, startx, starty + infoh + boxh + box_space);

            fillRect(renderer, fullwidth, boxh * 3, startx, starty + infoh + boxh + box_space + infoh, intBE);

            if (stage == Engine::MassCombat::MORALE)
            {
                if (morale.size() == 0)
                {
                    Sound::Play(Sound::Type::DICE_ROLL);

                    morale = Engine::ROLL_DICE(1);
                }

                auto row = 0;
                auto col = 0;

                morale_score = 0;

                for (auto i = 0; i < morale.size(); i++)
                {
                    if (morale[i] >= 1 && morale[i] <= 6)
                    {
                        auto result = morale[i] - 1;

                        morale_score += morale[i];

                        fitImage(renderer, dice[result], offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);

                        if (col < cols)
                        {
                            col += 1;
                        }
                        else
                        {
                            col = 0;

                            row += 1;
                        }
                    }
                }

                if (!morale_checked)
                {
                    Sound::Play(Sound::Type::FAIL);

                    if (morale_score <= unit.Morale)
                    {
                        Engine::GAIN_MORALE(unit, -1);

                        message = "The " + unit.Name + " loses 1 point of Morale!";

                        morale_result = true;
                    }
                    else
                    {
                        message = "The " + unit.Name + " flee!";

                        unit.Position = Location::BattleField::NONE;

                        morale_result = false;
                    }

                    displayMessage(message, intRD);

                    morale_checked = true;
                }
            }

            putHeader(renderer, unit.Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty);

            std::string unit_string = "Strength: " + std::to_string(unit.Strength);
            unit_string += "\nMorale: " + std::to_string(unit.Morale);

            putText(renderer, unit_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx, starty + infoh);

            if (stage == Engine::MassCombat::MORALE)
            {
                std::string morale_string = "Morale Check: " + std::to_string(morale_score);

                putHeader(renderer, morale_string.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx, starty + infoh + 4 * boxh + 2 * box_space + infoh);
            }

            if (stage == Engine::MassCombat::START)
            {
                controls = controls_morale;
            }
            else if (stage == Engine::MassCombat::MORALE)
            {
                controls = controls_end;
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            renderTextButtons(renderer, controls, FONT_DARK11, current, clrWH, intDB, intLB, font_size, TTF_STYLE_NORMAL);

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if (selected && current >= 0 && current < controls.size())
            {
                if (stage == Engine::MassCombat::START && controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (stage == Engine::MassCombat::START && controls[current].Type == Control::Type::CONFIRM)
                {
                    stage = Engine::MassCombat::MORALE;
                }
                else if (stage == Engine::MassCombat::MORALE && controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    stage = Engine::MassCombat::END;

                    done = true;

                    current = -1;

                    selected = false;
                }
            }
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        TTF_Quit();

        for (auto i = 0; i < 6; i++)
        {
            if (dice[i])
            {
                SDL_FreeSurface(dice[i]);

                dice[i] = NULL;
            }
        }
    }

    return morale_result;
}

void resolveMassCombat(SDL_Window *window, SDL_Renderer *renderer, Location::Type location, Party::Base &party, std::vector<Army::Base> &enemyArmy, std::vector<Engine::BattlefieldSpells> &enemySpells, std::vector<Engine::ArmyStatus> &enemyStatus, Location::Zone zone, int combatRound)
{
    if (window && renderer)
    {
        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        auto headerw = (int)(boxwidth * 0.75);

        auto done = false;

        auto stage = Engine::MassCombat::START;

        SDL_SetWindowTitle(window, "Legendary Kingdoms: Resolve Mass Combat");

        TTF_Init();

        auto font_mason = TTF_OpenFont(FONT_MASON, 32);

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);

        auto font_size = 28;

        const char *choices_combat[1] = {"Resolve Combat"};
        const char *choices_morale[1] = {"Check Morale"};
        const char *choices_end[1] = {"Done"};

        SDL_Surface *dice[6];

        dice[0] = createImage("images/dice/dice1.png");
        dice[1] = createImage("images/dice/dice2.png");
        dice[2] = createImage("images/dice/dice3.png");
        dice[3] = createImage("images/dice/dice4.png");
        dice[4] = createImage("images/dice/dice5.png");
        dice[5] = createImage("images/dice/dice6.png");

        auto controls_combat = createFixedTextButtons(choices_combat, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
        controls_combat[0].Type = Control::Type::CONFIRM;

        auto controls_morale = createFixedTextButtons(choices_morale, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
        controls_morale[0].Type = Control::Type::CONFIRM;

        auto controls_end = createFixedTextButtons(choices_end, 1, text_buttonw, text_buttonh, 10, startx, text_buttony);
        controls_end[0].Type = Control::Type::BACK;

        auto current = -1;

        auto selected = false;

        auto scrollUp = false;

        auto scrollDown = false;

        auto hold = false;

        std::vector<int> party_combat_results = {};
        std::vector<int> enemy_combat_results = {};
        std::vector<int> morale = {};

        auto party_combat_score = 0;
        auto enemy_combat_score = 0;
        auto morale_score = 0;

        auto size_dice = 64;

        auto cols = (fullwidth - 2 * box_space) / (size_dice + box_space);

        auto controls = std::vector<TextButton>();

        auto combat_resolved = false;
        auto morale_checked = false;

        auto party_unit = Engine::FIND_UNIT(party.Army, zone);
        auto enemy_unit = Engine::FIND_UNIT(enemyArmy, zone);

        auto offsety = starty + infoh + boxh + box_space + infoh + box_space;
        auto offsetx = startx + box_space;

        std::string mass_combat = "Round " + std::to_string(combatRound + 1) + " - Mass Combat Results: ";

        if (zone == Location::Zone::LEFT_FLANK)
        {
            mass_combat += "Left Flank";
        }
        else if (zone == Location::Zone::CENTER)
        {
            mass_combat += "Center";
        }
        else if (zone == Location::Zone::RIGHT_FLANK)
        {
            mass_combat += "Right Flank";
        }

        while (!done)
        {
            fillWindow(renderer, intWH);

            putHeader(renderer, mass_combat.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, fullwidth, infoh, startx, starty + infoh + boxh + box_space);

            fillRect(renderer, fullwidth, boxh * 3, startx, starty + infoh + boxh + box_space + infoh, intBE);

            if (stage != Engine::MassCombat::START)
            {
                if (stage == Engine::MassCombat::COMBAT)
                {
                    if (party_combat_results.size() == 0 || enemy_combat_results.size() == 0)
                    {
                        Sound::Play(Sound::Type::DICE_ROLL);
                    }

                    if (party_combat_results.size() == 0)
                    {
                        party_combat_results = Engine::ROLL_DICE(1);
                    }

                    if (enemy_combat_results.size() == 0)
                    {
                        enemy_combat_results = Engine::ROLL_DICE(1);
                    }
                }

                if (stage == Engine::MassCombat::MORALE)
                {
                    if (party_combat_score != enemy_combat_score)
                    {
                        if (morale.size() == 0)
                        {
                            Sound::Play(Sound::Type::DICE_ROLL);

                            morale = Engine::ROLL_DICE(1);
                        }
                    }
                }

                if (stage == Engine::MassCombat::COMBAT)
                {
                    auto row = 0;
                    auto col = 0;

                    party_combat_score = party.Army[party_unit].Strength;

                    for (auto i = 0; i < party_combat_results.size(); i++)
                    {
                        if (party_combat_results[i] >= 1 && party_combat_results[i] <= 6)
                        {
                            auto result = party_combat_results[i] - 1;

                            party_combat_score += party_combat_results[i];

                            fitImage(renderer, dice[result], offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);

                            if (col < cols)
                            {
                                col += 1;
                            }
                            else
                            {
                                col = 0;

                                row += 1;
                            }
                        }
                    }

                    row = 0;
                    col = 0;

                    enemy_combat_score = enemyArmy[enemy_unit].Strength;

                    if (enemyArmy[enemy_unit].Status != Army::Status::NONE && enemyArmy[enemy_unit].StatusRound >= 0 && enemyArmy[enemy_unit].StatusDuration >= 0 && ((combatRound - enemyArmy[enemy_unit].StatusRound) < enemyArmy[enemy_unit].StatusDuration))
                    {
                        if (enemyArmy[enemy_unit].Status == Army::Status::STRENGTH1)
                        {
                            enemy_combat_score += 1;
                        }
                    }

                    for (auto i = 0; i < enemy_combat_results.size(); i++)
                    {
                        if (enemy_combat_results[i] >= 1 && enemy_combat_results[i] <= 6)
                        {
                            auto result = enemy_combat_results[i] - 1;

                            enemy_combat_score += enemy_combat_results[i];

                            fitImage(renderer, dice[result], offsetx + boxwidth + marginx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);

                            if (col < cols)
                            {
                                col += 1;
                            }
                            else
                            {
                                col = 0;

                                row += 1;
                            }
                        }
                    }

                    if (!combat_resolved)
                    {
                        if (party_combat_score != enemy_combat_score)
                        {
                            if ((party_unit >= 0 && party_unit < party.Army.size()) && (enemy_unit >= 0 && enemy_unit < enemyArmy.size()))
                            {
                                if (party_combat_score < enemy_combat_score)
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    message = "The " + enemyArmy[enemy_unit].Name + " defeats your " + party.Army[party_unit].Name + "!";

                                    flash_color = intRD;
                                }
                                else if (enemy_combat_score < party_combat_score)
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    message = "Your " + party.Army[party_unit].Name + " defeats the " + enemyArmy[enemy_unit].Name + "!";

                                    flash_color = intLB;
                                }
                            }
                        }
                        else
                        {
                            Sound::Play(Sound::Type::FAIL);

                            message = "The fight is inconclusive!";

                            flash_color = intLB;
                        }

                        displayMessage(message, flash_color);

                        combat_resolved = true;
                    }
                }
            }

            if (stage == Engine::MassCombat::MORALE)
            {
                auto row = 0;
                auto col = 0;

                morale_score = 0;

                for (auto i = 0; i < morale.size(); i++)
                {
                    if (morale[i] >= 1 && morale[i] <= 6)
                    {
                        auto result = morale[i] - 1;

                        morale_score += morale[i];

                        if (party_combat_score > enemy_combat_score)
                        {
                            fitImage(renderer, dice[result], offsetx + boxwidth + marginx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);
                        }
                        else if (enemy_combat_score > party_combat_score)
                        {
                            fitImage(renderer, dice[result], offsetx + (col) * (box_space + size_dice), offsety + (row) * (box_space + size_dice), size_dice, size_dice);
                        }

                        if (col < cols)
                        {
                            col += 1;
                        }
                        else
                        {
                            col = 0;

                            row += 1;
                        }
                    }
                }

                if (!morale_checked)
                {
                    if (party_combat_score != enemy_combat_score)
                    {
                        if ((party_unit >= 0 && party_unit < party.Army.size()) && (enemy_unit >= 0 && enemy_unit < enemyArmy.size()))
                        {
                            if (party_combat_score < enemy_combat_score)
                            {
                                if (morale_score <= party.Army[party_unit].Morale)
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    Engine::GAIN_MORALE(party.Army[party_unit], -1);

                                    message = "Your " + party.Army[party_unit].Name + " loses 1 point of Morale!";
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::FAIL);

                                    message = "Your " + party.Army[party_unit].Name + " is routed!";

                                    party.Army[party_unit].Morale = 0;
                                }

                                Engine::UPDATE_ARMY(party.Army, location);

                                flash_color = intRD;
                            }
                            else if (enemy_combat_score < party_combat_score)
                            {
                                if (morale_score <= enemyArmy[enemy_unit].Morale)
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    Engine::GAIN_MORALE(enemyArmy[enemy_unit], -1);

                                    message = "The " + enemyArmy[enemy_unit].Name + " loses 1 point of Morale!";
                                }
                                else
                                {
                                    Sound::Play(Sound::Type::SUCCESS);

                                    message = "The " + enemyArmy[enemy_unit].Name + " is routed!";

                                    enemyArmy[enemy_unit].Morale = 0;
                                }

                                Engine::UPDATE_ARMY(enemyArmy, Location::Type::NONE);

                                flash_color = intLB;
                            }
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::FAIL);

                        message = "The fight is inconclusive!";

                        flash_color = intLB;
                    }

                    displayMessage(message, flash_color);

                    morale_checked = true;
                }
            }

            if (party_unit >= 0 && party_unit < party.Army.size())
            {
                std::string army_string = "";

                putHeader(renderer, party.Army[party_unit].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx, starty);

                army_string = "Strength: " + std::to_string(party.Army[party_unit].Strength);
                army_string += "\nMorale: " + std::to_string(party.Army[party_unit].Morale);

                putText(renderer, army_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx, starty + infoh);

                if (party_combat_score > 0)
                {
                    if (stage == Engine::MassCombat::COMBAT)
                    {
                        std::string combat_string = "Combat Result: " + std::to_string(party_combat_score);

                        putHeader(renderer, combat_string.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx, starty + infoh + 4 * boxh + 2 * box_space + infoh);
                    }
                    else if (stage == Engine::MassCombat::MORALE)
                    {
                        if (party_combat_score < enemy_combat_score)
                        {
                            std::string morale_string = "Morale Check: " + std::to_string(morale_score);

                            putHeader(renderer, morale_string.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx, starty + infoh + 4 * boxh + 2 * box_space + infoh);
                        }
                    }
                }
            }
            else
            {
                fillRect(renderer, headerw, infoh, startx, starty, fg);

                fillRect(renderer, boxwidth, boxh, startx, starty + infoh, intBE);
            }

            if (enemy_unit >= 0 && enemy_unit < enemyArmy.size())
            {
                std::string enemy_string = "";

                putHeader(renderer, enemyArmy[enemy_unit].Name.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, headerw, infoh, startx + boxwidth + marginx, starty);

                auto score = enemyArmy[enemy_unit].Strength;

                if (enemyArmy[enemy_unit].Status != Army::Status::NONE && enemyArmy[enemy_unit].StatusRound >= 0 && enemyArmy[enemy_unit].StatusDuration > 0 && ((combatRound - enemyArmy[enemy_unit].StatusRound) < enemyArmy[enemy_unit].StatusDuration))
                {
                    if (enemyArmy[enemy_unit].Status == Army::Status::STRENGTH1)
                    {
                        score += 1;
                    }
                }

                enemy_string = "Strength: " + std::to_string(score);
                enemy_string += "\nMorale: " + std::to_string(enemyArmy[enemy_unit].Morale);

                putText(renderer, enemy_string.c_str(), font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, boxwidth, boxh, startx + boxwidth + marginx, starty + infoh);

                if (enemy_combat_score > 0)
                {
                    if (stage == Engine::MassCombat::COMBAT)
                    {
                        std::string combat_string = "Combat Result: " + std::to_string(enemy_combat_score);

                        putHeader(renderer, combat_string.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx + boxwidth + marginx, starty + infoh + 4 * boxh + 2 * box_space + infoh);
                    }
                    else if (stage == Engine::MassCombat::MORALE)
                    {
                        if (enemy_combat_score < party_combat_score)
                        {
                            std::string morale_string = "Morale Check: " + std::to_string(morale_score);

                            putHeader(renderer, morale_string.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxwidth, infoh, startx + boxwidth + marginx, starty + infoh + 4 * boxh + 2 * box_space + infoh);
                        }
                    }
                }
            }
            else
            {
                fillRect(renderer, headerw, infoh, startx + boxwidth + marginx, starty, fg);

                fillRect(renderer, boxwidth, boxh, startx + boxwidth + marginx, starty + infoh, intBE);
            }

            if (stage == Engine::MassCombat::START)
            {
                controls = controls_combat;
            }
            else if (stage == Engine::MassCombat::COMBAT)
            {
                if (party_combat_score != enemy_combat_score)
                {
                    controls = controls_morale;
                }
                else
                {
                    stage = Engine::MassCombat::MORALE;

                    controls = controls_end;
                }
            }
            else if (stage == Engine::MassCombat::MORALE)
            {
                controls = controls_end;
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            renderTextButtons(renderer, controls, FONT_DARK11, current, clrWH, intDB, intLB, font_size, TTF_STYLE_NORMAL);

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if (selected && current >= 0 && current < controls.size())
            {
                if (stage == Engine::MassCombat::START && controls[current].Type == Control::Type::BACK)
                {
                    done = true;

                    current = -1;

                    selected = false;
                }
                else if (stage == Engine::MassCombat::START && controls[current].Type == Control::Type::CONFIRM)
                {
                    stage = Engine::MassCombat::COMBAT;
                }
                else if (stage == Engine::MassCombat::COMBAT && controls[current].Type == Control::Type::CONFIRM)
                {
                    stage = Engine::MassCombat::MORALE;
                }
                else if (stage == Engine::MassCombat::MORALE && controls[current].Type == Control::Type::BACK)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    stage = Engine::MassCombat::END;

                    done = true;

                    current = -1;

                    selected = false;
                }
            }
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        TTF_Quit();

        for (auto i = 0; i < 6; i++)
        {
            if (dice[i])
            {
                SDL_FreeSurface(dice[i]);

                dice[i] = NULL;
            }
        }
    }
}

Engine::Combat massCombatScreen(SDL_Window *window, SDL_Renderer *renderer, Location::Type location, Party::Base &party, std::vector<Army::Base> &enemyArmy, std::vector<Engine::BattlefieldSpells> &enemySpells, std::vector<Engine::ArmyStatus> &enemyStatus)
{
    auto combatResult = Engine::Combat::NONE;

    if (window && renderer)
    {
        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        auto messageh = (int)(0.125 * SCREEN_HEIGHT);

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);
        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);

        TTF_SetFontKerning(font_dark11, 0);

        auto boxw = (int)((fullwidth - 2 * box_space) / 3);

        auto combat_boxh = (int)((text_bounds - box_space - infoh) / 2);

        auto popupw = (int)(0.6 * SCREEN_WIDTH);
        auto popuph = (int)(0.6 * SCREEN_HEIGHT);
        auto popupx = (SCREEN_WIDTH - popupw) / 2;
        auto popupy = ((starty + text_bounds) - popuph) / 2;

        std::vector<Button> controls_yes = {Button(0, "icons/yes.png", 0, 0, 0, 0, popupx + button_space, popupy + popuph - button_space - buttonh, Control::Type::CONFIRM)};

        auto controls = std::vector<Button>();

        auto controls_battlefield = std::vector<Button>();

        Uint32 amask;

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
        amask = 0x000000ff;
#else
        amask = 0xff000000;
#endif

        for (auto y = 0; y < 2; y++)
        {
            for (auto x = 0; x < 3; x++)
            {
                SDL_Rect rect;

                rect.w = boxw - 2 * 8;
                rect.h = combat_boxh - 2 * 8;
                rect.x = 0;
                rect.y = 0;

                auto button = Button();

                button.Surface = SDL_CreateRGBSurface(0, boxw - 2 * 8, combat_boxh - 2 * 8, 32, 0, 0, 0, amask);

                if (y > 0)
                {
                    SDL_FillRect(button.Surface, &rect, intBE);
                }
                else
                {
                    SDL_FillRect(button.Surface, &rect, intBE);
                }

                button.ID = y * 3 + x;
                button.W = boxw - 2 * 8;
                button.H = combat_boxh - 2 * 8;
                button.Left = x > 0 ? y * 3 + x - 1 : y * 3 + x;
                button.Right = x < 2 ? y * 3 + x + 1 : y * 3 + x;
                button.Up = y > 0 ? (y - 1) * 3 + x : y * 3 + x;
                button.Down = y < 1 ? (y + 1) * 3 + x : (x < 2 ? (y + 1) * 3 + x : y * 3 + x);
                button.X = startx + x * (boxw + box_space) + border_space;
                button.Y = starty + infoh + y * (combat_boxh + box_space) + border_space + text_space;
                button.Type = Control::Type::ACTION;

                controls_battlefield.push_back(button);
            }
        }

        controls_battlefield.push_back(Button(6, createHeaderButton(window, FONT_DARK11, 28, "Fight", clrWH, intDB, text_buttonw, 48, -1), 6, 7, 3, 6, startx, text_buttony, Control::Type::CONFIRM));
        controls_battlefield.push_back(Button(7, createHeaderButton(window, FONT_DARK11, 28, "Cast Spell", clrWH, intDB, text_buttonw, 48, -1), 6, 7, 4, 7, startx + text_gridsize, text_buttony, Control::Type::SPELL));

        auto current = -1;
        auto selected = false;
        auto hold = false;
        auto scrollUp = false;
        auto scrollDown = false;

        auto current_mode = Engine::MassCombatMode::NORMAL;

        auto combat_round = 0;

        auto castSpells = std::vector<int>();
        auto enemy_has_cast = false;
        auto enemy_spell = Spells::MassCombat::NONE;

        while (Engine::ZONES(party.Army, enemyArmy) < 2 && Engine::ZONES(enemyArmy, party.Army) < 2)
        {
            for (auto i = 0; i < enemyStatus.size(); i++)
            {
                if (std::get<2>(enemyStatus[i]) == combat_round)
                {
                    auto enemy_unit = std::get<1>(enemyStatus[i]);

                    if (enemy_unit >= 0 && enemy_unit < enemyArmy.size())
                    {
                        enemyArmy[enemy_unit].Status = std::get<0>(enemyStatus[i]);

                        enemyArmy[enemy_unit].StatusRound = combat_round;

                        enemyArmy[enemy_unit].StatusDuration = std::get<3>(enemyStatus[i]);
                    }
                }
            }

            if (!enemy_has_cast)
            {
                enemy_spell = Engine::GET_SPELL(enemySpells, combat_round);

                if (enemy_spell != Spells::MassCombat::NONE)
                {
                    current_mode = Engine::MassCombatMode::SPELL;

                    enemy_has_cast = true;
                }
            }

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Mass Combat");

            fillWindow(renderer, intWH);

            for (auto y = 0; y < 2; y++)
            {
                for (auto x = 0; x < 3; x++)
                {
                    if (y > 0)
                    {
                        fillRect(renderer, boxw, combat_boxh, startx + x * (boxw + box_space), starty + infoh + y * (combat_boxh + box_space) + text_space, intBE);

                        thickRect(renderer, boxw - 2 * text_space, combat_boxh - 2 * text_space, startx + x * (boxw + box_space) + border_space, starty + infoh + y * (combat_boxh + box_space) + text_space + border_space, fg, border_pts);
                    }
                    else
                    {
                        fillRect(renderer, boxw, combat_boxh, startx + x * (boxw + box_space), starty + infoh + y * (combat_boxh + box_space) + text_space, intBE);
                    }
                }
            }

            putHeader(renderer, "Left Flank", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxw, infoh, startx, starty);
            putHeader(renderer, "Center", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxw, infoh, startx + (boxw + box_space), starty);
            putHeader(renderer, "Right Flank", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxw, infoh, startx + 2 * (boxw + box_space), starty);

            if (current_mode == Engine::MassCombatMode::NORMAL)
            {
                renderButtons(renderer, controls_battlefield, current, intLB, border_space, border_pts);

                controls = controls_battlefield;
            }
            else
            {
                renderButtons(renderer, controls_battlefield, -1, intLB, border_space, border_pts);
            }

            renderArmy(renderer, font_garamond, enemyArmy, boxw, combat_boxh, starty + infoh, clrBK, intBE);

            renderArmy(renderer, font_garamond, party.Army, boxw, combat_boxh, starty + infoh + combat_boxh + box_space, clrBK, intBE);

            if (current_mode == Engine::MassCombatMode::SPELL)
            {
                fillRect(renderer, popupw, popuph, popupx, popupy, intBE);

                drawRect(renderer, popupw, popuph, popupx, popupy, intBK);

                putText(renderer, Spells::MassCombatDescriptions[enemy_spell], font_garamond, text_space, clrBK, intBE, TTF_STYLE_NORMAL, popupw - 2 * text_space, popupy - infoh - 2 * text_space, popupx + text_space, popupy + infoh + text_space);

                std::string spell_string = "Your enemy has cast " + std::string(Spells::MassCombatNames[enemy_spell]);

                putHeader(renderer, spell_string.c_str(), font_dark11, text_space, clrWH, intDB, TTF_STYLE_NORMAL, popupw, infoh, popupx, popupy);

                renderButtons(renderer, controls_yes, current, intLB, border_space, border_pts);

                controls = controls_yes;

                enemy_has_cast = true;

                Sound::Play(Sound::Type::FAIL);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, -1, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, messageh, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current_mode == Engine::MassCombatMode::NORMAL)
                    {
                        if (current >= 0 && current < 6)
                        {
                            // TODO: View Army Unit popup?
                        }

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    if (current_mode == Engine::MassCombatMode::NORMAL)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        std::vector<Location::Zone> zones = {Location::Zone::LEFT_FLANK, Location::Zone::CENTER, Location::Zone::RIGHT_FLANK};

                        for (auto i = 0; i < zones.size(); i++)
                        {
                            if (Engine::ACTIVE(party.Army, enemyArmy, zones[i]))
                            {
                                resolveMassCombat(window, renderer, location, party, enemyArmy, enemySpells, enemyStatus, zones[i], combat_round);
                            }
                        }

                        castSpells.clear();

                        combat_round += 1;

                        enemy_has_cast = false;

                        enemy_spell = Spells::MassCombat::NONE;
                    }
                    else if (current_mode == Engine::MassCombatMode::SPELL)
                    {
                        if (enemy_spell == Spells::MassCombat::ENFEEBLEMENT_CENTER_FRONT)
                        {
                            auto party_unit = Engine::FIND_UNIT(party.Army, Location::BattleField::CENTER_FRONT);

                            if (party_unit >= 0 && party_unit < party.Army.size())
                            {
                                Engine::GAIN_STRENGTH(party.Army[party_unit], -1);
                            }
                        }
                        else if (enemy_spell == Spells::MassCombat::CLINGING_DREAD_LEFT_FRONT)
                        {
                            auto party_unit = Engine::FIND_UNIT(party.Army, Location::BattleField::LEFT_FLANK_FRONT);

                            if (party_unit >= 0 && party_unit < party.Army.size())
                            {
                                Engine::GAIN_MORALE(party.Army[party_unit], -1);
                            }
                        }
                        else if (enemy_spell == Spells::MassCombat::ROUT_LEFT_FRONT)
                        {
                            auto party_unit = Engine::FIND_UNIT(party.Army, Location::BattleField::LEFT_FLANK_FRONT);

                            if (party_unit >= 0 && party_unit < party.Army.size())
                            {
                                auto result = moraleCheck(window, renderer, party.Book, party.Army[party_unit], combat_round);

                                if (!result)
                                {
                                    party.Army[party_unit].Position = Location::BattleField::NONE;

                                    auto next_unit = Engine::FIND_UNIT(party.Army, Location::BattleField::LEFT_FLANK_SUPPORT);

                                    if (next_unit >= 0 && next_unit < party.Army.size())
                                    {
                                        party.Army[next_unit].Position = Location::BattleField::LEFT_FLANK_FRONT;
                                    }
                                }
                            }
                        }

                        current_mode = Engine::MassCombatMode::NORMAL;
                    }

                    selected = false;

                    current = -1;
                }
                else if (controls[current].Type == Control::Type::SPELL && !hold)
                {
                    if (Engine::SPELLCASTERS(party) > 0)
                    {
                        auto combat_spells = 0;

                        for (auto i = 0; i < party.Members.size(); i++)
                        {
                            if (Engine::IS_ALIVE(party.Members[i]) && party.Members[i].SpellCaster)
                            {
                                auto spells = Engine::COUNT(party.Members[i].SpellBook, Spells::Scope::SEA_COMBAT);

                                combat_spells += spells;
                            }
                        }

                        if (combat_spells <= 0)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("Your party does not have any usable mass combat spells.", intRD);
                        }
                        else if (castSpells.size() >= Engine::SPELLCASTERS(party))
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("Your party has already cast spells this round.", intRD);
                        }
                        else
                        {
                            auto caster = castMassCombatSpell(window, renderer, party, enemyArmy, location, castSpells, combat_round);

                            if (caster >= 0 && caster < party.Members.size())
                            {
                                castSpells.push_back(caster);

                                displayMessage(party.Members[caster].Name + " casts a spell!", intLB);
                            }

                            selected = false;

                            current = -1;
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("There are no spell casters in your party!", intRD);
                    }
                }
            }
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        TTF_Quit();
    }

    if (Engine::ZONES(party.Army, enemyArmy) > 1)
    {
        Sound::Play(Sound::Type::SUCCESS);

        combatResult = Engine::Combat::VICTORY;
    }
    else if (Engine::ZONES(enemyArmy, party.Army) > 1)
    {
        Sound::Play(Sound::Type::FAIL);

        combatResult = Engine::Combat::DEFEAT;
    }

    return combatResult;
}

Engine::Combat deploymentScreen(SDL_Window *window, SDL_Renderer *renderer, Location::Type location, Party::Base &party, std::vector<Army::Base> &enemyArmy, std::vector<Engine::BattlefieldSpells> &enemySpells, std::vector<Engine::ArmyStatus> &enemyStatus)
{
    auto combatResult = Engine::Combat::NONE;

    if (window && renderer)
    {
        auto flash_message = false;

        auto flash_color = intRD;

        std::string message = "";

        auto messageh = (int)(0.125 * SCREEN_HEIGHT);

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);
        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);

        TTF_SetFontKerning(font_dark11, 0);

        auto font_size = 28;

        auto boxw = (int)((fullwidth - 2 * box_space) / 3);

        auto deployment_boxh = (int)((text_bounds - box_space - infoh) / 2);

        auto popupw = (int)(0.6 * SCREEN_WIDTH);
        auto popuph = (int)(0.6 * SCREEN_HEIGHT);
        auto popupx = (SCREEN_WIDTH - popupw) / 2;
        auto popupy = ((starty + text_bounds) - popuph) / 2;

        auto offset = 0;
        auto limit = (popuph - infoh - buttonh - button_space) / (96);
        auto last = offset + limit;

        if (last > party.Army.size())
        {
            last = party.Army.size();
        }

        auto done = false;

        auto controls = std::vector<Button>();

        auto controls_battlefield = std::vector<Button>();

        Uint32 amask;

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
        amask = 0x000000ff;
#else
        amask = 0xff000000;
#endif

        for (auto y = 0; y < 2; y++)
        {
            for (auto x = 0; x < 3; x++)
            {
                SDL_Rect rect;

                rect.w = boxw - 2 * 8;
                rect.h = deployment_boxh - 2 * 8;
                rect.x = 0;
                rect.y = 0;

                auto button = Button();

                button.Surface = SDL_CreateRGBSurface(0, boxw - 2 * 8, deployment_boxh - 2 * 8, 32, 0, 0, 0, amask);

                if (y > 0)
                {
                    SDL_FillRect(button.Surface, &rect, intBE);
                }
                else
                {
                    SDL_FillRect(button.Surface, &rect, intBE);
                }

                button.ID = y * 3 + x;
                button.W = boxw - 2 * 8;
                button.H = deployment_boxh - 2 * 8;
                button.Left = x > 0 ? y * 3 + x - 1 : y * 3 + x;
                button.Right = x < 2 ? y * 3 + x + 1 : y * 3 + x;
                button.Up = y > 0 ? (y - 1) * 3 + x : y * 3 + x;
                button.Down = y < 1 ? (y + 1) * 3 + x : (x < 2 ? (y + 1) * 3 + x : y * 3 + x);
                button.X = startx + x * (boxw + box_space) + border_space;
                button.Y = starty + infoh + y * (deployment_boxh + box_space) + border_space + text_space;
                button.Type = Control::Type::ACTION;

                controls_battlefield.push_back(button);
            }
        }

        controls_battlefield.push_back(Button(6, createHeaderButton(window, FONT_DARK11, font_size, "Start Battle", clrWH, intDB, text_buttonw, 48, -1), 6, 7, 3, 6, startx, text_buttony, Control::Type::CONFIRM));
        controls_battlefield.push_back(Button(7, createHeaderButton(window, FONT_DARK11, font_size, "Cancel", clrWH, intDB, text_buttonw, 48, -1), 6, 7, 4, 7, startx + text_gridsize, text_buttony, Control::Type::BACK));

        auto controls_deploy = popupArmy(window, renderer, party.Army, offset, last, limit, popupw, popuph, infoh, popupx, popupy);

        auto current = -1;
        auto selected = false;
        auto hold = false;
        auto scrollUp = false;
        auto scrollDown = false;
        auto scrollSpeed = 1;

        auto current_zone = Location::Zone::NONE;
        auto current_mode = Engine::MassCombatMode::NORMAL;

        auto left_flank = std::vector<int>();
        auto center = std::vector<int>();
        auto right_flank = std::vector<int>();

        Engine::CLEAR_POSITIONS(party.Army);

        while (!done)
        {
            if (last > party.Army.size())
            {
                last = party.Army.size();
            }

            SDL_SetWindowTitle(window, "Legendary Kingdoms: Army Deployment");

            fillWindow(renderer, intWH);

            for (auto y = 0; y < 2; y++)
            {
                for (auto x = 0; x < 3; x++)
                {
                    if (y > 0)
                    {
                        fillRect(renderer, boxw, deployment_boxh, startx + x * (boxw + box_space), starty + infoh + y * (deployment_boxh + box_space) + text_space, intBE);

                        thickRect(renderer, boxw - 2 * text_space, deployment_boxh - 2 * text_space, startx + x * (boxw + box_space) + border_space, starty + infoh + y * (deployment_boxh + box_space) + text_space + border_space, fg, border_pts);
                    }
                    else
                    {
                        fillRect(renderer, boxw, deployment_boxh, startx + x * (boxw + box_space), starty + infoh + y * (deployment_boxh + box_space) + text_space, intBE);
                    }
                }
            }

            putHeader(renderer, "Left Flank", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxw, infoh, startx, starty);
            putHeader(renderer, "Center", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxw, infoh, startx + (boxw + box_space), starty);
            putHeader(renderer, "Right Flank", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, boxw, infoh, startx + 2 * (boxw + box_space), starty);

            if (current_mode == Engine::MassCombatMode::NORMAL)
            {
                renderButtons(renderer, controls_battlefield, current, intLB, border_space, border_pts);

                controls = controls_battlefield;
            }
            else
            {
                renderButtons(renderer, controls_battlefield, -1, intLB, border_space, border_pts);
            }

            renderArmy(renderer, font_garamond, enemyArmy, boxw, deployment_boxh, starty + infoh, clrBK, intBE);

            renderArmy(renderer, font_garamond, party.Army, boxw, deployment_boxh, starty + infoh + deployment_boxh + box_space, clrBK, intBE);

            if (current_mode == Engine::MassCombatMode::DEPLOY)
            {
                fillRect(renderer, popupw, popuph, popupx, popupy, intBE);

                drawRect(renderer, popupw, popuph, popupx, popupy, intBK);

                std::string deploy_string = "Select unit to deploy to the ";

                if (current_zone == Location::Zone::LEFT_FLANK)
                {
                    deploy_string += "left flank";
                }
                else if (current_zone == Location::Zone::CENTER)
                {
                    deploy_string += "center";
                }
                else if (current_zone == Location::Zone::RIGHT_FLANK)
                {
                    deploy_string += "right flank";
                }
                else
                {
                    deploy_string += "battlefield";
                }

                putHeader(renderer, deploy_string.c_str(), font_dark11, text_space, clrWH, intDB, TTF_STYLE_NORMAL, popupw, infoh, popupx, popupy);

                controls = controls_deploy;

                if (last - offset > 0)
                {
                    for (auto i = 0; i < last - offset; i++)
                    {
                        auto selection = left_flank;

                        if (current_zone == Location::Zone::LEFT_FLANK)
                        {
                            selection = left_flank;
                        }
                        else if (current_zone == Location::Zone::CENTER)
                        {
                            selection = center;
                        }
                        else if (current_zone == Location::Zone::RIGHT_FLANK)
                        {
                            selection = right_flank;
                        }

                        if (Engine::FIND_LIST(selection, offset + i) >= 0)
                        {
                            thickRect(renderer, controls[i].W + border_pts, controls[i].H + border_pts, controls[i].X - 2, controls[i].Y - 2, intLB, 2);
                        }
                        else
                        {
                            drawRect(renderer, controls[i].W + border_space, controls[i].H + border_space, controls[i].X - border_pts, controls[i].Y - border_pts, intBK);
                        }
                    }
                }

                renderButtons(renderer, controls_deploy, current, intLB, border_space, border_pts);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, -1, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, messageh, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (current_mode == Engine::MassCombatMode::DEPLOY)
                    {
                        if (offset > 0)
                        {
                            offset -= scrollSpeed;

                            if (offset < 0)
                            {
                                offset = 0;
                            }

                            last = offset + limit;

                            if (last > party.Army.size())
                            {
                                last = party.Army.size();
                            }

                            controls_deploy = popupArmy(window, renderer, party.Army, offset, last, limit, popupw, popuph, infoh, popupx, popupy);

                            SDL_Delay(50);
                        }

                        if (offset <= 0)
                        {
                            current = -1;

                            selected = false;
                        }
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (current_mode == Engine::MassCombatMode::DEPLOY)
                    {
                        if (party.Army.size() - last > 0)
                        {
                            if (offset < party.Army.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > party.Army.size() - limit)
                            {
                                offset = party.Army.size() - limit;
                            }

                            last = offset + limit;

                            if (last > party.Army.size())
                            {
                                last = party.Army.size();
                            }

                            controls_deploy = popupArmy(window, renderer, party.Army, offset, last, limit, popupw, popuph, infoh, popupx, popupy);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls_deploy, Control::Type::SCROLL_DOWN);
                            }

                            SDL_Delay(50);
                        }

                        if (party.Army.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current_mode == Engine::MassCombatMode::NORMAL)
                    {
                        if (current >= 0 && current < 6)
                        {
                            if (current > 2 && current < 6)
                            {
                                if (current == 3)
                                {
                                    current_zone = Location::Zone::LEFT_FLANK;
                                }
                                else if (current == 4)
                                {
                                    current_zone = Location::Zone::CENTER;
                                }
                                else if (current == 5)
                                {
                                    current_zone = Location::Zone::RIGHT_FLANK;
                                }

                                current_mode = Engine::MassCombatMode::DEPLOY;

                                current = -1;

                                controls_deploy = popupArmy(window, renderer, party.Army, offset, last, limit, popupw, popuph, infoh, popupx, popupy);
                            }
                        }

                        selected = false;
                    }
                    else if (current_mode == Engine::MassCombatMode::DEPLOY)
                    {
                        if (current_zone == Location::Zone::LEFT_FLANK)
                        {
                            if (current + offset >= 0 && current + offset < party.Army.size())
                            {
                                auto result = Engine::FIND_LIST(left_flank, current + offset);
                                auto center_result = Engine::FIND_LIST(center, current + offset);
                                auto right_result = Engine::FIND_LIST(right_flank, current + offset);

                                if (result >= 0 && result < left_flank.size())
                                {
                                    left_flank.erase(left_flank.begin() + result);
                                }
                                else if (left_flank.size() < 2)
                                {
                                    if (party.Army[current + offset].Garrison != location)
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage("You can only deploy a unit from the " + std::string(Location::Description[location]) + " barracks!", intRD);
                                    }
                                    else if (party.Army[current + offset].Morale <= 0)
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Army[current + offset].Name + " cannot join this battle!", intRD);
                                    }
                                    else
                                    {
                                        left_flank.push_back(current + offset);

                                        if (center_result >= 0 && center_result < center.size())
                                        {
                                            center.erase(center.begin() + center_result);
                                        }

                                        if (right_result >= 0 && right_result < right_flank.size())
                                        {
                                            right_flank.erase(right_flank.begin() + right_result);
                                        }
                                    }
                                }
                            }
                        }
                        else if (current_zone == Location::Zone::CENTER)
                        {
                            if (current + offset >= 0 && current + offset < party.Army.size())
                            {
                                auto result = Engine::FIND_LIST(center, current + offset);
                                auto right_result = Engine::FIND_LIST(right_flank, current + offset);
                                auto left_result = Engine::FIND_LIST(left_flank, current + offset);

                                if (result >= 0 && result < center.size())
                                {
                                    center.erase(center.begin() + result);
                                }
                                else if (center.size() < 2)
                                {
                                    if (party.Army[current + offset].Garrison != location)
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage("You can only deploy a unit from the " + std::string(Location::Description[location]) + " barracks!", intRD);
                                    }
                                    else if (party.Army[current + offset].Morale <= 0)
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Army[current + offset].Name + " cannot join this battle!", intRD);
                                    }
                                    else
                                    {
                                        center.push_back(current + offset);

                                        if (right_result >= 0 && right_result < right_flank.size())
                                        {
                                            right_flank.erase(right_flank.begin() + right_result);
                                        }

                                        if (left_result >= 0 && left_result < left_flank.size())
                                        {
                                            left_flank.erase(left_flank.begin() + left_result);
                                        }
                                    }
                                }
                            }
                        }
                        else if (current_zone == Location::Zone::RIGHT_FLANK)
                        {
                            if (current + offset >= 0 && current + offset < party.Army.size())
                            {
                                auto result = Engine::FIND_LIST(right_flank, current + offset);
                                auto center_result = Engine::FIND_LIST(center, current + offset);
                                auto left_result = Engine::FIND_LIST(left_flank, current + offset);

                                if (result >= 0 && result < right_flank.size())
                                {
                                    right_flank.erase(right_flank.begin() + result);
                                }
                                else if (right_flank.size() < 2)
                                {
                                    if (party.Army[current + offset].Garrison != location)
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage("You can only deploy a unit from the " + std::string(Location::Description[location]) + " barracks!", intRD);
                                    }
                                    else if (party.Army[current + offset].Morale <= 0)
                                    {
                                        Sound::Play(Sound::Type::ERROR);

                                        displayMessage(party.Army[current + offset].Name + " cannot join this battle!", intRD);
                                    }
                                    else
                                    {
                                        right_flank.push_back(current + offset);

                                        if (center_result >= 0 && center_result < center.size())
                                        {
                                            center.erase(center.begin() + center_result);
                                        }

                                        if (left_result >= 0 && left_result < left_flank.size())
                                        {
                                            left_flank.erase(left_flank.begin() + left_result);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    if (current_mode == Engine::MassCombatMode::NORMAL)
                    {
                        if (Engine::ZONES(enemyArmy, party.Army) > 1)
                        {
                            Sound::Play(Sound::Type::FAIL);

                            combatResult = Engine::Combat::DEFEAT;

                            done = true;
                        }
                        else if (Engine::ZONES(party.Army, enemyArmy) > 1)
                        {
                            Sound::Play(Sound::Type::SUCCESS);

                            combatResult = Engine::Combat::VICTORY;

                            done = true;
                        }
                        else
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            combatResult = massCombatScreen(window, renderer, location, party, enemyArmy, enemySpells, enemyStatus);

                            done = true;
                        }
                    }
                    else if (current_mode == Engine::MassCombatMode::DEPLOY)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        Engine::CLEAR_POSITIONS(party.Army);

                        if (left_flank.size() > 0)
                        {
                            party.Army[left_flank[0]].Position = Location::BattleField::LEFT_FLANK_FRONT;

                            if (left_flank.size() > 1)
                            {
                                party.Army[left_flank[1]].Position = Location::BattleField::LEFT_FLANK_SUPPORT;
                            }
                        }

                        if (center.size() > 0)
                        {
                            party.Army[center[0]].Position = Location::BattleField::CENTER_FRONT;

                            if (center.size() > 1)
                            {
                                party.Army[center[1]].Position = Location::BattleField::CENTER_SUPPORT;
                            }
                        }

                        if (right_flank.size() > 0)
                        {
                            party.Army[right_flank[0]].Position = Location::BattleField::RIGHT_FLANK_FRONT;

                            if (right_flank.size() > 1)
                            {
                                party.Army[right_flank[1]].Position = Location::BattleField::RIGHT_FLANK_SUPPORT;
                            }
                        }

                        controls_deploy = popupArmy(window, renderer, party.Army, offset, last, limit, popupw, popuph, infoh, popupx, popupy);

                        current_mode = Engine::MassCombatMode::NORMAL;

                        current_zone = Location::Zone::NONE;

                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    if (current_mode == Engine::MassCombatMode::NORMAL)
                    {
                        done = true;
                    }
                    else if (current_mode == Engine::MassCombatMode::DEPLOY)
                    {
                        current_mode = Engine::MassCombatMode::NORMAL;

                        current_zone = Location::Zone::NONE;

                        current = -1;

                        selected = false;
                    }
                }
            }
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        TTF_Quit();
    }

    return combatResult;
}

std::vector<Button> createChoices(SDL_Window *window, SDL_Renderer *renderer, std::vector<Choice::Base> choices, int start, int last, int limit, int offsetx, int offsety)
{
    auto controls = std::vector<Button>();

    if (choices.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 24, choices[index].Text, clrBK, intBE, list_buttonw, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (choices.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (choices.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/papyrus.png", idx - 1, idx + 1, idx - 1, idx, textx, buttony, Control::Type::ENCYCLOPEDIA));
    controls.push_back(Button(idx + 1, "icons/ancient-map.png", idx, idx + 2, idx - 1, idx + 1, textx + gridsize, buttony, Control::Type::MAP));
    controls.push_back(Button(idx + 2, "icons/user.png", idx + 1, idx + 3, idx - 1, idx + 2, textx + 2 * gridsize, buttony, Control::Type::PARTY));
    controls.push_back(Button(idx + 3, "icons/back-button.png", idx + 2, idx + 3, idx - 1, idx + 3, lastx, buttony, Control::Type::BACK));

    return controls;
}

void addBye(Story::Base *story, std::string bye)
{
    if (bye.length() > 0)
    {
        if (!story->Bye)
        {
            story->temp_string = bye;
        }
        else
        {
            story->temp_string = std::string(story->Bye) + "\n\n" + bye;
        }

        story->Bye = story->temp_string.c_str();
    }
}

void followersJSON(nlohmann::json &json, std::vector<Follower::Base> followers)
{
    for (auto i = 0; i < followers.size(); i++)
    {
        nlohmann::json data;

        data.emplace("name", followers[i].Name);
        data.emplace("type", followers[i].Type);
        data.emplace("health", followers[i].Health);

        json.push_back(data);
    }
}

void spellBookJSON(nlohmann::json &json, std::vector<Spells::Base> spells)
{
    for (auto i = 0; i < spells.size(); i++)
    {
        nlohmann::json data;

        data.emplace("name", spells[i].Name);
        data.emplace("description", spells[i].Description);
        data.emplace("scope", spells[i].Scope);
        data.emplace("type", spells[i].Type);
        data.emplace("charged", spells[i].Charged);
        data.emplace("recharge", spells[i].Recharge);

        json.push_back(data);
    }
}

void attributesJSON(nlohmann::json &json, std::vector<Attribute::Base> attributes)
{
    for (auto i = 0; i < attributes.size(); i++)
    {
        nlohmann::json data;

        data.emplace("type", attributes[i].Type);
        data.emplace("value", attributes[i].Value);

        json.push_back(data);
    }
}

void equipmentJSON(nlohmann::json &json, std::vector<Equipment::Base> equipment)
{
    for (auto i = 0; i < equipment.size(); i++)
    {
        nlohmann::json data;

        data.emplace("name", equipment[i].Name);
        data.emplace("description", equipment[i].Description);
        data.emplace("class", equipment[i].Class);
        data.emplace("type", equipment[i].Type);
        data.emplace("attribute", equipment[i].Attribute);
        data.emplace("modifier", equipment[i].Modifier);
        data.emplace("twoHanded", equipment[i].TwoHanded);
        data.emplace("additionalSlots", equipment[i].AdditionalSlots);
        data.emplace("value", equipment[i].Value);

        json.push_back(data);
    }
}

std::string getSavePath()
{
#if defined(_WIN32)
    PWSTR path_str;

    SHGetKnownFolderPath(FOLDERID_Documents, KF_FLAG_DEFAULT, NULL, &path_str);

    std::wstring wpath(path_str);

    CoTaskMemFree(path_str);

    std::string save(wpath.length(), ' ');

    std::copy(wpath.begin(), wpath.end(), save.begin());

    save += "/Saved Games/Legendary Kingdoms";
#else
    const char *homedir;

    if ((homedir = getenv("HOME")) == NULL)
    {
        homedir = getpwuid(getuid())->pw_dir;
    }

    std::string save = std::string(homedir) + "/Documents/Saved Games/Legendary Kingdoms";
#endif

    return save;
}

void saveGame(Party::Base &party, const char *overwrite)
{
    auto seed = std::chrono::system_clock::now().time_since_epoch() / std::chrono::milliseconds(1);

    std::ostringstream buffer;

    auto save = getSavePath();

    std::string path = save + "/";

    fs::create_directories(save);

    if (overwrite != NULL)
    {
        buffer << std::string(overwrite);
    }
    else
    {
        buffer << path << std::to_string(seed) << ".save";
    }

    nlohmann::json data;

    party.Epoch = seed;

    // set up empty lists/arrays
    data["members"] = std::vector<nlohmann::json>();
    data["codes"] = std::vector<nlohmann::json>();
    data["vault"] = std::vector<nlohmann::json>();
    data["fleet"] = std::vector<nlohmann::json>();
    data["army"] = std::vector<nlohmann::json>();
    data["dead"] = std::vector<int>();
    data["invisibleCodes"] = std::vector<int>();
    data["lastSelection"] = std::vector<int>();
    data["order"] = std::vector<int>();
    data["hearts"] = std::vector<std::vector<int>>();

    data["location"] = party.Location;
    data["vaultMoney"] = party.VaultMoney;
    data["money"] = party.Money;
    data["limit"] = party.Limit;
    data["currentShip"] = party.CurrentShip;
    data["recentSuccesses"] = party.RecentSuccesses;
    data["lastSelected"] = party.LastSelected;
    data["currentCharacter"] = party.CurrentCharacter;
    data["book"] = party.Book;
    data["storyID"] = party.StoryID;
    data["epoch"] = party.Epoch;

    // save characters
    for (auto i = 0; i < party.Members.size(); i++)
    {
        nlohmann::json character;

        character["attributes"] = std::vector<nlohmann::json>();
        character["equipment"] = std::vector<nlohmann::json>();
        character["spellBook"] = std::vector<nlohmann::json>();
        character["followers"] = std::vector<nlohmann::json>();
        character["status"] = std::vector<int>();

        character["name"] = party.Members[i].Name;
        character["background"] = party.Members[i].Background;
        character["image"] = party.Members[i].Image;
        character["type"] = party.Members[i].Type;
        character["team"] = party.Members[i].Team;
        character["health"] = party.Members[i].Health;
        character["maximumHealth"] = party.Members[i].MaximumHealth;
        character["maximumEquipment"] = party.Members[i].MaximumEquipment;
        character["spellBookLimit"] = party.Members[i].SpellBookLimit;
        character["spellCaster"] = party.Members[i].SpellCaster;
        character["isCivilized"] = party.Members[i].IsCivilized;
        character["damaged"] = party.Members[i].Damaged;

        equipmentJSON(character["equipment"], party.Members[i].Equipment);
        attributesJSON(character["attributes"], party.Members[i].Attributes);
        spellBookJSON(character["spellBook"], party.Members[i].SpellBook);
        followersJSON(character["followers"], party.Members[i].Followers);

        for (auto j = 0; j < party.Members[i].Status.size(); j++)
        {
            character["status"].push_back(party.Members[i].Status[j]);
        }

        data["members"].push_back(character);
    }

    // save codes
    for (auto i = 0; i < party.Codes.size(); i++)
    {
        nlohmann::json code;

        code.emplace("type", party.Codes[i].Type);
        code.emplace("code", party.Codes[i].Code);

        data["codes"].push_back(code);
    }

    // save vault equipment
    equipmentJSON(data["vault"], party.Vault);

    // save fleet
    for (auto i = 0; i < party.Fleet.size(); i++)
    {
        nlohmann::json ship;

        ship.emplace("name", party.Fleet[i].Name);
        ship.emplace("type", party.Fleet[i].Type);
        ship.emplace("location", party.Fleet[i].Location);
        ship.emplace("fighting", party.Fleet[i].Fighting);
        ship.emplace("health", party.Fleet[i].Health);
        ship.emplace("maximumHealth", party.Fleet[i].MaximumHealth);
        ship.emplace("maximumCargo", party.Fleet[i].MaximumCargo);
        ship["cargo"] = std::vector<int>();

        for (auto j = 0; j < party.Fleet[i].Cargo.size(); j++)
        {
            ship["cargo"].push_back(party.Fleet[i].Cargo[j]);
        }

        data["fleet"].push_back(ship);
    }

    // save army
    for (auto i = 0; i < party.Army.size(); i++)
    {
        nlohmann::json unit;

        unit.emplace("name", party.Army[i].Name);
        unit.emplace("type", party.Army[i].Type);
        unit.emplace("garrison", party.Army[i].Garrison);
        unit.emplace("strength", party.Army[i].Strength);
        unit.emplace("maximumStrength", party.Army[i].MaximumStrength);
        unit.emplace("morale", party.Army[i].Morale);
        unit.emplace("maximumMorale", party.Army[i].MaximumMorale);
        unit.emplace("unique", party.Army[i].Unique);
        unit.emplace("position", party.Army[i].Position);
        unit.emplace("status", party.Army[i].Status);
        unit.emplace("statusRound", party.Army[i].StatusRound);
        unit.emplace("statusDuration", party.Army[i].StatusDuration);

        data["army"].push_back(unit);
    }

    for (auto i = 0; i < party.Dead.size(); i++)
    {
        data["dead"].push_back(party.Dead[i]);
    }

    for (auto i = 0; i < party.InvisibleCodes.size(); i++)
    {
        data["invisibleCodes"].push_back(party.InvisibleCodes[i]);
    }

    for (auto i = 0; i < party.LastSelection.size(); i++)
    {
        data["lastSelection"].push_back(party.LastSelection[i]);
    }

    for (auto i = 0; i < party.Order.size(); i++)
    {
        data["order"].push_back(party.Order[i]);
    }

    for (auto i = 0; i < party.Hearts.size(); i++)
    {
        auto hearts = std::vector<int>();

        auto heart = party.Hearts.begin();

        std::advance(heart, i);

        auto romance = heart->first;

        auto from = romance.first;

        auto to = romance.second;

        auto value = party.Hearts[romance];

        hearts.push_back((int)from);
        hearts.push_back((int)to);
        hearts.push_back(value);

        data["hearts"].push_back(hearts);
    }

    std::string filename = buffer.str();

    std::ofstream file(filename);

    file << data.dump();

    file.close();
}

Party::Base loadGame(std::string file_name)
{
    auto party = Party::Base();

    std::ifstream ifs(file_name);

    if (ifs.good())
    {
        auto data = nlohmann::json::parse(ifs);

        ifs.close();

        party.Location = !data["location"].is_null() ? static_cast<Location::Type>((int)data["location"]) : Location::Type::NONE;
        party.VaultMoney = !data["vaultMoney"].is_null() ? (int)data["vaultMoney"] : 0;
        party.Money = !data["money"].is_null() ? (int)data["money"] : 0;
        party.Limit = !data["limit"].is_null() ? (int)data["limit"] : party.Limit;
        party.CurrentShip = !data["currentShip"].is_null() ? (int)data["currentShip"] : -1;
        party.RecentSuccesses = !data["recentSuccesses"].is_null() ? (int)data["recentSuccesses"] : 0;
        party.LastSelected = !data["lastSelected"].is_null() ? (int)data["lastSelected"] : -1;
        party.CurrentCharacter = !data["currentCharacter"].is_null() ? (int)data["currentCharacter"] : -1;
        party.Book = !data["book"].is_null() ? static_cast<Book::Type>((int)data["book"]) : Book::Type::NONE;
        party.StoryID = !data["storyID"].is_null() ? (int)data["storyID"] : -1;

#if defined(_WIN32) || defined(__arm__)
        party.Epoch = !data["epoch"].is_null() ? (long long)(data["epoch"]) : 0;
#else
        party.Epoch = !data["epoch"].is_null() ? (long)(data["epoch"]) : 0;
#endif

        // load party members, attributes, equipment, spellbook, followers, status
        if (!data["members"].is_null() && data["members"].is_array() && data["members"].size() > 0)
        {
            for (auto i = 0; i < data["members"].size(); i++)
            {
                auto character = Character::Base();

                character.Name = !data["members"][i]["name"].is_null() ? data["members"][i]["name"] : "";
                character.Background = !data["members"][i]["background"].is_null() ? data["members"][i]["background"] : "";
                character.Image = !data["members"][i]["image"].is_null() ? data["members"][i]["image"] : "";
                character.Type = !data["members"][i]["type"].is_null() ? static_cast<Character::Type>((int)data["members"][i]["type"]) : Character::Type::NONE;
                character.Team = !data["members"][i]["team"].is_null() ? static_cast<Team::Type>((int)data["members"][i]["team"]) : Team::Type::NONE;
                character.Health = !data["members"][i]["health"].is_null() ? (int)data["members"][i]["health"] : 0;
                character.MaximumHealth = !data["members"][i]["maximumHealth"].is_null() ? (int)data["members"][i]["maximumHealth"] : 0;
                character.MaximumEquipment = !data["members"][i]["maximumEquipment"].is_null() ? (int)data["members"][i]["maximumEquipment"] : character.MaximumEquipment;
                character.SpellBookLimit = !data["members"][i]["spellBookLimit"].is_null() ? (int)data["members"][i]["spellBookLimit"] : 10;
                character.SpellCaster = !data["members"][i]["spellCaster"].is_null() ? (bool)data["members"][i]["spellCaster"] : character.SpellCaster;
                character.IsCivilized = !data["members"][i]["isCivilized"].is_null() ? (bool)data["members"][i]["isCivilized"] : character.IsCivilized;
                character.Damaged = !data["members"][i]["damaged"].is_null() ? (bool)data["members"][i]["damaged"] : character.Damaged;

                if (!data["members"][i]["equipment"].is_null() && data["members"][i]["equipment"].is_array() && data["members"][i]["equipment"].size() > 0)
                {
                    for (auto j = 0; j < data["members"][i]["equipment"].size(); j++)
                    {
                        auto equipment = Equipment::Base();

                        equipment.Name = !data["members"][i]["equipment"][j]["name"].is_null() ? data["members"][i]["equipment"][j]["name"] : "";
                        equipment.Description = !data["members"][i]["equipment"][j]["description"].is_null() ? data["members"][i]["equipment"][j]["description"] : "";
                        equipment.Class = !data["members"][i]["equipment"][j]["class"].is_null() ? static_cast<Equipment::Class>((int)data["members"][i]["equipment"][j]["class"]) : equipment.Class;
                        equipment.Type = !data["members"][i]["equipment"][j]["type"].is_null() ? static_cast<Equipment::Type>((int)data["members"][i]["equipment"][j]["type"]) : equipment.Type;
                        equipment.Attribute = !data["members"][i]["equipment"][j]["attribute"].is_null() ? static_cast<Attribute::Type>((int)data["members"][i]["equipment"][j]["attribute"]) : equipment.Attribute;
                        equipment.Modifier = !data["members"][i]["equipment"][j]["modifier"].is_null() ? (int)data["members"][i]["equipment"][j]["modifier"] : equipment.Modifier;
                        equipment.TwoHanded = !data["members"][i]["equipment"][j]["twoHanded"].is_null() ? (bool)data["members"][i]["equipment"][j]["twoHanded"] : equipment.TwoHanded;
                        equipment.AdditionalSlots = !data["members"][i]["equipment"][j]["additionalSlots"].is_null() ? (int)data["members"][i]["equipment"][j]["additionalSlots"] : equipment.AdditionalSlots;
                        equipment.Value = !data["members"][i]["equipment"][j]["value"].is_null() ? (int)data["members"][i]["equipment"][j]["value"] : equipment.Value;

                        character.Equipment.push_back(equipment);
                    }
                }

                if (!data["members"][i]["attributes"].is_null() && data["members"][i]["attributes"].is_array() && data["members"][i]["attributes"].size() > 0)
                {
                    for (auto j = 0; j < data["members"][i]["attributes"].size(); j++)
                    {
                        auto attribute = Attribute::Base();

                        attribute.Type = !data["members"][i]["attributes"][j]["type"].is_null() ? static_cast<Attribute::Type>((int)data["members"][i]["attributes"][j]["type"]) : attribute.Type;
                        attribute.Value = !data["members"][i]["attributes"][j]["value"].is_null() ? (int)data["members"][i]["attributes"][j]["value"] : attribute.Value;

                        character.Attributes.push_back(attribute);
                    }
                }

                if (!data["members"][i]["spellBook"].is_null() && data["members"][i]["spellBook"].is_array() && data["members"][i]["spellBook"].size() > 0)
                {
                    for (auto j = 0; j < data["members"][i]["spellBook"].size(); j++)
                    {
                        auto spell = Spells::Base();

                        spell.Name = !data["members"][i]["spellBook"][j]["name"].is_null() ? data["members"][i]["spellBook"][j]["name"] : "";
                        spell.Description = !data["members"][i]["spellBook"][j]["description"].is_null() ? data["members"][i]["spellBook"][j]["description"] : "";
                        spell.Scope = !data["members"][i]["spellBook"][j]["scope"].is_null() ? static_cast<Spells::Scope>((int)data["members"][i]["spellBook"][j]["scope"]) : spell.Scope;
                        spell.Type = !data["members"][i]["spellBook"][j]["type"].is_null() ? static_cast<Spells::Type>((int)data["members"][i]["spellBook"][j]["type"]) : spell.Type;
                        spell.Charged = !data["members"][i]["spellBook"][j]["charged"].is_null() ? (bool)data["members"][i]["spellBook"][j]["charged"] : spell.Charged;
                        spell.Recharge = !data["members"][i]["spellBook"][j]["recharge"].is_null() ? (int)data["members"][i]["spellBook"][j]["recharge"] : spell.Recharge;

                        character.SpellBook.push_back(spell);
                    }
                }

                if (!data["members"][i]["followers"].is_null() && data["members"][i]["followers"].is_array() && data["members"][i]["followers"].size() > 0)
                {
                    for (auto j = 0; j < data["members"][i]["followers"].size(); j++)
                    {
                        auto follower = Follower::Base();

                        follower.Name = !data["members"][i]["followers"][j]["name"].is_null() ? data["members"][i]["followers"][j]["name"] : "";
                        follower.Type = !data["members"][i]["followers"][j]["type"].is_null() ? static_cast<Follower::Type>((int)data["followers"][i]["followers"][j]["type"]) : follower.Type;
                        follower.Health = !data["members"][i]["followers"][j]["health"].is_null() ? (int)data["members"][i]["followers"][j]["health"] : follower.Health;

                        character.Followers.push_back(follower);
                    }
                }

                if (!data["members"][i]["status"].is_null() && data["members"][i]["status"].is_array() && data["members"][i]["status"].size() > 0)
                {
                    for (auto j = 0; j < data["members"][i]["status"].size(); j++)
                    {
                        if (!data["members"][i]["status"].is_null())
                        {
                            character.Status.push_back(static_cast<Character::Status>((int)data["members"][i]["status"][j]));
                        }
                    }
                }

                party.Members.push_back(character);
            }
        }

        // codes
        if (!data["codes"].is_null() && data["codes"].is_array() && data["codes"].size() > 0)
        {
            for (auto i = 0; i < data["codes"].size(); i++)
            {
                auto code = Codes::Base();

                code.Type = !data["codes"][i]["type"].is_null() ? static_cast<Book::Type>((int)data["codes"][i]["type"]) : code.Type;
                code.Code = !data["codes"][i]["code"].is_null() ? (int)data["codes"][i]["code"] : code.Code;

                party.Codes.push_back(code);
            }
        }

        // vault equipment
        if (!data["vault"].is_null() && data["vault"].is_array() && data["vault"].size() > 0)
        {
            for (auto i = 0; i < data["vault"].size(); i++)
            {
                auto equipment = Equipment::Base();

                equipment.Name = !data["vault"][i]["name"].is_null() ? data["vault"][i]["name"] : "";
                equipment.Description = !data["vault"][i]["description"].is_null() ? data["vault"][i]["description"] : "";
                equipment.Class = !data["vault"][i]["class"].is_null() ? static_cast<Equipment::Class>((int)data["vault"][i]["class"]) : equipment.Class;
                equipment.Type = !data["vault"][i]["type"].is_null() ? static_cast<Equipment::Type>((int)data["vault"][i]["type"]) : equipment.Type;
                equipment.Attribute = !data["vault"][i]["attribute"].is_null() ? static_cast<Attribute::Type>((int)data["vault"][i]["attribute"]) : equipment.Attribute;
                equipment.Modifier = !data["vault"][i]["modifier"].is_null() ? (int)data["vault"][i]["modifier"] : equipment.Modifier;
                equipment.TwoHanded = !data["vault"][i]["twoHanded"].is_null() ? (bool)data["vault"][i]["twoHanded"] : equipment.TwoHanded;
                equipment.AdditionalSlots = !data["vault"][i]["additionalSlots"].is_null() ? (int)data["vault"][i]["additionalSlots"] : equipment.AdditionalSlots;
                equipment.Value = !data["vault"][i]["value"].is_null() ? (int)data["vault"][i]["value"] : equipment.Value;

                party.Vault.push_back(equipment);
            }
        }

        // fleet
        if (!data["fleet"].is_null() && data["fleet"].is_array() && data["fleet"].size() > 0)
        {
            for (auto i = 0; i < data["fleet"].size(); i++)
            {
                auto ship = Ship::Base();

                ship.Name = !data["fleet"][i]["name"].is_null() ? data["fleet"][i]["name"] : "";
                ship.Type = !data["fleet"][i]["type"].is_null() ? static_cast<Ship::Type>((int)data["fleet"][i]["type"]) : ship.Type;
                ship.Location = !data["fleet"][i]["location"].is_null() ? static_cast<Location::Type>((int)data["fleet"][i]["location"]) : ship.Location;
                ship.Fighting = !data["fleet"][i]["fighting"].is_null() ? (int)data["fleet"][i]["fighting"] : ship.Fighting;
                ship.Health = !data["fleet"][i]["health"].is_null() ? (int)data["fleet"][i]["health"] : ship.Health;
                ship.MaximumHealth = !data["fleet"][i]["maximumHealth"].is_null() ? (int)data["fleet"][i]["maximumHealth"] : ship.MaximumHealth;
                ship.MaximumCargo = !data["fleet"][i]["maximumCargo"].is_null() ? (int)data["fleet"][i]["maximumCargo"] : ship.MaximumCargo;

                if (!data["fleet"][i]["cargo"].is_null() && data["fleet"][i]["cargo"].is_array() && data["fleet"][i]["cargo"].size() > 0)
                {
                    for (auto j = 0; j < data["fleet"][i]["cargo"].size(); j++)
                    {
                        if (!data["fleet"][i]["cargo"][j].is_null())
                        {
                            ship.Cargo.push_back(static_cast<Cargo::Type>((int)data["fleet"][i]["cargo"][j]));
                        }
                    }
                }

                party.Fleet.push_back(ship);
            }
        }

        // army
        if (!data["army"].is_null() && data["army"].is_array() && data["army"].size() > 0)
        {
            for (auto i = 0; i < data["army"].size(); i++)
            {
                auto unit = Army::Base();

                unit.Name = !data["army"][i]["name"].is_null() ? data["army"][i]["name"] : "";
                unit.Type = !data["army"][i]["type"].is_null() ? static_cast<Army::Type>((int)data["army"][i]["type"]) : unit.Type;
                unit.Garrison = !data["army"][i]["garrison"].is_null() ? static_cast<Location::Type>((int)data["army"][i]["garrison"]) : unit.Garrison;
                unit.Strength = !data["army"][i]["strength"].is_null() ? (int)data["army"][i]["strength"] : unit.Strength;
                unit.MaximumStrength = !data["army"][i]["maximumStrength"].is_null() ? (int)data["army"][i]["maximumStrength"] : unit.MaximumStrength;
                unit.Morale = !data["army"][i]["morale"].is_null() ? (int)data["army"][i]["morale"] : unit.Morale;
                unit.MaximumMorale = !data["army"][i]["maximumMorale"].is_null() ? (int)data["army"][i]["maximumMorale"] : unit.MaximumMorale;
                unit.Unique = !data["army"][i]["unique"].is_null() ? (bool)data["army"][i]["unique"] : unit.Unique;
                unit.Position = !data["army"][i]["position"].is_null() ? static_cast<Location::BattleField>((int)data["army"][i]["position"]) : unit.Position;
                unit.Status = !data["army"][i]["status"].is_null() ? static_cast<Army::Status>((int)data["army"][i]["status"]) : unit.Status;
                unit.StatusRound = !data["army"][i]["statusRound"].is_null() ? (int)data["army"][i]["statusRound"] : unit.StatusRound;
                unit.StatusDuration = !data["army"][i]["statusDuration"].is_null() ? (int)data["army"][i]["statusDuration"] : unit.StatusDuration;

                party.Army.push_back(unit);
            }
        }

        // dead characters
        if (!data["dead"].is_null() && data["dead"].is_array() && data["dead"].size() > 0)
        {
            for (auto i = 0; i < data["dead"].size(); i++)
            {
                if (!data["dead"][i].is_null())
                {
                    party.Dead.push_back(static_cast<Character::Type>((int)data["dead"][i]));
                }
            }
        }

        // invisible codes, i.e. notes
        if (!data["invisibleCodes"].is_null() && data["invisibleCodes"].is_array() && data["invisibleCodes"].size() > 0)
        {
            for (auto i = 0; i < data["invisibleCodes"].size(); i++)
            {
                if (!data["invisibleCodes"][i].is_null())
                {
                    party.InvisibleCodes.push_back(static_cast<Codes::Type>((int)data["invisibleCodes"][i]));
                }
            }
        }

        // last party members selected on a skill check
        if (!data["lastSelection"].is_null() && data["lastSelection"].is_array() && data["lastSelection"].size() > 0)
        {
            for (auto i = 0; i < data["lastSelection"].size(); i++)
            {
                if (!data["lastSelection"][i].is_null())
                {
                    party.LastSelection.push_back((int)data["lastSelection"][i]);
                }
            }
        }

        // order of party members attempting to accomplish a task
        if (!data["order"].is_null() && data["order"].is_array() && data["order"].size() > 0)
        {
            for (auto i = 0; i < data["order"].size(); i++)
            {
                if (!data["order"][i].is_null())
                {
                    party.Order.push_back(static_cast<Character::Type>((int)data["order"][i]));
                }
            }
        }

        // romance histogram
        if (!data["hearts"].is_null() && data["hearts"].is_array() && data["hearts"].size() > 0)
        {
            for (auto i = 0; i < data["hearts"].size(); i++)
            {
                if (!data["hearts"][i].is_null() && data["hearts"][i].is_array() && data["hearts"][i].size() >= 3)
                {
                    auto from = static_cast<Character::Type>((int)data["hearts"][i][0]);
                    auto to = static_cast<Character::Type>((int)data["hearts"][i][1]);
                    auto hearts = (int)data["hearts"][i][2];

                    Engine::GAIN_HEARTS(party, from, to, hearts);
                }
            }
        }
    }

    return party;
}

#if defined(_WIN32) || defined(__arm__) || defined(__APPLE__)
std::string time_string(long long deserialised)
{
    auto epoch = std::chrono::time_point<std::chrono::system_clock>();
    auto since_epoch = std::chrono::milliseconds(deserialised);
    std::chrono::system_clock::time_point timestamp = epoch + since_epoch;

    auto in_time_t = std::chrono::system_clock::to_time_t(timestamp);

    std::stringstream ss;

    if (in_time_t >= 0)
    {
        ss << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d %X");
    }

    return ss.str();
}
#else
std::string time_string(long deserialised)
{
    auto epoch = std::chrono::time_point<std::chrono::high_resolution_clock>();
    auto since_epoch = std::chrono::milliseconds(deserialised);
    auto timestamp = epoch + since_epoch;

    auto in_time_t = std::chrono::system_clock::to_time_t(timestamp);

    std::stringstream ss;

    ss << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d %X");

    return ss.str();
}
#endif

std::string previewGame(std::string file_name)
{
    std::string preview = "";

    std::ifstream ifs(file_name);

    if (ifs.good())
    {
        auto data = nlohmann::json::parse(ifs);

        ifs.close();

        auto location = !data["location"].is_null() ? static_cast<Location::Type>((int)data["location"]) : Location::Type::NONE;
        auto money = !data["money"].is_null() ? (int)data["money"] : 0;
        auto book = !data["book"].is_null() ? static_cast<Book::Type>((int)data["book"]) : Book::Type::NONE;

#if defined(_WIN32) || defined(__arm__)
        auto epoch = !data["epoch"].is_null() ? (long long)(data["epoch"]) : 0;
#else
        auto epoch = !data["epoch"].is_null() ? (long)(data["epoch"]) : 0;
#endif

        preview = std::string(Book::Title[book]) + ": " + std::string(Location::Description[location]) + ", " + std::to_string(money) + " silver coins";

        // get names
        if (!data["members"].is_null() && data["members"].is_array() && data["members"].size() > 0)
        {
            preview += "\nParty: ";

            auto names = 0;

            for (auto i = 0; i < data["members"].size(); i++)
            {
                std::string name = !data["members"][i]["name"].is_null() ? data["members"][i]["name"] : "";

                if (name.length() > 0)
                {
                    if (names > 0)
                    {
                        preview += ", ";
                    }

                    preview += name;

                    names += 1;
                }
            }
        }

        preview += "\n" + time_string(epoch);
    }

    return preview;
}

std::string miniPreview(std::string file_name)
{
    std::string preview = "";

    std::ifstream ifs(file_name);

    if (ifs.good())
    {
        auto data = nlohmann::json::parse(ifs);

        ifs.close();

        auto location = !data["location"].is_null() ? static_cast<Location::Type>((int)data["location"]) : Location::Type::NONE;

#if defined(_WIN32) || defined(__arm__)
        auto epoch = !data["epoch"].is_null() ? (long long)(data["epoch"]) : 0;
#else
        auto epoch = !data["epoch"].is_null() ? (long)(data["epoch"]) : 0;
#endif

        preview = std::string(Location::Description[location]);

        // get names
        if (!data["members"].is_null() && data["members"].is_array() && data["members"].size() > 0)
        {
            preview += "\n";

            auto names = 0;

            for (auto i = 0; i < data["members"].size(); i++)
            {
                std::string name = !data["members"][i]["name"].is_null() ? data["members"][i]["name"] : "";

                if (name.length() > 0)
                {
                    if (names > 0)
                    {
                        preview += ", ";
                    }

                    preview += name;

                    names += 1;
                }
            }
        }

        preview += "\n" + time_string(epoch);
    }

    return preview;
}

std::vector<Button> createFileList(SDL_Window *window, SDL_Renderer *renderer, std::vector<std::string> list, int start, int last, int limit, int offsetx, int offsety, bool save_button)
{
    auto controls = std::vector<Button>();

    if (list.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto preview = previewGame(list[i]);

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, preview.c_str(), clrBK, intBE, list_buttonw, 100, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (list.size() > limit)
    {
        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, scrollx, texty + border_space, Control::Type::SCROLL_UP));

            idx += 1;
        }

        if (list.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, scrollx, scrolly, Control::Type::SCROLL_DOWN));

            idx += 1;
        }
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/open.png", idx, idx + 1, list.size() > 0 ? (last - start) - 1 : idx, idx, textx, buttony, Control::Type::LOAD));

    if (save_button)
    {
        idx = controls.size();

        controls.push_back(Button(idx, "icons/disk.png", idx - 1, idx + 1, list.size() > 0 ? (last - start) - 1 : idx, idx, textx + gridsize, buttony, Control::Type::SAVE));
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/no.png", idx - 1, idx + 1, list.size() > 0 ? (last - start) - 1 : idx, idx, (save_button ? (textx + 2 * gridsize) : (textx + gridsize)), buttony, Control::Type::DELETE));

    controls.push_back(Button(idx + 1, "icons/back-button.png", idx, idx + 1, list.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, lastx, buttony, Control::Type::BACK));

    return controls;
}

Control::Type gameScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, bool save_button)
{
    auto result = Control::Type::BACK;

    if (window && renderer)
    {
        auto save = getSavePath();

        std::string path = save + "/";

        fs::create_directories(save);

        auto splash = createImage("images/legendary-kingdoms-logo-bw.png");

        auto entries = std::vector<std::string>();

        auto saved_games = std::multimap<std::filesystem::file_time_type, std::string, std::greater<std::filesystem::file_time_type>>();

        try
        {
            for (const auto &entry : fs::directory_iterator(path))
            {
                auto time_stamp = entry.last_write_time();

#if defined(_WIN32) || defined(__arm__)
                std::string file_name = entry.path().string();
#else
                std::string file_name = entry.path();
#endif

                if (file_name.substr(file_name.find_last_of(".") + 1) == "save")
                {
                    saved_games.insert(std::make_pair(time_stamp, file_name));
                }
            }
        }
        catch (std::exception &ex)
        {
            Sound::Play(Sound::Type::ERROR);

            std::cerr << "Unable to read save directory!" << std::endl;
        }

        for (auto const &entry : saved_games)
        {
            entries.push_back(entry.second);
        }

        auto fg = Color::HEADER(party.Book);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
        auto font_garamond2 = TTF_OpenFont(FONT_GARAMOND, 22);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);
        auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);

        TTF_SetFontKerning(font_dark11, 0);

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (124);
        auto last = offset + limit;

        if (last > entries.size())
        {
            last = entries.size();
        }

        auto popupw = (int)(0.6 * SCREEN_WIDTH);
        auto popuph = (int)(0.6 * SCREEN_HEIGHT);
        auto popupx = (SCREEN_WIDTH - popupw) / 2;
        auto popupy = ((starty + text_bounds) - popuph) / 2;

        auto controls = std::vector<Button>();
        auto controls_normal = createFileList(window, renderer, entries, offset, last, limit, textx, texty + infoh, save_button);
        auto controls_confirm = popupConfirm(popupw, popuph, popupx, popupy);

        auto current = -1;
        auto selected = false;
        auto scrollUp = false;
        auto scrollDown = false;
        auto hold = false;
        auto scrollSpeed = 1;

        auto selection = -1;

        auto done = false;

        std::string message = "";

        auto flash_message = false;

        auto flash_color = intRD;

        Uint32 start_ticks = 0;

        Uint32 duration = 3000;

        auto displayMessage = [&](std::string msg, Uint32 color)
        {
            flash_message = true;

            message = msg;

            flash_color = color;

            start_ticks = SDL_GetTicks();
        };

        auto current_mode = Control::Type::GAME;

        while (!done)
        {
            if (save_button)
            {
                SDL_SetWindowTitle(window, "Legendary Kingdoms: Load/Save Game");
            }
            else
            {
                SDL_SetWindowTitle(window, "Legendary Kingdoms: Load Game");
            }

            fillWindow(renderer, intWH);

            if (splash)
            {
                fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            if (current >= 0 && current < controls_normal.size() && current_mode == Control::Type::GAME)
            {
                if (selection >= 0 && selection < entries.size())
                {
                    if (controls_normal[current].Type == Control::Type::LOAD)
                    {
                        putText(renderer, "Load Game", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                    }
                    else if (controls_normal[current].Type == Control::Type::SAVE)
                    {
                        putText(renderer, "Overwrite Game", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                    }
                    else if (controls_normal[current].Type == Control::Type::DELETE)
                    {
                        putText(renderer, "Delete Game", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                    }
                    else
                    {
                        putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                    }
                }
                else
                {
                    if (controls_normal[current].Type == Control::Type::SAVE)
                    {
                        putText(renderer, "Save Game", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                    }
                    else
                    {
                        putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
                    }
                }
            }
            else
            {
                putText(renderer, "Selected", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh - 1));
            }

            if (selection >= 0 && selection < entries.size())
            {
                putText(renderer, miniPreview(entries[selection]).c_str(), font_garamond2, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }
            else
            {
                putText(renderer, "(None)", font_garamond2, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
            }

            putHeader(renderer, "Games", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

            fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, intBE);

            if (last - offset > 0)
            {
                for (auto i = 0; i < last - offset; i++)
                {
                    if (selection == offset + i)
                    {
                        thickRect(renderer, controls_normal[i].W + border_pts, controls_normal[i].H + border_pts, controls_normal[i].X - 2, controls_normal[i].Y - 2, intLB, 2);
                    }
                    else
                    {
                        drawRect(renderer, controls_normal[i].W + border_space, controls_normal[i].H + border_space, controls_normal[i].X - border_pts, controls_normal[i].Y - border_pts, intBK);
                    }
                }
            }

            if (current_mode == Control::Type::GAME)
            {
                controls = controls_normal;
            }
            else if (current_mode == Control::Type::CONFIRM)
            {
                renderButtons(renderer, controls_normal, -1, intLB, border_space, border_pts);

                fillRect(renderer, popupw, popuph, popupx, popupy, intBE);

                drawRect(renderer, popupw, popuph, popupx, popupy, intBK);

                putHeader(renderer, "Are you sure?", font_dark11, text_space, clrWH, intDB, TTF_STYLE_NORMAL, popupw, infoh, popupx, popupy);

                putText(renderer, "You are about to delete this game. All accumulated progress and resources will be lost forever.", font_garamond, -1, clrBK, intBE, TTF_STYLE_NORMAL, popupw - 2 * text_space, popuph - infoh - 2 * text_space, popupx + text_space, popupy + infoh + text_space);

                controls = controls_confirm;
            }
            else
            {
                controls = controls_normal;
            }

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            if (current >= 0 && current < controls.size() && current_mode != Control::Type::CONFIRM)
            {
                renderCaption(renderer, font_caption, controls[current]);
            }

            if (flash_message)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw * 2, infoh * 2, -1, -1);
                }
                else
                {
                    flash_message = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    if (current_mode == Control::Type::GAME)
                    {
                        result = Control::Type::BACK;

                        done = true;
                    }
                    else
                    {
                        current_mode = Control::Type::GAME;
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    if (current + offset >= 0 && current < entries.size())
                    {
                        if (selection == current + offset)
                        {
                            selection = -1;
                        }
                        else
                        {
                            selection = current + offset;
                        }
                    }

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (current_mode == Control::Type::GAME)
                    {
                        if (offset > 0)
                        {
                            offset -= scrollSpeed;

                            if (offset < 0)
                            {
                                offset = 0;
                            }

                            last = offset + limit;

                            if (last > entries.size())
                            {
                                last = entries.size();
                            }

                            controls_normal = createFileList(window, renderer, entries, offset, last, limit, textx, texty + infoh, save_button);

                            SDL_Delay(50);
                        }

                        if (offset <= 0)
                        {
                            current = -1;

                            selected = false;
                        }
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (current_mode == Control::Type::GAME)
                    {
                        if (entries.size() - last > 0)
                        {
                            if (offset < entries.size() - limit)
                            {
                                offset += scrollSpeed;
                            }

                            if (offset > entries.size() - limit)
                            {
                                offset = entries.size() - limit;
                            }

                            last = offset + limit;

                            if (last > entries.size())
                            {
                                last = entries.size();
                            }

                            controls_normal = createFileList(window, renderer, entries, offset, last, limit, textx, texty + infoh, save_button);

                            SDL_Delay(50);

                            if (offset > 0)
                            {
                                current = FIND_CONTROL(controls_normal, Control::Type::SCROLL_DOWN);
                            }
                        }

                        if (entries.size() - last <= 0)
                        {
                            selected = false;

                            current = -1;
                        }
                    }
                }
                else if (controls[current].Type == Control::Type::SAVE && !hold)
                {
                    if (selection >= 0 && selection < entries.size())
                    {
                        saveGame(party, entries[selection].c_str());
                    }
                    else
                    {
                        saveGame(party, NULL);
                    }

                    result = Control::Type::SAVE;

                    done = true;

                    current = -1;

                    selected = false;

                    Sound::Play(Sound::Type::SUCCESS);
                }
                else if (controls[current].Type == Control::Type::LOAD && !hold)
                {
                    if (selection >= 0 && selection < entries.size())
                    {
                        party = loadGame(entries[selection]);

                        result = Control::Type::LOAD;

                        done = true;

                        Sound::Play(Sound::Type::SUCCESS);
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("Please select a game to load!", intRD);
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::DELETE && !hold)
                {
                    if (selection >= 0 && selection < entries.size())
                    {
                        if (current_mode == Control::Type::GAME)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            current_mode = Control::Type::CONFIRM;
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);
                        }
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);

                        displayMessage("Please select a game to delete!", intRD);
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                {
                    if (current_mode == Control::Type::CONFIRM)
                    {
                        auto del = fs::remove(entries[selection]);

                        if (del)
                        {
                            Sound::Play(Sound::Type::FAIL);

                            displayMessage("Game Deleted", intLB);

                            entries.erase(entries.begin() + selection);

                            if (offset > 0)
                            {
                                offset -= 1;
                            }

                            last = offset + limit;

                            if (last > entries.size())
                            {
                                last = entries.size();
                            }

                            controls_normal = createFileList(window, renderer, entries, offset, last, limit, textx, texty + infoh, save_button);

                            selection = -1;

                            SDL_Delay(50);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("Game not removed!", intRD);
                        }

                        current_mode = Control::Type::GAME;
                    }
                    else
                    {
                        Sound::Play(Sound::Type::ERROR);
                    }
                }
            }
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_garamond2)
        {
            TTF_CloseFont(font_garamond2);

            font_garamond2 = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_dark11 = NULL;
        }

        if (font_caption)
        {
            TTF_CloseFont(font_caption);

            font_caption = NULL;
        }

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    return result;
}

Story::Base *processChoices(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Story::Base *story)
{
    Story::Base *next = &Story::notImplemented;

    auto error = false;
    std::string message = "";

    Uint32 start_ticks = 0;
    Uint32 duration = 3000;

    SDL_Surface *background = NULL;

    if (renderer && story->Choices.size() > 0)
    {
        SDL_Surface *splash = NULL;
        SDL_Texture *splashTexture = NULL;

        if (story->Image)
        {
            splash = createImage(story->Image);
        }

        auto selected = false;
        auto current = -1;
        auto done = false;
        auto scrollUp = false;
        auto scrollDown = false;
        auto hold = false;
        auto scrollSpeed = 1;

        auto offset = 0;
        auto limit = (text_bounds - 2 * text_space - infoh) / (96);
        auto last = offset + limit;

        if (last > story->Choices.size())
        {
            last = story->Choices.size();
        }

        auto controls = createChoices(window, renderer, story->Choices, offset, last, limit, textx, texty);

        auto fg = Color::HEADER(story->BookID);

        TTF_Init();

        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, 28);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_mason2 = TTF_OpenFont(FONT_MASON, 28);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);
        auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);

        TTF_SetFontKerning(font_dark11, 0);

        auto splash_h = splashw;

        if (splash)
        {
            if (splash->w != splashw)
            {
                splash_h = (int)((double)splashw / splash->w * splash->h);
            }

            splashTexture = SDL_CreateTextureFromSurface(renderer, splash);
        }

        while (!done)
        {
            if (story->Title)
            {
                SDL_SetWindowTitle(window, story->Title);
            }
            else
            {
                if (story->ID != -1)
                {
                    auto storyID = story->ID;

                    if (storyID < 0 && story->DisplayID >= 0)
                    {
                        storyID = story->DisplayID;
                    }

                    std::string title_string = "Legendary Kingdoms - " + std::string(Book::Title[story->BookID]) + ": ";

                    SDL_SetWindowTitle(window, (title_string + std::string(3 - std::to_string(std::abs(storyID)).length(), '0') + std::to_string(std::abs(storyID))).c_str());
                }
                else
                {
                    std::string title_string = "Legendary Kingdoms - " + std::string(Book::Title[story->BookID]) + ": Not Implemented Yet";

                    SDL_SetWindowTitle(window, title_string.c_str());
                }
            }

            fillWindow(renderer, intWH);

            if (background)
            {
                stretchImage(renderer, background, 0, 0, SCREEN_WIDTH, buttony - button_space);
            }

            if (splash)
            {
                splash_h = fitImage(renderer, splash, startx, starty, splashw, text_bounds);
            }

            if (!splash || (splash && splash_h < (text_bounds - 2 * boxh - infoh)))
            {
                putHeader(renderer, "Party", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

                if (Engine::COUNT(party) > 0)
                {
                    std::string party_string = "";

                    auto count = 0;

                    for (auto i = 0; i < party.Members.size(); i++)
                    {
                        if (count > 0)
                        {
                            party_string += "\n";
                        }

                        party_string += party.Members[i].Name;

                        if (Engine::IS_DEAD(party.Members[i]))
                        {
                            party_string += " (D)";
                        }
                        else if (Engine::IS_CURSED(party.Members[i]))
                        {
                            party_string += " (C)";
                        }

                        count += 1;
                    }

                    putText(renderer, party_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
                }
            }

            if (!splash)
            {
                std::string title_string = std::string(Book::Title[story->BookID]) + "\n";

                if (story->ID != -1)
                {
                    auto storyID = story->ID;

                    if (storyID < 0 && story->DisplayID >= 0)
                    {
                        storyID = story->DisplayID;
                    }

                    title_string += std::string(3 - std::to_string(std::abs(storyID)).length(), '0') + std::to_string(std::abs(storyID));

                    putText(renderer, title_string.c_str(), font_mason2, text_space, clrBK, intWH, TTF_STYLE_NORMAL, splashw, infoh, startx, starty);
                }
                else
                {
                    title_string += "Not Implemented";

                    putText(renderer, title_string.c_str(), font_mason2, text_space, clrBK, intWH, TTF_STYLE_NORMAL, splashw, infoh, startx, starty);
                }
            }

            if ((!splash || (splash && splash_h < (text_bounds - 4 * boxh - 2 * infoh - box_space))) && (Engine::COUNT_TEAMS(party) > 0 || story->Team != Team::Type::NONE))
            {
                std::vector<Team::Type> teams = {};

                if (Engine::IS_ACTIVE(party, party.CurrentCharacter) || story->Team != Team::Type::NONE)
                {
                    putHeader(renderer, "Current", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (4 * boxh + 2 * infoh + box_space));

                    if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                    {
                        teams.push_back(Engine::GET_TEAM(party.Members[party.CurrentCharacter]));
                    }
                    else
                    {
                        teams.push_back(story->Team);
                    }
                }
                else
                {
                    putHeader(renderer, "Teams", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (4 * boxh + 2 * infoh + box_space));

                    teams = Engine::GET_TEAMS(party);
                }

                if (teams.size() > 0)
                {
                    std::string teams_string = "";

                    for (auto i = 0; i < teams.size(); i++)
                    {
                        if (i > 0)
                        {
                            teams_string += ", ";
                        }

                        teams_string += Team::Descriptions[teams[i]];
                    }

                    putText(renderer, teams_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 4 * boxh - infoh - box_space);
                }
                else
                {
                    fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 4 * boxh - infoh - box_space, intBE);
                }
            }
            else if (!splash || (splash && splash_h < (text_bounds - 3 * boxh - 2 * infoh - box_space)))
            {
                putHeader(renderer, "Money", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space));

                putText(renderer, (std::to_string(party.Money) + " silver coins").c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + text_bounds - 3 * boxh - infoh - box_space);
            }

            fillRect(renderer, textwidth, text_bounds, textx, texty, BE_80);

            renderButtons(renderer, controls, current, intLB, text_space, border_pts);

            if (current >= 0 && current < controls.size() && !selected)
            {
                renderCaption(renderer, font_caption, controls[current]);
            }

            for (auto i = offset; i < last; i++)
            {
                auto index = i - offset;

                if (current != index)
                {
                    if (index >= 0 && index < controls.size())
                    {
                        drawRect(renderer, controls[index].W + (2 * text_space), controls[index].H + (2 * text_space), controls[index].X - text_space, controls[index].Y - text_space, intBK);
                    }
                }
            }

            if (splash)
            {
                auto mousex = 0;
                auto mousey = 0;

                SDL_GetMouseState(&mousex, &mousey);

                auto zoomw = (int)(0.80 * (double)textwidth);
                auto zoomh = (int)(0.80 * (double)text_bounds);

                clipValue(zoomw, 0, splash->w);
                clipValue(zoomh, 0, splash->h);

                auto boundx = splashw;

                if (splash_h == text_bounds)
                {
                    boundx = (int)((double)splash_h / splash->h * (double)splash->w);
                }

                if (mousex >= startx && mousex <= (startx + boundx) && mousey >= starty && mousey <= (starty + splash_h))
                {
                    auto scalex = (double)(mousex - startx) / boundx;
                    auto scaley = (double)(mousey - starty) / splash_h;

                    auto centerx = (int)(scalex * (double)splash->w);
                    auto centery = (int)(scaley * (double)splash->h);

                    clipValue(centerx, zoomw / 2, splash->w - zoomw / 2);
                    clipValue(centery, zoomh / 2, splash->h - zoomh / 2);

                    if (splashTexture)
                    {
                        SDL_Rect src;

                        src.w = zoomw;
                        src.h = zoomh;
                        src.x = centerx - zoomw / 2;
                        src.y = centery - zoomh / 2;

                        SDL_Rect dst;

                        dst.w = zoomw;
                        dst.h = zoomh;
                        dst.x = (textx + (textwidth - zoomw) / 2);
                        dst.y = (texty + (text_bounds - zoomh) / 2);

                        fillRect(renderer, dst.w, dst.h, dst.x, dst.y, intWH);
                        SDL_RenderCopy(renderer, splashTexture, &src, &dst);
                        drawRect(renderer, dst.w + 2, dst.h + 2, dst.x - 1, dst.y - 1, intBK);
                    }
                }
            }

            if (error)
            {
                if ((SDL_GetTicks() - start_ticks) < duration)
                {
                    putHeader(renderer, message.c_str(), font_garamond, text_space, clrWH, intRD, TTF_STYLE_NORMAL, splashw * 2, boxh * 2, -1, -1);
                }
                else
                {
                    error = false;
                }
            }

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if ((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold)
            {
                if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                {
                    if (offset > 0)
                    {
                        offset -= scrollSpeed;

                        if (offset < 0)
                        {
                            offset = 0;
                        }

                        last = offset + limit;

                        if (last > story->Choices.size())
                        {
                            last = story->Choices.size();
                        }

                        controls = createChoices(window, renderer, story->Choices, offset, last, limit, textx, texty);

                        SDL_Delay(50);
                    }

                    if (offset <= 0)
                    {
                        current = -1;

                        selected = false;
                    }
                }
                else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                {
                    if (story->Choices.size() - last > 0)
                    {
                        if (offset < story->Choices.size() - limit)
                        {
                            offset += scrollSpeed;
                        }

                        if (offset > story->Choices.size() - limit)
                        {
                            offset = story->Choices.size() - limit;
                        }

                        last = offset + limit;

                        if (last > story->Choices.size())
                        {
                            last = story->Choices.size();
                        }

                        controls = createChoices(window, renderer, story->Choices, offset, last, limit, textx, texty);

                        SDL_Delay(50);

                        if (offset > 0)
                        {
                            current = FIND_CONTROL(controls, Control::Type::SCROLL_DOWN);
                        }
                    }

                    if (story->Choices.size() - last <= 0)
                    {
                        selected = false;

                        current = -1;
                    }
                }
                else if (controls[current].Type == Control::Type::ACTION && !hold)
                {
                    auto choice = current + offset;

                    if (choice >= 0 && choice < story->Choices.size())
                    {
                        if (story->Choices[choice].Type == Choice::Type::NORMAL)
                        {
                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::RESET_SHOP)
                        {
                            story->ResetShop = true;

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::ATTRIBUTES)
                        {
                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            auto selection = std::vector<int>();

                            auto success = false;

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter) && party.Members[party.CurrentCharacter].Team == Team::Type::SOLO)
                            {
                                selection = {party.CurrentCharacter};

                                success = skillTestScreen(window, renderer, party, story->Choices[choice].Team, selection, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, story->Choices[choice].UseWeapon);
                            }
                            else
                            {
                                success = skillCheck(window, renderer, party, story->Choices[choice].Team, 1, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, selection, story->Choices[choice].UseWeapon);
                            }

                            if (success || (selection.size() == 1))
                            {
                                story->SkillCheck(party, success, selection);

                                if (success)
                                {
                                    next = findStory(story->Choices[choice].Destination);
                                }
                                else
                                {
                                    next = findStory(story->Choices[choice].DestinationFailed);
                                }

                                done = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::EVERYONE_SKILL_CHECKS)
                        {
                            if (Engine::COUNT(party, story->Choices[choice].Team) > 0)
                            {
                                for (auto i = 0; i < party.Members.size(); i++)
                                {
                                    if (Engine::IS_ACTIVE(party, i) && (story->Choices[choice].Team == Team::Type::NONE || party.Members[i].Team == story->Choices[choice].Team))
                                    {
                                        auto success = skillTestScreen(window, renderer, party, story->Choices[choice].Team, {i}, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, story->Choices[choice].UseWeapon);

                                        story->SkillCheck(party, success, {i});
                                    }
                                }
                            }

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::LAST_CHARACTER)
                        {
                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            auto selection = std::vector<int>();

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                party.LastSelected = party.CurrentCharacter;
                            }

                            auto success = false;

                            if (Engine::IS_ACTIVE(party, party.LastSelected))
                            {
                                if (Engine::IS_ALIVE(party.Members[party.LastSelected]))
                                {
                                    selection.push_back(party.LastSelected);

                                    success = skillTestScreen(window, renderer, party, story->Choices[choice].Team, selection, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, story->Choices[choice].UseWeapon);
                                }
                                else
                                {
                                    success = skillCheck(window, renderer, party, story->Choices[choice].Team, 1, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, selection, story->Choices[choice].UseWeapon);
                                }
                            }
                            else
                            {
                                success = skillCheck(window, renderer, party, story->Choices[choice].Team, 1, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, selection, story->Choices[choice].UseWeapon);
                            }

                            if (success || selection.size() == 1)
                            {
                                story->SkillCheck(party, success, selection);

                                if (success)
                                {
                                    next = findStory(story->Choices[choice].Destination);
                                }
                                else
                                {
                                    next = findStory(story->Choices[choice].DestinationFailed);
                                }

                                done = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::ORDER_SKILL_CHECK)
                        {
                            if (party.Order.size() > 0 && ((story->Choices[choice].Value - 1) >= 0) && ((story->Choices[choice].Value - 1) < party.Order.size()))
                            {
                                party.LastSelected = Engine::FIND_CHARACTER(party, party.Order[story->Choices[choice].Value - 1]);
                            }
                            else
                            {
                                party.CurrentCharacter = Engine::FIND_SOLO(party);

                                if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                                {
                                    party.LastSelected = party.CurrentCharacter;
                                }
                            }

                            auto selection = std::vector<int>();

                            auto success = false;

                            if (Engine::IS_ACTIVE(party, party.LastSelected))
                            {
                                selection.push_back(party.LastSelected);

                                success = skillTestScreen(window, renderer, party, story->Choices[choice].Team, selection, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, story->Choices[choice].UseWeapon);
                            }
                            else
                            {
                                success = skillCheck(window, renderer, party, story->Choices[choice].Team, 1, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, selection, story->Choices[choice].UseWeapon);
                            }

                            if (success || selection.size() == 1)
                            {
                                story->SkillCheck(party, success, selection);

                                if (success)
                                {
                                    next = findStory(story->Choices[choice].Destination);
                                }
                                else
                                {
                                    next = findStory(story->Choices[choice].DestinationFailed);
                                }

                                done = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::TEAM_ATTRIBUTES)
                        {
                            auto selection = std::vector<int>();

                            auto success = skillCheck(window, renderer, party, story->Choices[choice].Team, 2, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, selection, story->Choices[choice].UseWeapon);

                            if (success || (selection.size() == 2 || (selection.size() > 0 && selection.size() >= Engine::COUNT(party, story->Choices[choice].Team))))
                            {
                                story->SkillCheck(party, success, selection);

                                if (success)
                                {
                                    next = findStory(story->Choices[choice].Destination);
                                }
                                else
                                {
                                    next = findStory(story->Choices[choice].DestinationFailed);
                                }

                                done = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::PARTY_EXCEPT_WITHSTATUS)
                        {
                            auto with_status = Engine::COUNT(party, story->Choices[choice].Status[0]);

                            auto party_count = Engine::COUNT(party, story->Choices[choice].Team);

                            auto team_size = std::min<int>(2, party_count - with_status);

                            if (team_size > 0)
                            {
                                auto selection = selectPartyMembers(window, renderer, party, story->Choices[choice].Team, team_size, Control::Type::SKILL);

                                if (selection.size() >= team_size)
                                {
                                    auto valid = true;

                                    for (auto i = 0; i < selection.size(); i++)
                                    {
                                        if (Engine::HAS_STATUS(party.Members[selection[i]], story->Choices[choice].Status[0]))
                                        {
                                            valid = false;
                                        }
                                    }

                                    if (valid)
                                    {
                                        auto success = skillTestScreen(window, renderer, party, story->Choices[choice].Team, selection, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, story->Choices[choice].UseWeapon);

                                        story->SkillCheck(party, success, selection);

                                        if (success)
                                        {
                                            next = findStory(story->Choices[choice].Destination);
                                        }
                                        else
                                        {
                                            next = findStory(story->Choices[choice].DestinationFailed);
                                        }

                                        done = true;
                                    }
                                    else
                                    {
                                        error = true;

                                        Sound::Play(Sound::Type::ERROR);

                                        if (selection.size() == 1)
                                        {
                                            message = "The party member selected is not valid";
                                        }
                                        else
                                        {
                                            message = "One of the party members selected is not valid";
                                        }
                                    }
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::EQUIPMENT)
                        {
                            auto equipment = std::vector<Equipment::Type>();

                            for (auto i = 0; i < story->Choices[choice].Equipment.size(); i++)
                            {
                                equipment.push_back(story->Choices[choice].Equipment[i].Type);
                            }

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                if (Engine::VERIFY_EQUIPMENT(party.Members[party.CurrentCharacter], equipment))
                                {
                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                                else
                                {
                                    error = true;

                                    if (story->Choices[choice].Equipment.size() > 1)
                                    {
                                        message = "You do not have the required items!";
                                    }
                                    else
                                    {
                                        message = "You do not have the required item!";
                                    }
                                }
                            }
                            else
                            {
                                if (Engine::VERIFY_EQUIPMENT(party, equipment))
                                {
                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                                else
                                {
                                    error = true;

                                    if (story->Choices[choice].Equipment.size() > 1)
                                    {
                                        message = "You do not have the required items!";
                                    }
                                    else
                                    {
                                        message = "You do not have the required item!";
                                    }
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::ANY_EQUIPMENT)
                        {
                            auto equipment = std::vector<Equipment::Type>();

                            for (auto i = 0; i < story->Choices[choice].Equipment.size(); i++)
                            {
                                equipment.push_back(story->Choices[choice].Equipment[i].Type);
                            }

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                if (Engine::VERIFY_ANY_EQUIPMENT(party.Members[party.CurrentCharacter], equipment))
                                {
                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                                else
                                {
                                    error = true;

                                    message = "You do not have any of the required items!";
                                }
                            }
                            else
                            {
                                if (Engine::VERIFY_ANY_EQUIPMENT(party, equipment))
                                {
                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                                else
                                {
                                    error = true;

                                    message = "You do not have any of the required items!";
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::SHIP)
                        {
                            auto location = story->Choices[choice].Location;

                            if (location == Location::Type::NONE)
                            {
                                location = party.Location;
                            }

                            if (Engine::HAS_SHIP(party, location))
                            {
                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                            else
                            {
                                error = true;

                                if (location != Location::Type::NONE)
                                {
                                    message = "You do not have a ship at " + std::string(Location::Description[location]);
                                }
                                else
                                {
                                    message = "You do not have a ship at this location!";
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::SAIL)
                        {
                            auto location = story->Choices[choice].Location;

                            if (location == Location::Type::NONE)
                            {
                                location = party.Location;
                            }

                            if (Engine::HAS_SHIP(party, location))
                            {
                                auto result = -1;

                                if (Engine::COUNT(party, location) == 1)
                                {
                                    result = Engine::FIND_SHIP(party, location);
                                }
                                else
                                {
                                    result = selectShip(window, renderer, party.Book, party.Fleet, story->Choices[choice].Location, {}, Control::Type::SAIL);
                                }

                                if (result >= 0 && result < party.Fleet.size())
                                {
                                    party.CurrentShip = result;

                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                            }
                            else
                            {
                                error = true;

                                if (location != Location::Type::NONE)
                                {
                                    message = "You do not have a ship at " + std::string(Location::Description[location]);
                                }
                                else
                                {
                                    message = "You do not have a ship at this location!";
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::TEAM_MAX_HEALTH)
                        {
                            auto target = std::vector<int>();

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                target = {party.CurrentCharacter};
                            }
                            else if (Engine::COUNT(party) == 1)
                            {
                                target = {Engine::FIRST(party)};
                            }
                            else
                            {
                                target = selectPartyMembers(window, renderer, party, story->Choices[choice].Team, story->Choices[choice].Value, Control::Type::RAISE_MAX_HEALTH);
                            }

                            if (target.size() > 0)
                            {
                                for (auto i = 0; i < target.size(); i++)
                                {
                                    if (target[i] >= 0 && target[i] < party.Members.size())
                                    {
                                        party.Members[target[i]].MaximumHealth += story->Choices[choice].Success;

                                        Engine::GAIN_HEALTH(party.Members[target[i]], story->Choices[choice].Success);
                                    }
                                }

                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::ADD_MAX_HEALTH)
                        {
                            auto target = -1;

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                target = party.CurrentCharacter;
                            }
                            else if (Engine::COUNT(party, story->Choices[choice].Team) == 1)
                            {
                                target = Engine::FIRST(party, story->Choices[choice].Team);
                            }
                            else
                            {
                                target = selectPartyMember(window, renderer, party, story->Choices[choice].Team, Equipment::NONE, Control::Type::HEALTH);
                            }

                            if (Engine::IS_ACTIVE(party, target))
                            {
                                Engine::GAIN_SCORE(party.Members[target], Attribute::Type::HEALTH, story->Choices[choice].Value);

                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::GAIN_HEALTH)
                        {
                            auto target = -1;

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                target = party.CurrentCharacter;
                            }
                            else
                            {
                                if (Engine::COUNT(party) == 1)
                                {
                                    target = Engine::FIRST(party);
                                }
                                else
                                {
                                    target = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, (story->Choices[choice].Value > 0 ? Control::Type::GAIN_HEALTH : Control::Type::LOSE_HEALTH));
                                }
                            }

                            if (target >= 0 && target < party.Members.size())
                            {
                                story->temp_string = party.Members[target].Name + " ";

                                if (story->Choices[choice].Value > 0)
                                {
                                    story->temp_string += "gains " + std::to_string(story->Choices[choice].Value);
                                }
                                else
                                {
                                    story->temp_string += "loses " + std::to_string(-story->Choices[choice].Value);
                                }

                                story->temp_string += " Health point";

                                if (std::abs(story->Choices[choice].Value) > 1)
                                {
                                    story->temp_string += "s";
                                }

                                story->temp_string += ".";

                                addBye(story, story->temp_string.c_str());

                                Engine::GAIN_HEALTH(party.Members[target], story->Choices[choice].Value);
                            }

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::GAIN_HEALTH_ATTRIBUTE)
                        {
                            auto target = -1;

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                target = party.CurrentCharacter;
                            }
                            else
                            {
                                if (Engine::COUNT(party) == 1)
                                {
                                    target = Engine::FIRST(party);
                                }
                                else
                                {
                                    target = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, (story->Choices[choice].Value > 0 ? Control::Type::GAIN_HEALTH : Control::Type::LOSE_HEALTH));
                                }
                            }

                            if (target >= 0 && target < party.Members.size())
                            {
                                story->temp_string = party.Members[target].Name + " ";

                                if (story->Choices[choice].Value > 0)
                                {
                                    story->temp_string += "gains " + std::to_string(story->Choices[choice].Value);
                                }
                                else
                                {
                                    story->temp_string += "loses " + std::to_string(-story->Choices[choice].Value);
                                }

                                story->temp_string += " Health point";

                                if (std::abs(story->Choices[choice].Value) > 1)
                                {
                                    story->temp_string += "s";
                                }

                                story->temp_string += " and ";

                                if (story->Choices[choice].Difficulty > 0)
                                {
                                    story->temp_string += "gains " + std::to_string(story->Choices[choice].Difficulty);
                                }
                                else
                                {
                                    story->temp_string += "loses " + std::to_string(-story->Choices[choice].Difficulty);
                                }

                                story->temp_string += " " + std::string(Attribute::Descriptions[story->Choices[choice].Attributes[0]]) + ".";

                                addBye(story, story->temp_string.c_str());

                                Engine::GAIN_HEALTH(party.Members[target], story->Choices[choice].Value);

                                Engine::GAIN_SCORE(party.Members[target], story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty);
                            }

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::BRIBE_CODEWORD_ITEM || story->Choices[choice].Type == Choice::Type::PAY_WITH)
                        {
                            auto equipment = std::vector<Equipment::Type>();

                            for (auto i = 0; i < story->Choices[choice].Equipment.size(); i++)
                            {
                                equipment.push_back(story->Choices[choice].Equipment[i].Type);
                            }

                            auto count = Engine::COUNT_EQUIPMENT(party, story->Choices[choice].Team, equipment);

                            if (count >= story->Choices[choice].Value)
                            {
                                Engine::LOSE_EQUIPMENT(party, story->Choices[choice].Team, equipment[0], story->Choices[choice].Value);

                                if (story->Choices[choice].Type == Choice::Type::BRIBE_CODEWORD_ITEM)
                                {
                                    Engine::GET_CODES(party, story->Choices[choice].InvisibleCodes);
                                }

                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                            else
                            {
                                if (story->Choices[choice].Value > 1)
                                {
                                    message = "You do not have the required items!";
                                }
                                else
                                {
                                    message = "You do not have the required item!";
                                }

                                error = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::ROLL_FOR_ATTRIBUTE_INCREASE)
                        {
                            auto target = -1;

                            auto team = story->Choices[choice].Team;

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                target = party.CurrentCharacter;

                                team = party.Members[party.CurrentCharacter].Team;
                            }
                            else if (Engine::COUNT(party, story->Choices[choice].Team) == 1)
                            {
                                target = Engine::FIRST(party, story->Choices[choice].Team);
                            }
                            else
                            {
                                target = selectPartyMember(window, renderer, party, story->Choices[choice].Team, Equipment::NONE, Control::Type::ROLL_FOR_ATTRIBUTE_INCREASE);
                            }

                            if (target >= 0 && target < party.Members.size())
                            {
                                auto increase = gainAttributeScore(window, renderer, party.Book, party.Members[target], story->Choices[choice].Attributes[0], story->Choices[choice].Value, story->Choices[choice].Difficulty);

                                if (increase >= 0)
                                {
                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::LASTCHARACTER_ROLLS_FOR_ATTRIBUTEINCREASE)
                        {
                            if (Engine::IS_ACTIVE(party, party.LastSelected))
                            {
                                auto increase = gainAttributeScore(window, renderer, party.Book, party.Members[party.LastSelected], story->Choices[choice].Attributes[0], story->Choices[choice].Value, story->Choices[choice].Difficulty);

                                if (increase >= 0)
                                {
                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::ROLL_ATTRIBUTE_WITH_STATUS)
                        {
                            auto target = -1;

                            if (Engine::COUNT(party, story->Choices[choice].Status[0]) == 1)
                            {
                                target = Engine::FIRST(party, story->Choices[choice].Status[0]);
                            }
                            else
                            {
                                target = selectPartyMember(window, renderer, party, story->Choices[choice].Team, Equipment::NONE, Control::Type::ROLL_FOR_ATTRIBUTE_INCREASE);
                            }

                            if (Engine::IS_ACTIVE(party, target) && Engine::HAS_STATUS(party.Members[target], story->Choices[choice].Status[0]))
                            {
                                auto increase = gainAttributeScore(window, renderer, party.Book, party.Members[target], story->Choices[choice].Attributes[0], story->Choices[choice].Value, story->Choices[choice].Difficulty);

                                if (increase >= 0)
                                {
                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::RAISE_ATTRIBUTE_SCORE)
                        {
                            auto target = -1;

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                target = party.CurrentCharacter;
                            }
                            else if (Engine::COUNT(party) == 1)
                            {
                                target = Engine::FIRST(party);
                            }
                            else
                            {
                                target = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, Control::Type::RAISE_ATTRIBUTE_SCORE);
                            }

                            if (target >= 0 && target < party.Members.size())
                            {
                                auto increase = gainAttributeScore(window, renderer, party.Book, party.Members[target], story->Choices[choice].Attributes[0], story->Choices[choice].Value, 0);

                                if (increase >= 0)
                                {
                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::PARTY_RAISE_ATTRIBUTE)
                        {
                            for (auto i = 0; i < party.Members.size(); i++)
                            {
                                if (Engine::IS_ALIVE(party.Members[i]))
                                {
                                    auto increase = -1;

                                    while (increase <= 0)
                                    {
                                        auto attribute = Attribute::Type::NONE;

                                        while (attribute == Attribute::Type::NONE)
                                        {
                                            attribute = selectAttribute(window, renderer, party.Book, party.Members[i], story->Choices[choice].Value);
                                        }

                                        increase = gainAttributeScore(window, renderer, party.Book, party.Members[i], attribute, story->Choices[choice].Value, 0);
                                    }
                                }
                            }

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::PARTY_RAISE_HEALTH)
                        {
                            Engine::RAISE_HEALTH(party, story->Choices[choice].Value);

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::RANDOM_EVENT)
                        {
                            Sound::Play(Sound::Type::DICE_ROLL);

                            auto results = Engine::ROLL_DICE(story->Choices[choice].Value);

                            auto sum = 0;

                            for (auto i = 0; i < results.size(); i++)
                            {
                                sum += results[i];
                            }

                            for (auto i = 0; i < story->Choices[choice].RandomDestinations.size(); i++)
                            {
                                if (sum <= std::get<0>(story->Choices[choice].RandomDestinations[i]) && !done)
                                {
                                    story->Bye = std::get<1>(story->Choices[choice].RandomDestinations[i]);

                                    next = findStory(std::get<2>(story->Choices[choice].RandomDestinations[i]));

                                    done = true;
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::CHOOSE_PARTY_MEMBER)
                        {
                            auto selected = -1;

                            while (selected < 0 || selected >= party.Members.size())
                            {
                                if (Engine::COUNT(party, story->Choices[choice].Team) == 1)
                                {
                                    if (story->Choices[choice].Team == Team::Type::NONE)
                                    {
                                        selected = Engine::FIRST(party);
                                    }
                                    else
                                    {
                                        selected = Engine::FIRST(party, story->Choices[choice].Team);
                                    }
                                }
                                else
                                {
                                    selected = selectPartyMember(window, renderer, party, story->Choices[choice].Team, Equipment::NONE, Control::Type::PARTY);
                                }
                            }

                            if (story->Choices[choice].Team == Team::Type::NONE || party.Members[selected].Team == story->Choices[choice].Team)
                            {
                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                            else
                            {
                                message = party.Members[selected].Name + " is not part of the " + std::string(Team::Descriptions[story->Choices[choice].Team]) + " team!";

                                error = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::CHOOSE_CHARACTER_EXCEPT)
                        {
                            auto selected = -1;

                            while (selected < 0 || selected >= party.Members.size())
                            {
                                if (Engine::COUNT(party, story->Choices[choice].Team) == 1)
                                {
                                    if (story->Choices[choice].Team == Team::Type::NONE)
                                    {
                                        selected = Engine::FIRST(party);
                                    }
                                    else
                                    {
                                        selected = Engine::FIRST(party, story->Choices[choice].Team);
                                    }
                                }
                                else
                                {
                                    selected = selectPartyMember(window, renderer, party, story->Choices[choice].Team, Equipment::NONE, Control::Type::PARTY);
                                }
                            }

                            if ((story->Choices[choice].Team == Team::Type::NONE || party.Members[selected].Team == story->Choices[choice].Team) && party.Members[selected].Type != story->Choices[choice].Character)
                            {
                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                            else
                            {
                                if (party.Members[selected].Type == story->Choices[choice].Character)
                                {
                                    message = "You cannot select " + party.Members[selected].Name + "!";
                                }
                                else
                                {
                                    message = party.Members[selected].Name + " is not part of the " + std::string(Team::Descriptions[story->Choices[choice].Team]) + " team!";
                                }

                                error = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::RETREAT)
                        {
                            if (party.Army.size() > 0)
                            {
                                for (auto unit = 0; unit < party.Army.size(); unit++)
                                {
                                    if (party.Army[unit].Position != Location::BattleField::NONE || party.Army[unit].Morale <= 0)
                                    {
                                        auto retreat = retreatArmy(window, renderer, party, unit, story->Choices[choice].Location, story->Choices[choice].Value, 1);

                                        if (retreat)
                                        {
                                            party.Army[unit].Position = Location::BattleField::NONE;
                                            party.Army[unit].Morale = party.Army[unit].MaximumMorale;
                                        }
                                    }
                                }
                            }

                            Engine::REMOVE_ROUTED(party);

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::GET_EQUIPMENT)
                        {
                            auto take_done = takeScreen(window, renderer, party, story->Choices[choice].Team, story->Choices[choice].Equipment, story->Choices[choice].Equipment.size(), true);

                            if (take_done)
                            {
                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::GET_EQUIPMENT_CODE)
                        {
                            auto take_done = takeScreen(window, renderer, party, story->Choices[choice].Team, story->Choices[choice].Equipment, story->Choices[choice].Equipment.size(), true);

                            if (take_done)
                            {
                                if (Engine::VERIFY_EQUIPMENT(party, {story->Choices[choice].Equipment[0].Type}))
                                {
                                    Engine::GET_CODES(party, story->Choices[choice].Codes);

                                    Engine::GET_CODES(party, story->Choices[choice].InvisibleCodes);

                                    std::string bye_string = "You gained the code";

                                    if (story->Choices[choice].Codes.size() > 1)
                                    {
                                        bye_string += "s: ";

                                        for (auto i = 0; i < story->Choices[choice].Codes.size(); i++)
                                        {
                                            if (i > 0)
                                            {
                                                bye_string += ", ";
                                            }

                                            bye_string += std::string(Codes::Prefix[story->Choices[choice].Codes[i].Type]) += std::to_string(story->Choices[choice].Codes[i].Code);
                                        }
                                    }
                                    else
                                    {
                                        bye_string += " " + std::string(Codes::Prefix[story->Choices[choice].Codes[0].Type]) += std::to_string(story->Choices[choice].Codes[0].Code);
                                    }

                                    bye_string += ".";

                                    addBye(story, bye_string);
                                }

                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::DELIVER)
                        {
                            if (Engine::HAS_SHIP(party, story->Choices[choice].Location, story->Choices[choice].Cargo.size()))
                            {
                                if (party.Money >= story->Choices[choice].Value)
                                {
                                    auto result = selectShip(window, renderer, party.Book, party.Fleet, story->Choices[choice].Location, story->Choices[choice].Cargo, Control::Type::CARGO);

                                    if (result >= 0 && result < party.Fleet.size())
                                    {
                                        Engine::GAIN_MONEY(party, -story->Choices[choice].Value);

                                        party.Fleet[result].Cargo.insert(party.Fleet[result].Cargo.end(), story->Choices[choice].Cargo.begin(), story->Choices[choice].Cargo.end());

                                        next = findStory(story->Choices[choice].Destination);

                                        done = true;
                                    }
                                }
                                else
                                {
                                    message = "You do not have enough silver coins!";

                                    error = true;
                                }
                            }
                            else
                            {
                                if (Engine::HAS_SHIP(party, story->Choices[choice].Location))
                                {
                                    message = "You do not have the required cargo space!";
                                }
                                else
                                {
                                    message = "You do not have a ship at " + std::string(Location::Description[story->Choices[choice].Location]) + "!";
                                }

                                error = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::GAIN_CARGO)
                        {
                            if (party.CurrentShip >= 0 && party.CurrentShip < party.Fleet.size())
                            {
                                if ((party.Fleet[party.CurrentShip].MaximumCargo - party.Fleet[party.CurrentShip].Cargo.size()) >= story->Choices[choice].Cargo.size())
                                {
                                    party.Fleet[party.CurrentShip].Cargo.insert(party.Fleet[party.CurrentShip].Cargo.end(), story->Choices[choice].Cargo.begin(), story->Choices[choice].Cargo.end());

                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                                else
                                {
                                    message = "You do not have enough space in your ship!";

                                    error = true;
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::CODES)
                        {
                            if (Engine::VERIFY_CODES(party, story->Choices[choice].Codes))
                            {
                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                            else
                            {
                                if (story->Choices[choice].Codes.size() > 1)
                                {
                                    message = "You do not have the required codes!";
                                }
                                else
                                {
                                    message = "You do not have the required code!";
                                }

                                error = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::SET_STATUS_FROM_LIST)
                        {
                            auto selected = -1;

                            while (selected < 0 || selected >= party.Members.size())
                            {
                                party.CurrentCharacter = Engine::FIND_SOLO(party);

                                if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                                {
                                    selected = party.CurrentCharacter;
                                }
                                else if (Engine::COUNT(party) == 1)
                                {
                                    selected = Engine::FIRST(party);
                                }
                                else
                                {
                                    selected = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, Control::Type::ANY);
                                }
                            }

                            for (auto i = 0; i < party.Members.size(); i++)
                            {
                                if (i != selected)
                                {
                                    Engine::REMOVE_STATUS(party.Members[i], story->Choices[choice].Status[story->Choices[choice].Value]);
                                }
                            }

                            for (auto i = 0; i < story->Choices[choice].Status.size(); i++)
                            {
                                if (i == story->Choices[choice].Value)
                                {
                                    Engine::GAIN_STATUS(party.Members[selected], story->Choices[choice].Status[story->Choices[choice].Value]);
                                }
                                else
                                {
                                    Engine::REMOVE_STATUS(party.Members[selected], story->Choices[choice].Status[i]);
                                }
                            }

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::HAS_STATUS)
                        {
                            auto result = true;

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                for (auto i = 0; i < story->Choices[choice].Status.size(); i++)
                                {
                                    result &= Engine::HAS_STATUS(party.Members[party.CurrentCharacter], story->Choices[choice].Status[i]);
                                }
                            }
                            else
                            {
                                for (auto i = 0; i < story->Choices[choice].Status.size(); i++)
                                {
                                    result &= Engine::HAS_STATUS(party, story->Choices[choice].Status[i]);
                                }
                            }

                            if (result)
                            {
                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                            else
                            {
                                error = true;

                                if (story->Choices[choice].Status.size() > 1)
                                {
                                    if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                                    {
                                        message = "You do not have all of the required status: ";
                                    }
                                    else
                                    {
                                        message = "Your party does not have all of the required status: ";
                                    }
                                }
                                else
                                {
                                    if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                                    {
                                        message = "You do not have the required status: ";
                                    }
                                    else
                                    {
                                        message = "Your party does not have the required status: ";
                                    }
                                }

                                for (auto i = 0; i < story->Choices[choice].Status.size(); i++)
                                {
                                    if (i > 0)
                                    {
                                        message += ", ";
                                    }

                                    message += std::string(Character::StatusDescriptions[story->Choices[choice].Status[i]]);
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::PAYFORSTATUS_WITH_HEALTH)
                        {
                            auto target = -1;

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                target = party.CurrentCharacter;
                            }
                            else
                            {
                                target = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, Control::Type::ANY);
                            }

                            if (target >= 0 && target < party.Members.size())
                            {
                                if (!Engine::HAS_STATUS(party.Members[target], story->Choices[choice].Status[0]))
                                {
                                    story->temp_string = party.Members[target].Name + " gains " + std::string(Character::StatusDescriptions[story->Choices[choice].Status[0]]);

                                    party.Members[target].MaximumHealth += story->Choices[choice].Value;

                                    if (party.Members[target].Health > party.Members[target].MaximumHealth)
                                    {
                                        party.Members[target].Health = party.Members[target].MaximumHealth;
                                    }

                                    Engine::GAIN_STATUS(party.Members[target], story->Choices[choice].Status[0]);

                                    addBye(story, story->temp_string.c_str());

                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                                else
                                {
                                    error = true;

                                    message = party.Members[target].Name + " already has " + std::string(Character::StatusDescriptions[story->Choices[choice].Status[0]]) + "!";
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::ASSIGN_TEAMS)
                        {
                            Engine::CONSOLIDATE(party);

                            assignTeams(window, renderer, party, story->Choices[choice].Teams, story->Choices[choice].Value);

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::LAST_INDIVIDUAL_CHECK)
                        {
                            auto selection = std::vector<int>();

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                selection.push_back(party.CurrentCharacter);
                            }
                            else if (Engine::IS_ACTIVE(party, party.LastSelected))
                            {
                                selection.push_back(party.LastSelected);
                            }
                            else if (party.LastSelection.size() > 0)
                            {
                                selection = party.LastSelection;
                            }

                            auto success = false;

                            if (selection.size() == 1)
                            {
                                auto target = selection[0];

                                if (Engine::IS_ACTIVE(party, target))
                                {
                                    success = skillTestScreen(window, renderer, party, story->Choices[choice].Team, selection, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, story->Choices[choice].UseWeapon);
                                }
                                else
                                {
                                    selection.clear();

                                    success = skillCheck(window, renderer, party, story->Choices[choice].Team, 1, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, selection, story->Choices[choice].UseWeapon);
                                }
                            }
                            else
                            {
                                selection.clear();

                                success = skillCheck(window, renderer, party, story->Choices[choice].Team, 1, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, selection, story->Choices[choice].UseWeapon);
                            }

                            if (success || selection.size() == 1)
                            {
                                story->SkillCheck(party, success, selection);

                                if (success)
                                {
                                    next = findStory(story->Choices[choice].Destination);
                                }
                                else
                                {
                                    next = findStory(story->Choices[choice].DestinationFailed);
                                }

                                done = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::INDIVIDUAL_WITH_STATUS)
                        {
                            auto selection = std::vector<int>();

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                selection.push_back(party.CurrentCharacter);
                            }
                            else if (Engine::COUNT(party, story->Choices[choice].Status[0]) > 1)
                            {
                                auto result = selectPartyMember(window, renderer, party, story->Choices[choice].Team, Equipment::NONE, Control::Type::SKILL);

                                if (result >= 0 && result < party.Members.size())
                                {
                                    selection.push_back(result);
                                }
                            }
                            else if (Engine::COUNT(party, story->Choices[choice].Status[0]) > 0)
                            {
                                selection.push_back(Engine::FIRST(party, story->Choices[choice].Status[0]));
                            }

                            auto success = false;

                            auto with_status = false;

                            if (selection.size() == 1)
                            {
                                auto target = selection[0];

                                if (Engine::IS_ACTIVE(party, target) && Engine::HAS_STATUS(party.Members[target], story->Choices[choice].Status[0]))
                                {
                                    success = skillTestScreen(window, renderer, party, story->Choices[choice].Team, selection, story->Choices[choice].Attributes[0], story->Choices[choice].Difficulty, story->Choices[choice].Success, story->Choices[choice].UseWeapon);

                                    with_status = true;
                                }
                            }

                            if (selection.size() == 1 && with_status)
                            {
                                story->SkillCheck(party, success, selection);

                                if (success)
                                {
                                    next = findStory(story->Choices[choice].Destination);
                                }
                                else
                                {
                                    next = findStory(story->Choices[choice].DestinationFailed);
                                }

                                done = true;
                            }
                            else if (selection.size() == 1)
                            {
                                error = true;

                                message = "You do not have the required status: ";

                                for (auto i = 0; i < story->Choices[choice].Status.size(); i++)
                                {
                                    if (i > 0)
                                    {
                                        message += ", ";
                                    }

                                    message += std::string(Character::StatusDescriptions[story->Choices[choice].Status[i]]);
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::RAISE_LOWEST_ATTRIBUTE)
                        {
                            auto attribute_min = Engine::MIN(party, story->Choices[choice].Attributes[0]);

                            auto target = -1;

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                target = party.CurrentCharacter;
                            }
                            else if (Engine::COUNT(party, story->Choices[choice].Attributes[0], attribute_min) > 1)
                            {
                                target = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, Control::Type::RAISE_ATTRIBUTE_SCORE);
                            }
                            else
                            {
                                target = Engine::FIRST(party, story->Choices[choice].Attributes[0], attribute_min);
                            }

                            if (target >= 0 && target < party.Members.size())
                            {
                                if (Engine::SCORE(party.Members[target], story->Choices[choice].Attributes[0]) == attribute_min)
                                {
                                    auto increase = gainAttributeScore(window, renderer, party.Book, party.Members[target], story->Choices[choice].Attributes[0], story->Choices[choice].Value, 0);

                                    if (increase >= 0)
                                    {
                                        next = findStory(story->Choices[choice].Destination);

                                        done = true;
                                    }
                                }
                                else
                                {
                                    error = true;

                                    message = party.Members[target].Name + " does not have the lowest " + std::string(Attribute::Descriptions[story->Choices[choice].Attributes[0]]) + " score!";
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::SELECT_LOWEST_ATTRIBUTE)
                        {
                            auto attribute_min = Engine::MIN(party, story->Choices[choice].Attributes[0]);

                            auto target = -1;

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::COUNT(party, story->Choices[choice].Attributes[0], attribute_min) > 1)
                            {
                                target = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, Control::Type::RAISE_ATTRIBUTE_SCORE);
                            }
                            else
                            {
                                target = Engine::FIRST(party, story->Choices[choice].Attributes[0], attribute_min);

                                party.LastSelected = target;
                            }

                            if (Engine::IS_ALIVE(party, target))
                            {
                                if (Engine::SCORE(party.Members[target], story->Choices[choice].Attributes[0]) == attribute_min)
                                {
                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                                else
                                {
                                    error = true;

                                    message = party.Members[target].Name + " does not have the lowest " + std::string(Attribute::Descriptions[story->Choices[choice].Attributes[0]]) + " score!";
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::RAISEATTRIBUTE_WITH_BLESSING)
                        {
                            if (party.Money >= story->Choices[choice].Value)
                            {
                                auto attribute_min = Engine::MIN(party, story->Choices[choice].Attributes[0]);

                                auto target = -1;

                                party.CurrentCharacter = Engine::FIND_SOLO(party);

                                if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                                {
                                    target = party.CurrentCharacter;
                                }
                                else if (Engine::COUNT(party, story->Choices[choice].Attributes[0], attribute_min) > 1)
                                {
                                    target = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, Control::Type::RAISE_ATTRIBUTE_SCORE);
                                }
                                else
                                {
                                    target = Engine::FIRST(party, story->Choices[choice].Attributes[0], attribute_min);
                                }

                                if (target >= 0 && target < party.Members.size())
                                {
                                    if (Engine::SCORE(party.Members[target], story->Choices[choice].Attributes[0]) == attribute_min)
                                    {
                                        if (Engine::SCORE(party.Members[target], story->Choices[choice].Attributes[0]) < story->Choices[choice].Difficulty)
                                        {
                                            auto increase = gainAttributeScore(window, renderer, party.Book, party.Members[target], story->Choices[choice].Attributes[0], story->Choices[choice].Success, 0);

                                            if (increase >= 0)
                                            {
                                                if (increase > 0)
                                                {
                                                    addBye(story, party.Members[target].Name + " gains +" + std::to_string(increase) + " " + std::string(Attribute::Descriptions[story->Choices[choice].Attributes[0]]) + "!");
                                                }

                                                Engine::GAIN_MONEY(party, -story->Choices[choice].Value);

                                                next = findStory(story->Choices[choice].Destination);

                                                done = true;
                                            }
                                        }
                                        else
                                        {
                                            error = true;

                                            message = "This blessing will have no effect on " + party.Members[target].Name + "'s " + std::string(Attribute::Descriptions[story->Choices[choice].Attributes[0]]) + "!";
                                        }
                                    }
                                    else
                                    {
                                        error = true;

                                        message = party.Members[target].Name + " does not have the lowest " + std::string(Attribute::Descriptions[story->Choices[choice].Attributes[0]]) + " score!";
                                    }
                                }
                            }
                            else
                            {
                                error = true;

                                message = "You do not have enough money for the blessing!";
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::PAYFORBLESSING_WITH_ITEM)
                        {
                            auto equipment = std::vector<Equipment::Type>();

                            for (auto i = 0; i < story->Choices[choice].Equipment.size(); i++)
                            {
                                equipment.push_back(story->Choices[choice].Equipment[i].Type);
                            }

                            if (equipment.size() > 0 && Engine::VERIFY_EQUIPMENT(party, equipment))
                            {
                                auto attribute_min = Engine::MIN(party, story->Choices[choice].Attributes[0]);

                                auto target = -1;

                                party.CurrentCharacter = Engine::FIND_SOLO(party);

                                if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                                {
                                    target = party.CurrentCharacter;
                                }
                                else if (Engine::COUNT(party, story->Choices[choice].Attributes[0], attribute_min) > 1)
                                {
                                    target = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, Control::Type::RAISE_ATTRIBUTE_SCORE);
                                }
                                else
                                {
                                    target = Engine::FIRST(party, story->Choices[choice].Attributes[0], attribute_min);
                                }

                                if (target >= 0 && target < party.Members.size())
                                {
                                    if (Engine::SCORE(party.Members[target], story->Choices[choice].Attributes[0]) == attribute_min)
                                    {
                                        Engine::GAIN_SCORE(party.Members[target], story->Choices[choice].Attributes[0], story->Choices[choice].Value);

                                        if (story->Choices[choice].Value > 0)
                                        {
                                            addBye(story, party.Members[target].Name + " gains +" + std::to_string(story->Choices[choice].Value) + " " + std::string(Attribute::Descriptions[story->Choices[choice].Attributes[0]]) + "!");
                                        }

                                        Engine::LOSE_EQUIPMENT(party, story->Choices[choice].Team, equipment);

                                        next = findStory(story->Choices[choice].Destination);

                                        done = true;
                                    }
                                    else
                                    {
                                        error = true;

                                        message = party.Members[target].Name + " does not have the lowest " + std::string(Attribute::Descriptions[story->Choices[choice].Attributes[0]]) + " score!";
                                    }
                                }
                            }
                            else
                            {
                                error = true;

                                message = "You do not have the required item";

                                if (story->Choices[choice].Equipment.size() > 1)
                                {
                                    message += "s";
                                }

                                message += " for the blessing!";
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::GAIN_MORALE)
                        {
                            auto target = selectArmyUnits(window, renderer, party, story->Choices[choice].Location, story->Choices[choice].Value);

                            if (target.size() >= story->Choices[choice].Value || target.size() >= Engine::COUNT(party.Army, story->Choices[choice].Location))
                            {
                                for (auto i = 0; i < target.size(); i++)
                                {
                                    if (target[i] >= 0 && target[i] < party.Members.size())
                                    {
                                        party.Army[target[i]].MaximumMorale += story->Choices[choice].Success;

                                        Engine::GAIN_MORALE(party.Army[target[i]], story->Choices[choice].Success);
                                    }
                                }

                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::SET_PARTY_ORDER)
                        {
                            auto team_size = Engine::COUNT(party, story->Choices[choice].Team);

                            auto target = selectPartyMembers(window, renderer, party, story->Choices[choice].Team, team_size, Control::Type::SELECT_ORDER);

                            if (target.size() > 0 && target.size() >= team_size)
                            {
                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::GET_CODES)
                        {
                            if (story->Choices[choice].Codes.size() > 0)
                            {
                                Engine::GET_CODES(party, story->Choices[choice].Codes);
                            }

                            if (story->Choices[choice].InvisibleCodes.size() > 0)
                            {
                                Engine::GET_CODES(party, story->Choices[choice].InvisibleCodes);
                            }

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::GAIN_MONEY)
                        {
                            if (story->Choices[choice].Value >= 0)
                            {
                                Engine::GAIN_MONEY(party, story->Choices[choice].Value);

                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                            else
                            {
                                if (party.Money >= -(story->Choices[choice].Value))
                                {
                                    Engine::GAIN_MONEY(party, -story->Choices[choice].Value);

                                    next = findStory(story->Choices[choice].Destination);

                                    done = true;
                                }
                                else
                                {
                                    error = true;

                                    message = "You do not have " + std::to_string(-story->Choices[choice].Value) + " silver coins!";
                                }
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::BRIBE_CODEWORD_AMOUNT)
                        {
                            if (party.Money >= story->Choices[choice].Value)
                            {
                                Engine::GAIN_MONEY(party, -story->Choices[choice].Value);

                                if (story->Choices[choice].InvisibleCodes.size() > 0)
                                {
                                    Engine::GET_CODES(party, story->Choices[choice].InvisibleCodes);
                                }

                                next = findStory(story->Choices[choice].Destination);

                                done = true;
                            }
                            else
                            {
                                error = true;

                                message = "You do not have " + std::to_string(story->Choices[choice].Value) + " silver coins!";
                            }
                        }
                        else if (story->Choices[choice].Type == Choice::Type::LOSE_EQUIPMENT)
                        {
                            auto equipment = std::vector<Equipment::Base>();

                            for (auto i = 0; i < party.Members.size(); i++)
                            {
                                if (Engine::IS_ACTIVE(party, i) && (party.Members[i].Team == story->Choices[choice].Team || story->Choices[choice].Team == Team::Type::NONE))
                                {
                                    for (auto j = 0; j < party.Members[i].Equipment.size(); i++)
                                    {
                                        equipment.push_back(party.Members[i].Equipment[j]);
                                    }
                                }
                            }

                            if (story->Choices[choice].Value >= equipment.size())
                            {
                                Engine::LOSE_ALL(party);
                            }
                            else
                            {
                                loseItems(window, renderer, party, Character::Type::NONE, story->Choices[choice].Team, equipment, story->Choices[choice].EquipmentExceptions, story->Choices[choice].Value, false);
                            }

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::EVERYONE_LOSES_EQUIPMENT)
                        {
                            auto equipmentClasses = std::vector<Equipment::Class>();

                            if (story->Choices[choice].EquipmentExceptions.size() > 0)
                            {
                                for (auto i = 0; i < Equipment::Classes.size(); i++)
                                {
                                    if (Engine::FIND_LIST(story->Choices[choice].EquipmentExceptions, Equipment::Classes[i]) < 0)
                                    {
                                        equipmentClasses.push_back(Equipment::Classes[i]);
                                    }
                                }
                            }
                            else
                            {
                                equipmentClasses = Equipment::Classes;
                            }

                            for (auto i = 0; i < party.Members.size(); i++)
                            {
                                if (Engine::IS_ACTIVE(party, i) && party.Members[i].Equipment.size() > 0)
                                {
                                    if (Engine::COUNT_EQUIPMENT(party.Members[i], equipmentClasses) < story->Choices[choice].Value)
                                    {
                                        for (auto j = 0; j < equipmentClasses.size(); j++)
                                        {
                                            Engine::LOSE_ALL(party.Members[i], equipmentClasses[j]);
                                        }
                                    }
                                    else
                                    {
                                        loseItems(window, renderer, party, party.Members[i].Type, story->Choices[choice].Team, party.Members[i].Equipment, story->Choices[choice].EquipmentExceptions, story->Choices[choice].Value, false);
                                    }
                                }
                            }

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }
                        else if (story->Choices[choice].Type == Choice::Type::GAIN_HEART)
                        {
                            Engine::GAIN_HEARTS(party, story->Choices[choice].Character, story->Choices[choice].SecondCharacter, story->Choices[choice].Value);

                            next = findStory(story->Choices[choice].Destination);

                            done = true;
                        }

                        if (story->Choices[choice].Bye)
                        {
                            addBye(story, story->Choices[choice].Bye);
                        }

                        if (error)
                        {
                            if (SDL_GetTicks() - start_ticks > duration)
                            {
                                Sound::Play(Sound::Type::ERROR);

                                start_ticks = SDL_GetTicks();
                            }
                        }
                    }
                }
                else if (controls[current].Type == Control::Type::ENCYCLOPEDIA && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    encyclopediaScreen(window, renderer, story->BookID);

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::MAP && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    mapScreen(window, renderer, story->BookID);

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::PARTY && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    viewParty(window, renderer, party, story->Team, false);

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::BACK && !hold)
                {
                    next = story;

                    done = true;
                }
            }
        }

        Sound::Play(Sound::Type::BUTTON_CLICK);

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_caption)
        {
            TTF_CloseFont(font_caption);

            font_caption = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_mason = NULL;
        }

        if (font_mason2)
        {
            TTF_CloseFont(font_mason2);

            font_mason2 = NULL;
        }

        TTF_Quit();

        if (splashTexture)
        {
            SDL_DestroyTexture(splashTexture);

            splashTexture = NULL;
        }

        if (splash)
        {
            SDL_FreeSurface(splash);

            splash = NULL;
        }
    }

    if (background)
    {
        SDL_FreeSurface(background);

        background = NULL;
    }

    return next;
}

Story::Base *renderChoices(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Story::Base *story)
{
    Story::Base *next = &Story::notImplemented;

    if (story->Choices.size() > 0)
    {
        next = processChoices(window, renderer, party, story);
    }
    else
    {
        next = findStory(story->Continue(party));
    }

    return next;
}

void storyTransition(Party::Base &party, Story::Base *story, Story::Base *next)
{
    std::string temp_string = "";

    auto storyID = story->ID < 0 ? story->DisplayID : story->ID;

    auto nextID = next->ID < 0 ? next->DisplayID : next->ID;

    if ((story->BookID != next->BookID) || (story->BookID == next->BookID && storyID != nextID))
    {
        Engine::LOSE_CODES(party, {Codes::Type::NO_VAULT_ACCESS, Codes::Type::MAGIC_VAULT});

        if (Engine::VERIFY_EQUIPMENT(party, {Equipment::Type::RUNESWORD3}))
        {
            auto result = Engine::FIND_BEARER(party, Equipment::Type::RUNESWORD3);

            if (result >= 0 && result < party.Members.size())
            {
                Engine::GAIN_HEALTH(party.Members[result], -1);

                temp_string = party.Members[result].Name + " loses 1 Health point.";

                addBye(story, temp_string);
            }
        }

        if (((story->BookID != next->BookID) || (party.CurrentShip != -1)) && Engine::IN_PARTY(party, Character::Type::SKULLCRACKER))
        {
            auto result = Engine::FIND_CHARACTER(party, Character::Type::SKULLCRACKER);

            if (result >= 0 && result < party.Members.size())
            {
                party.Members.erase(party.Members.begin() + result);

                addBye(story, "Skullcracker leaves and wanders into the desert.");
            }
        }
    }

    if (next->Location != Location::Type::NONE)
    {
        if (Engine::HAS_FOLLOWER(party, Follower::Type::MORDAIN_SKELETONS) && next->Location != Location::Type::MORDAIN && next->Location != Location::Type::MORDAIN_EXCAVATED_DUNGEONS)
        {
            Engine::LOSE_FOLLOWERS(party, {Follower::Type::MORDAIN_SKELETONS});

            addBye(story, "The [SKELETONS] crumble to dust!");
        }
    }
}

void renderCaption(SDL_Renderer *renderer, TTF_Font *font_caption, Button control)
{
    auto caption_size = TTF_FontHeight(font_caption);
    auto captiony = buttony + buttonh + border_space;
    auto captionx = control.X - text_space;

    std::string caption = "";

    if (control.Type == Control::Type::ENCYCLOPEDIA)
    {
        caption = "Consult Encyclopedia";
    }
    else if (control.Type == Control::Type::MAP)
    {
        caption = "View Map";
    }
    else if (control.Type == Control::Type::TOGGLE_MAP)
    {
        caption = "Switch between Local and World Maps";
    }
    else if (control.Type == Control::Type::GAME)
    {
        caption = "Load or Save Game";
    }
    else if (control.Type == Control::Type::PARTY)
    {
        caption = "View Party";
    }
    else if (control.Type == Control::Type::HARBOUR)
    {
        caption = "Visit Harbour";
    }
    else if (control.Type == Control::Type::SHOP)
    {
        caption = "Buy/Sell Items";
    }
    else if (control.Type == Control::Type::REST)
    {
        caption = "Rest, Recover, and Recharge Spells";
    }
    else if (control.Type == Control::Type::PREVIEW)
    {
        caption = "Preview Battle";
    }
    else if (control.Type == Control::Type::CONTINUE_STORY)
    {
        caption = "Continue Story";
    }
    else if (control.Type == Control::Type::RECRUIT)
    {
        caption = "Recruit adventurers for your party";
    }
    else if (control.Type == Control::Type::BARRACKS)
    {
        caption = "Transfer Troops";
    }
    else if (control.Type == Control::Type::BACK)
    {
        caption = "Go Back";
    }
    else if (control.Type == Control::Type::QUIT)
    {
        caption = "Leave Game";
    }
    else if (control.Type == Control::Type::USE)
    {
        caption = "Use Item";
    }
    else if (control.Type == Control::Type::DROP)
    {
        caption = "Drop Item";
    }
    else if (control.Type == Control::Type::VAULT)
    {
        caption = "Access The Vault";
    }
    else if (control.Type == Control::Type::MONEY)
    {
        caption = "Access Money in The Vault";
    }
    else if (control.Type == Control::Type::TRANSFER)
    {
        caption = "Transfer Item";
    }
    else if (control.Type == Control::Type::SPELL)
    {
        caption = "Cast Spell";
    }
    else if (control.Type == Control::Type::RECHARGE)
    {
        caption = "Recharge Spell";
    }
    else if (control.Type == Control::Type::UNLEARN)
    {
        caption = "Unlearn Spell (Erase from Spellbook)";
    }
    else if (control.Type == Control::Type::BUY)
    {
        caption = "Buy Items";
    }
    else if (control.Type == Control::Type::SELL)
    {
        caption = "Sell Items";
    }
    else if (control.Type == Control::Type::EQUIPMENT)
    {
        caption = "View Inventory";
    }
    else if (control.Type == Control::Type::PREVIOUS_TOPIC)
    {
        caption = "Previous Topic";
    }
    else if (control.Type == Control::Type::NEXT_TOPIC)
    {
        caption = "Next Topic";
    }
    else if (control.Type == Control::Type::BUY_CARGO)
    {
        caption = "Buy Cargo";
    }
    else if (control.Type == Control::Type::SELL_CARGO)
    {
        caption = "Sell Cargo";
    }
    else if (control.Type == Control::Type::BUY_SHIP)
    {
        caption = "Buy Ships";
    }
    else if (control.Type == Control::Type::SELL_SHIP)
    {
        caption = "Sell Ships";
    }
    else if (control.Type == Control::Type::LOAD)
    {
        caption = "Load Game";
    }
    else if (control.Type == Control::Type::DELETE)
    {
        caption = "Delete Game";
    }
    else if (control.Type == Control::Type::SAVE)
    {
        caption = "Create or Overwrite Game";
    }
    else if (control.Type == Control::Type::PREVIOUS_CHARACTER)
    {
        caption = "Previous party member";
    }
    else if (control.Type == Control::Type::NEXT_CHARACTER)
    {
        caption = "Next party member";
    }

    if (caption.length() > 0)
    {
        putText(renderer, caption.c_str(), font_caption, border_pts, clrDB, intWH, TTF_STYLE_NORMAL, textwidth, caption_size, captionx, captiony);
    }
}

bool processStory(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Book::Type book, Story::Base *story)
{
    auto quit = false;

    if (window && renderer)
    {
        TTF_Init();

        auto font_size = 28;
        auto font_garamond = TTF_OpenFont(FONT_GARAMOND, font_size);
        auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);
        auto font_mason = TTF_OpenFont(FONT_MASON, 24);
        auto font_mason2 = TTF_OpenFont(FONT_MASON, 28);
        auto font_dark11 = TTF_OpenFont(FONT_DARK11, 32);

        TTF_SetFontKerning(font_dark11, 0);

        SDL_Surface *background = NULL;

        std::vector<Button> controls = {};
        std::vector<Button> controls_normal = {};
        std::vector<Button> controls_popup = {};

        auto popupw = (int)(0.6 * SCREEN_WIDTH);
        auto popuph = (int)(0.6 * SCREEN_HEIGHT);
        auto popupx = (SCREEN_WIDTH - popupw) / 2;
        auto popupy = ((starty + text_bounds) - popuph) / 2;
        auto popup_speed = 1;
        auto popup_limit = (popuph - infoh - buttonh - button_space) / (96);

        auto controls_confirm = popupConfirm(popupw, popuph, popupx, popupy);

        auto current_mode = Control::Type::STORY;

        while (!quit)
        {
            setWindowIcon(window, "icons/spidermindgames-48.png");

            SDL_Surface *splash = NULL;
            SDL_Texture *splashTexture = NULL;
            SDL_Surface *text = NULL;

            auto flash_message = false;

            auto flash_color = intRD;

            std::string message = "";

            Uint32 start_ticks = 0;

            Uint32 duration = 3000;

            auto displayMessage = [&](std::string msg, Uint32 color)
            {
                flash_message = true;

                message = msg;

                flash_color = color;

                start_ticks = SDL_GetTicks();
            };

            party.StoryID = story->ID;

            if (party.Book == Book::Type::BOOK1)
            {
                setWindowIcon(window, "icons/book1-48.png");
            }
            else
            {
                setWindowIcon(window, "icons/spidermindgames-48.png");
            }

            auto saveParty = party;

            auto run_once = true;

            if (run_once)
            {
                run_once = false;

                auto jump = story->Background(party);

                auto jumpBook = jump.first;

                if (jumpBook != Book::Type::NONE)
                {
                    story = findStory(jump);

                    continue;
                }

                story->Event(party);
            }

            if (story->Location != Location::Type::NONE)
            {
                Engine::SET_LOCATION(party, story->Location, story->IsCity);
            }

            auto splash_h = splashw;

            if (story->Image)
            {
                splash = createImage(story->Image);
            }

            if (splash)
            {
                if (splash->w > listwidth)
                {
                    splash_h = (int)((double)listwidth / splash->w * splash->h);
                }
                else
                {
                    splash_h = splash->h;
                }

                splashTexture = SDL_CreateTextureFromSurface(renderer, splash);
            }

            if (story->Image && story->Text)
            {
                text = createTextAndImage(story->Text, story->Image, FONT_GARAMOND, font_size, clrDB, intBE, listwidth, TTF_STYLE_NORMAL);
            }
            else if (story->Text)
            {
                text = createText(story->Text, FONT_GARAMOND, font_size, clrDB, listwidth, TTF_STYLE_NORMAL);
            }

            auto compact = (text && text->h <= text_bounds - 2 * text_space) || !text;

            if (story->Controls == Story::Controls::STANDARD)
            {
                controls_normal = Story::StandardControls(compact);
            }
            else if (story->Controls == Story::Controls::SHOP)
            {
                controls_normal = Story::ShopControls(compact);
            }
            else if (story->Controls == Story::Controls::BARTER)
            {
                controls_normal = Story::BarterControls(compact);
            }
            else if (story->Controls == Story::Controls::HARBOUR)
            {
                controls_normal = Story::HarbourControls(compact);
            }
            else if (story->Controls == Story::Controls::REST)
            {
                controls_normal = Story::InnControls(compact);
            }
            else if (story->Controls == Story::Controls::RECRUIT)
            {
                controls_normal = Story::RecruitmentControls(compact);
            }
            else if (story->Controls == Story::Controls::BARRACKS)
            {
                controls_normal = Story::BarracksControls(compact);
            }
            else
            {
                controls_normal = Story::ExitControls(compact);
            }

            if ((story->Monsters.size() > 0 || story->EnemyArmy.size() > 0 || story->EnemyFleet.size() > 0) && ((Engine::ALIVE(party) + Engine::OUTSIDE(party)) > 0))
            {
                controls_normal = Story::BattlePreviewControls(compact);
            }

            if (story->Type != Story::Type::NORMAL || (Engine::ALIVE(party) + Engine::OUTSIDE(party)) <= 0)
            {
                controls_normal = Story::ExitControls(compact);
            }

            auto popup_offset = 0;

            auto popup_last = popup_offset + popup_limit;

            if (story->Monsters.size() > 0 || story->EnemyFleet.size() > 0 || story->EnemyArmy.size() > 0)
            {
                if (story->Monsters.size() > 0)
                {
                    if (popup_last > story->Monsters.size())
                    {
                        popup_last = story->Monsters.size();
                    }

                    controls_popup = popupList(window, renderer, story->Monsters, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy);
                }
                else if (story->EnemyFleet.size() > 0)
                {
                    if (popup_last > story->EnemyFleet.size())
                    {
                        popup_last = story->EnemyFleet.size();
                    }

                    controls_popup = popupList(window, renderer, story->EnemyFleet, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy);
                }
                else if (story->EnemyArmy.size() > 0)
                {
                    if (popup_last > story->EnemyArmy.size())
                    {
                        popup_last = story->EnemyArmy.size();
                    }

                    controls_popup = popupList(window, renderer, story->EnemyArmy, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy, false);
                }
            }

            auto scrollSpeed = 20;
            auto hold = false;
            auto selected = false;
            auto current = -1;
            auto offset = 0;
            auto transition = false;

            auto fg = Color::HEADER(story->BookID);

            while (!transition)
            {
                if (story->Title)
                {
                    SDL_SetWindowTitle(window, story->Title);
                }
                else
                {
                    if (story->ID != -1)
                    {
                        auto storyID = story->ID;

                        if (storyID < 0 && story->DisplayID >= 0)
                        {
                            storyID = story->DisplayID;
                        }

                        std::string title_string = "Legendary Kingdoms - " + std::string(Book::Title[story->BookID]) + ": ";

                        SDL_SetWindowTitle(window, (title_string + std::string(3 - std::to_string(std::abs(storyID)).length(), '0') + std::to_string(std::abs(storyID))).c_str());
                    }
                    else
                    {
                        std::string title_string = "Legendary Kingdoms - " + std::string(Book::Title[story->BookID]) + ": Not Implemented Yet";

                        SDL_SetWindowTitle(window, title_string.c_str());
                    }
                }

                fillWindow(renderer, intWH);

                if (background)
                {
                    stretchImage(renderer, background, 0, 0, SCREEN_WIDTH, buttony - button_space);
                }

                std::string title_string = std::string(Book::Title[book]) + "\n";

                if (story->ID != -1)
                {
                    auto storyID = story->ID;

                    if (storyID < 0 && story->DisplayID >= 0)
                    {
                        storyID = story->DisplayID;
                    }

                    title_string += std::string(3 - std::to_string(std::abs(storyID)).length(), '0') + std::to_string(std::abs(storyID));

                    putText(renderer, title_string.c_str(), font_mason2, text_space, clrBK, intWH, TTF_STYLE_NORMAL, splashw, infoh, startx, starty);
                }
                else
                {
                    title_string += "Not Implemented";

                    putText(renderer, title_string.c_str(), font_mason2, text_space, clrBK, intWH, TTF_STYLE_NORMAL, splashw, infoh, startx, starty);
                }

                putHeader(renderer, "Party", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (2 * boxh + infoh));

                if (Engine::COUNT(party) > 0)
                {
                    std::string party_string = "";

                    auto count = 0;

                    for (auto i = 0; i < party.Members.size(); i++)
                    {
                        if (count > 0)
                        {
                            party_string += "\n";
                        }

                        party_string += party.Members[i].Name;

                        if (Engine::IS_DEAD(party.Members[i]))
                        {
                            party_string += " (D)";
                        }
                        else if (Engine::IS_CURSED(party.Members[i]))
                        {
                            party_string += " (C)";
                        }

                        count += 1;
                    }

                    putText(renderer, party_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh);
                }
                else
                {
                    fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 2 * boxh, intBE);
                }

                if (Engine::COUNT_TEAMS(party) > 0 || story->Team != Team::Type::NONE)
                {
                    std::vector<Team::Type> teams = {};

                    if (Engine::IS_ACTIVE(party, party.CurrentCharacter) || story->Team != Team::Type::NONE)
                    {
                        putHeader(renderer, "Current", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (4 * boxh + 2 * infoh + box_space));

                        if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                        {
                            teams.push_back(Engine::GET_TEAM(party.Members[party.CurrentCharacter]));
                        }
                        else
                        {
                            teams.push_back(story->Team);
                        }
                    }
                    else
                    {
                        putHeader(renderer, "Teams", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (4 * boxh + 2 * infoh + box_space));

                        teams = Engine::GET_TEAMS(party);
                    }

                    if (teams.size() > 0)
                    {
                        std::string teams_string = "";

                        for (auto i = 0; i < teams.size(); i++)
                        {
                            if (i > 0)
                            {
                                teams_string += ", ";
                            }

                            teams_string += Team::Descriptions[teams[i]];
                        }

                        putText(renderer, teams_string.c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, 2 * boxh, startx, starty + text_bounds - 4 * boxh - infoh - box_space);
                    }
                    else
                    {
                        fillRect(renderer, splashw, 2 * boxh, startx, starty + text_bounds - 4 * boxh - infoh - box_space, intBE);
                    }
                }
                else
                {
                    putHeader(renderer, "Money", font_dark11, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty + text_bounds - (3 * boxh + 2 * infoh + box_space));

                    putText(renderer, (std::to_string(party.Money) + " silver coins").c_str(), font_mason, text_space, clrBK, intBE, TTF_STYLE_NORMAL, splashw, boxh, startx, starty + text_bounds - 3 * boxh - infoh - box_space);
                }

                fillRect(renderer, textwidth, text_bounds, textx, texty, BE_80);

                if (story->Text && text && story->Image && splash)
                {
                    renderImage(renderer, text, textx + text_space, texty + text_space, text_bounds - 2 * text_space, offset);
                }
                else if (story->Text && text)
                {
                    renderText(renderer, text, 0, textx + text_space, texty + text_space, text_bounds - 2 * text_space, offset);
                }

                auto scrollUp = false;

                auto scrollDown = false;

                if (story->Type == Story::Type::DOOM)
                {
                    Sound::Play(Sound::Type::FAIL);

                    putText(renderer, "This adventure is over.", font_garamond, text_space, clrWH, intRD, TTF_STYLE_NORMAL, splashw, boxh, startx, starty);
                }
                else if ((Engine::ALIVE(party) + Engine::OUTSIDE(party)) <= 0)
                {
                    Sound::Play(Sound::Type::FAIL);

                    putText(renderer, "Your party has died. This adventure is over.", font_garamond, text_space, clrWH, intRD, TTF_STYLE_NORMAL, splashw, boxh, startx, starty);
                }

                if (current_mode == Control::Type::STORY)
                {
                    controls = controls_normal;
                }
                else if (current_mode == Control::Type::PREVIEW)
                {
                    renderButtons(renderer, controls_normal, -1, intLB, border_space, border_pts, (!compact && offset > 0), !compact && text && offset < (text->h - text_bounds + 2 * text_space));

                    fillRect(renderer, popupw, popuph, popupx, popupy, intBE);

                    drawRect(renderer, popupw, popuph, popupx, popupy, intBK);

                    std::string preview_string = "";

                    if (story->Monsters.size() > 0)
                    {
                        preview_string = "Enemy Combatants";
                    }
                    else if (story->EnemyFleet.size() > 0)
                    {
                        preview_string = "Enemy Fleet";
                    }
                    else if (story->EnemyArmy.size() > 0)
                    {
                        preview_string = "Enemy Army";
                    }
                    else
                    {
                        preview_string = "Battle Preview";
                    }

                    putHeader(renderer, preview_string.c_str(), font_dark11, text_space, clrWH, intDB, TTF_STYLE_NORMAL, popupw, infoh, popupx, popupy);

                    if (popup_last - popup_offset > 0)
                    {
                        for (auto i = 0; i < popup_last - popup_offset; i++)
                        {
                            drawRect(renderer, controls_popup[i].W + border_space, controls_popup[i].H + border_space, controls_popup[i].X - border_pts, controls_popup[i].Y - border_pts, intBK);
                        }
                    }

                    controls = controls_popup;
                }
                else if (current_mode == Control::Type::CONFIRM)
                {
                    renderButtons(renderer, controls_normal, -1, intLB, border_space, border_pts, (!compact && offset > 0), !compact && text && offset < (text->h - text_bounds + 2 * text_space));

                    fillRect(renderer, popupw, popuph, popupx, popupy, intBE);

                    drawRect(renderer, popupw, popuph, popupx, popupy, intBK);

                    putHeader(renderer, "Are you sure?", font_dark11, text_space, clrWH, intDB, TTF_STYLE_NORMAL, popupw, infoh, popupx, popupy);

                    putText(renderer, "You are about to end this session. Any unsaved progress will be lost.", font_garamond, -1, clrBK, intBE, TTF_STYLE_NORMAL, popupw - 2 * text_space, popuph - infoh - 2 * text_space, popupx + text_space, popupy + infoh + text_space);

                    controls = controls_confirm;
                }

                if (current_mode == Control::Type::STORY)
                {
                    renderButtons(renderer, controls, current, intLB, border_space, border_pts, (!compact && offset > 0), !compact && text && offset < (text->h - text_bounds + 2 * text_space));
                }
                else if (current_mode == Control::Type::PREVIEW || current_mode == Control::Type::CONFIRM)
                {
                    renderButtons(renderer, controls, current, intLB, border_space, border_pts);
                }

                if (current >= 0 && current < controls.size() && current_mode == Control::Type::STORY && !selected)
                {
                    renderCaption(renderer, font_caption, controls[current]);
                }

                if (splash && splash->w > listwidth && current_mode != Control::Type::PREVIEW)
                {
                    auto mousex = 0;
                    auto mousey = 0;

                    SDL_GetMouseState(&mousex, &mousey);

                    auto zoomw = textx - startx;
                    auto zoomh = splashw;

                    clipValue(zoomw, 0, splash->w);
                    clipValue(zoomh, 0, splash->h);

                    auto offsetx = 0;
                    auto offsety = splash_h;

                    if (splash->w < listwidth)
                    {
                        offsetx = (listwidth - splash->w) / 2;

                        offsety = splash->h;
                    }

                    if (mousex >= (textx + text_space + offsetx) && mousex <= (textx + textwidth - text_space - offsetx) && mousey >= (texty + text_space) && mousey <= (texty + text_bounds - text_space) && offset >= 0 && offset <= offsety && ((mousey - (texty + text_space)) <= (offsety - offset)))
                    {
                        auto scalex = (double)(mousex - (textx + text_space)) / listwidth;
                        auto scaley = (double)((mousey - (texty + text_space)) + offset) / offsety;

                        auto centerx = (int)(scalex * (double)splash->w);
                        auto centery = (int)(scaley * (double)splash->h);

                        clipValue(centerx, zoomw / 2, splash->w - zoomw / 2);
                        clipValue(centery, zoomh / 2, splash->h - zoomh / 2);

                        if (splashTexture)
                        {
                            SDL_Rect src;

                            src.w = zoomw;
                            src.h = zoomh;
                            src.x = centerx - zoomw / 2;
                            src.y = centery - zoomh / 2;

                            SDL_Rect dst;

                            dst.w = zoomw;
                            dst.h = zoomh;
                            dst.x = startx / 2;
                            dst.y = (starty + (text_bounds - zoomh) / 2);

                            fillRect(renderer, dst.w, dst.h, dst.x, dst.y, intWH);
                            SDL_RenderCopy(renderer, splashTexture, &src, &dst);
                            drawRect(renderer, dst.w + 2, dst.h + 2, dst.x - 1, dst.y - 1, intBK);
                        }
                    }
                }

                if (flash_message)
                {
                    if ((SDL_GetTicks() - start_ticks) < duration)
                    {
                        putText(renderer, message.c_str(), font_garamond, text_space, clrWH, flash_color, TTF_STYLE_NORMAL, splashw, boxh, startx, starty);
                    }
                    else
                    {
                        flash_message = false;
                    }
                }

                Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

                if (((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold))
                {
                    if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || scrollUp)
                    {
                        if (current_mode == Control::Type::STORY)
                        {
                            if (text)
                            {
                                if (offset > 0)
                                {
                                    offset -= scrollSpeed;
                                }

                                if (offset < 0)
                                {
                                    offset = 0;
                                }
                            }
                        }
                        else if (current_mode == Control::Type::PREVIEW)
                        {
                            auto offset_limit = 0;

                            if (story->Monsters.size() > 0)
                            {
                                offset_limit = story->Monsters.size();
                            }
                            else if (story->EnemyFleet.size() > 0)
                            {
                                offset_limit = story->EnemyFleet.size();
                            }
                            else if (story->EnemyArmy.size() > 0)
                            {
                                offset_limit = story->EnemyArmy.size();
                            }

                            if (popup_offset > 0)
                            {
                                popup_offset -= popup_speed;

                                if (popup_offset < 0)
                                {
                                    popup_offset = 0;
                                }

                                popup_last = popup_offset + popup_limit;

                                if (popup_last > offset_limit)
                                {
                                    popup_last = offset_limit;
                                }

                                if (story->Monsters.size() > 0)
                                {
                                    controls_popup = popupList(window, renderer, story->Monsters, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy);
                                }
                                else if (story->EnemyFleet.size() > 0)
                                {
                                    controls_popup = popupList(window, renderer, story->EnemyFleet, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy);
                                }
                                else if (story->EnemyArmy.size() > 0)
                                {
                                    controls_popup = popupList(window, renderer, story->EnemyArmy, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy, false);
                                }

                                SDL_Delay(50);
                            }

                            if (popup_offset <= 0)
                            {
                                current = -1;

                                selected = false;
                            }
                        }
                    }
                    else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || scrollDown)
                    {
                        if (current_mode == Control::Type::STORY)
                        {
                            if (text)
                            {
                                if (text->h >= (text_bounds - 2 * text_space))
                                {
                                    if (offset < (text->h - text_bounds + 2 * text_space))
                                    {
                                        offset += scrollSpeed;
                                    }

                                    if (offset > (text->h - text_bounds + 2 * text_space))
                                    {
                                        offset = text->h - text_bounds + 2 * text_space;
                                    }
                                }
                            }
                        }
                        else if (current_mode == Control::Type::PREVIEW)
                        {
                            auto offset_limit = 0;

                            if (story->Monsters.size() > 0)
                            {
                                offset_limit = story->Monsters.size();
                            }
                            else if (story->EnemyFleet.size() > 0)
                            {
                                offset_limit = story->EnemyFleet.size();
                            }
                            else if (story->EnemyArmy.size() > 0)
                            {
                                offset_limit = story->EnemyArmy.size();
                            }

                            if (offset_limit - popup_last > 0)
                            {
                                if (popup_offset < offset_limit - popup_limit)
                                {
                                    popup_offset += popup_speed;
                                }

                                if (popup_offset > offset_limit - popup_limit)
                                {
                                    popup_offset = offset_limit - popup_limit;
                                }

                                popup_last = popup_offset + popup_limit;

                                if (popup_last > offset_limit)
                                {
                                    popup_last = offset_limit;
                                }

                                if (story->Monsters.size() > 0)
                                {
                                    controls_popup = popupList(window, renderer, story->Monsters, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy);
                                }
                                else if (story->EnemyFleet.size() > 0)
                                {
                                    controls_popup = popupList(window, renderer, story->EnemyFleet, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy);
                                }
                                else if (story->EnemyArmy.size() > 0)
                                {
                                    controls_popup = popupList(window, renderer, story->EnemyArmy, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy, false);
                                }

                                if (popup_offset > 0)
                                {
                                    current = FIND_CONTROL(controls_popup, Control::Type::SCROLL_DOWN);
                                }

                                SDL_Delay(50);
                            }

                            if (offset_limit - popup_last <= 0)
                            {
                                selected = false;

                                current = -1;
                            }
                        }
                    }
                    else if (controls[current].Type == Control::Type::PARTY && !hold)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        viewParty(window, renderer, party, story->Team, false);

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::MAP && !hold)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        mapScreen(window, renderer, story->BookID);

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::HARBOUR && !hold)
                    {
                        if ((story->Ships.size() > 0 && story->Cargo.size() > 0) || (story->Ships.size() > 0 && story->ShipRepairPrice >= 0) || (story->Cargo.size() > 0 && story->ShipRepairPrice >= 0))
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            harbourScreen(window, renderer, party, story);
                        }
                        else if (story->Ships.size() > 0)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            shipScreen(window, renderer, party, Team::Type::NONE, story->Ships, story);
                        }
                        else if (story->Cargo.size() > 0)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            cargoScreen(window, renderer, party, story);
                        }
                        else if (story->ShipRepairPrice >= 0)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            repairScreen(window, renderer, party, story);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);
                        }

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::SHOP && !hold)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        auto result = -1;

                        if (Engine::COUNT(party) == 1)
                        {
                            result = Engine::FIRST(party);
                        }
                        else
                        {
                            result = selectPartyMember(window, renderer, party, Team::Type::NONE, Equipment::NONE, Control::Type::ENTER_SHOP);
                        }

                        if (result >= 0 && result < party.Members.size())
                        {
                            shopScreen(window, renderer, party, story->Team, story->Shop, result);
                        }

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::REST && !hold)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        restScreen(window, renderer, party, story->RestPrice, story->CanRecharge);

                        current = -1;

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::GAME && !hold)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        auto result = gameScreen(window, renderer, saveParty, true);

                        if (result == Control::Type::SAVE)
                        {
                            displayMessage("Game Saved!", intLB);
                        }
                        else if (result == Control::Type::LOAD)
                        {
                            if (saveParty.Book != Book::Type::NONE && saveParty.StoryID != -1)
                            {
                                party = saveParty;

                                story = findStory({party.Book, party.StoryID});

                                transition = true;

                                displayMessage("Game loaded!", intLB);

                                continue;
                            }
                        }

                        current = -1;

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::PREVIEW && !hold)
                    {
                        if (current_mode == Control::Type::STORY)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            current_mode = Control::Type::PREVIEW;

                            popup_offset = 0;

                            popup_last = popup_offset + popup_limit;

                            if (Engine::COUNT(story->Monsters) > 0 || Engine::COUNT(story->EnemyArmy) > 0 || Engine::COUNT(story->EnemyFleet) > 0)
                            {
                                if (story->Monsters.size() > 0)
                                {
                                    if (popup_last > story->Monsters.size())
                                    {
                                        popup_last = story->Monsters.size();
                                    }

                                    controls_popup = popupList(window, renderer, story->Monsters, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy);
                                }
                                else if (story->EnemyFleet.size() > 0)
                                {
                                    if (popup_last > story->EnemyFleet.size())
                                    {
                                        popup_last = story->EnemyFleet.size();
                                    }

                                    controls_popup = popupList(window, renderer, story->EnemyFleet, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy);
                                }
                                else if (story->EnemyArmy.size() > 0)
                                {
                                    if (popup_last > story->EnemyArmy.size())
                                    {
                                        popup_last = story->EnemyArmy.size();
                                    }

                                    controls_popup = popupList(window, renderer, story->EnemyArmy, popup_offset, popup_last, popup_limit, popupw, popuph, infoh, popupx, popupy, false);
                                }
                            }
                        }

                        current = -1;

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::BACK && !hold)
                    {
                        if (current_mode == Control::Type::CONFIRM)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            current_mode = Control::Type::STORY;
                        }

                        current = -1;

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::CONFIRM && !hold)
                    {
                        if (current_mode == Control::Type::PREVIEW)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            current_mode = Control::Type::STORY;
                        }
                        else if (current_mode == Control::Type::CONFIRM)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            transition = true;

                            quit = true;
                        }

                        current = -1;

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::CONTINUE_STORY && !hold)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        Engine::Destination final_destination = {Book::Type::NONE, -1};

                        if (Engine::COUNT(story->Monsters) > 0)
                        {
                            Team::Type team = story->Team;

                            party.CurrentCharacter = Engine::FIND_SOLO(party);

                            if (Engine::IS_ACTIVE(party, party.CurrentCharacter))
                            {
                                team = Team::Type::SOLO;
                            }

                            auto result = combatScreen(window, renderer, party, team, story->Monsters, story->Allies, story->CanFlee, story->FleeRound, story->RoundLimit, true);

                            story->AfterCombat(party, result);
                        }

                        if (Engine::COUNT(story->EnemyFleet) > 0)
                        {
                            auto result = seaCombatScreen(window, renderer, party, story->EnemyFleet, story->CanFlee, story->FleeRound, story->RoundLimit);

                            story->AfterCombat(party, result);
                        }

                        if (story->EnemyArmy.size() > 0)
                        {
                            auto result = deploymentScreen(window, renderer, story->Barracks, party, story->EnemyArmy, story->EnemySpells, story->EnemyArmyStatus);

                            if (result != Engine::Combat::NONE)
                            {
                                story->AfterCombat(party, result);

                                if (result == Engine::Combat::VICTORY)
                                {
                                    addBye(story, "Your forces were victorious in battle.");
                                }
                                else if (result == Engine::Combat::DEFEAT)
                                {
                                    addBye(story, "Your forces were defeated.");
                                }

                                story->EnemyArmy.clear();
                                story->EnemySpells.clear();
                                story->EnemyArmyStatus.clear();
                            }
                            else
                            {
                                continue;
                            }
                        }

                        if (Engine::ALIVE(party) > 0)
                        {
                            if (story->Take.size() > 0 && story->Limit > 0)
                            {
                                auto done = takeScreen(window, renderer, party, story->Team, story->Take, story->Limit, true);

                                if (!done)
                                {
                                    continue;
                                }
                                else
                                {
                                    story->Limit = 0;
                                }
                            }

                            if (story->Spells.size() > 0 && Engine::SPELLCASTERS(party) > 0)
                            {
                                auto done = spellScreen(window, renderer, party, story->Spells, true);

                                if (!done)
                                {
                                    continue;
                                }
                                else
                                {
                                    story->Spells.clear();
                                }
                            }

                            if (story->Army.size() > 0)
                            {
                                auto done = armyScreen(window, renderer, party, story->Army);

                                if (!done)
                                {
                                    continue;
                                }
                                else
                                {
                                    story->Army.clear();
                                }
                            }

                            // Remove dead party members
                            auto liveCharacters = std::vector<Character::Base>();

                            auto deadInventory = std::vector<Equipment::Base>();

                            for (auto i = 0; i < party.Members.size(); i++)
                            {
                                if (Engine::IS_ALIVE(party.Members[i]))
                                {
                                    liveCharacters.push_back(party.Members[i]);
                                }
                                else
                                {
                                    party.Dead.push_back(party.Members[i].Type);

                                    if (party.Members[i].Team == Team::Type::SOLO && party.CurrentCharacter == i)
                                    {
                                        party.Members[i].Equipment.clear();
                                    }

                                    if (party.Members[i].Type == Character::Type::AKIHIRO_OF_CHALICE && party.Members[i].Team == Team::Type::SOLO && party.CurrentCharacter == i)
                                    {
                                        if (book == Book::Type::BOOK1)
                                        {
                                            final_destination = {Book::Type::BOOK1, 450};
                                        }
                                    }

                                    if (party.CurrentCharacter != -1)
                                    {
                                        party.CurrentCharacter = -1;
                                    }

                                    if (party.LastSelected != -1)
                                    {
                                        party.LastSelected = -1;
                                    }

                                    if (party.LastSelection.size() > 0)
                                    {
                                        party.LastSelection.clear();
                                    }

                                    if (party.Members[i].Equipment.size() > 0)
                                    {
                                        deadInventory.insert(deadInventory.end(), party.Members[i].Equipment.begin(), party.Members[i].Equipment.end());
                                    }

                                    auto deadCharacter = Engine::FIND_CHARACTER(party.Order, party.Members[i].Type);

                                    if (deadCharacter >= 0 && deadCharacter < party.Order.size())
                                    {
                                        party.Order.erase(party.Order.begin() + deadCharacter);
                                    }
                                }
                            }

                            party.Members = liveCharacters;

                            if (deadInventory.size() > 0)
                            {
                                takeScreen(window, renderer, party, Team::Type::NONE, deadInventory, deadInventory.size(), false);
                            }

                            while (!Engine::VERIFY_EQUIPMENT_LIMIT(party))
                            {
                                for (auto i = 0; i < party.Members.size(); i++)
                                {
                                    if (Engine::IS_ACTIVE(party, i))
                                    {
                                        while (!Engine::VERIFY_EQUIPMENT_LIMIT(party.Members[i]))
                                        {
                                            inventoryScreen(window, renderer, party, story->Team, party.Members[i], -1, false);
                                        }
                                    }
                                }
                            }

                            // clean-up fleet
                            auto remaining_fleet = std::vector<Ship::Base>();

                            for (auto i = 0; i < party.Fleet.size(); i++)
                            {
                                if (party.Fleet[i].Health > 0)
                                {
                                    remaining_fleet.push_back(party.Fleet[i]);

                                    if (party.CurrentShip == i)
                                    {
                                        party.CurrentShip = remaining_fleet.size() - 1;
                                    }
                                }
                            }

                            party.Fleet = remaining_fleet;

                            current = -1;

                            selected = false;

                            Story::Base *next;

                            // handle special destinations for character deaths
                            if (final_destination.first != Book::Type::NONE && final_destination.second != -1)
                            {
                                next = findStory(final_destination);
                            }
                            else
                            {
                                next = renderChoices(window, renderer, party, story);
                            }

                            book = next->BookID;

                            storyTransition(party, story, next);

                            if ((next->ID != story->ID) || (story->BookID != next->BookID))
                            {
                                if (story->Bye)
                                {
                                    auto bye = createText(story->Bye, FONT_GARAMOND, font_size + 4, clrDB, fullwidth - 2 * text_space, TTF_STYLE_NORMAL);

                                    auto forward = createImage("icons/next.png");

                                    if (bye && forward)
                                    {
                                        fillWindow(renderer, intWH);

                                        if (background)
                                        {
                                            stretchImage(renderer, background, 0, 0, SCREEN_WIDTH, buttony - button_space);
                                        }

                                        fillRect(renderer, fullwidth, bye->h + 2 * text_space, startx, ((buttony - button_space) - (bye->h + 2 * text_space)) / 2, BE_80);

                                        renderText(renderer, bye, 0, (SCREEN_WIDTH - bye->w) / 2, ((buttony - button_space) - bye->h) / 2, (buttony - button_space), 0);

                                        renderImage(renderer, forward, lastx, buttony);

                                        SDL_RenderPresent(renderer);

                                        Input::WaitForNext(renderer);

                                        Sound::Play(Sound::Type::BUTTON_CLICK);

                                        SDL_FreeSurface(bye);

                                        bye = NULL;

                                        SDL_FreeSurface(forward);

                                        forward = NULL;
                                    }
                                }

                                story = next;

                                transition = true;
                            }
                            else if (Engine::ALIVE(party) <= 0)
                            {
                                controls_normal = Story::ExitControls(compact);
                            }
                        }
                        else
                        {
                            controls_normal = Story::ExitControls(compact);
                        }
                    }
                    else if (controls[current].Type == Control::Type::ENCYCLOPEDIA && !hold)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        encyclopediaScreen(window, renderer, story->BookID);

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::RECRUIT && !hold)
                    {
                        if (Engine::CAN_RECRUIT(party, story->BookID))
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            recruitAdventurer(window, renderer, story->BookID, party, story->RecruitmentPrice);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("There is no one left to recruit in this land!", intRD);
                        }

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::BARRACKS && !hold)
                    {
                        if (party.Army.size() <= 0)
                        {
                            Sound::Play(Sound::Type::ERROR);

                            displayMessage("You do not have any troops!", intRD);
                        }
                        else
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            armyTransfer(window, renderer, party);
                        }

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::QUIT && !hold)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        if (current_mode == Control::Type::STORY)
                        {
                            current_mode = Control::Type::CONFIRM;
                        }

                        current = -1;

                        selected = false;
                    }
                }
            }

            if (splash)
            {
                SDL_FreeSurface(splash);

                splash = NULL;
            }

            if (splashTexture)
            {
                SDL_DestroyTexture(splashTexture);

                splashTexture = NULL;
            }

            if (text)
            {
                SDL_FreeSurface(text);

                text = NULL;
            }
        }

        if (background)
        {
            SDL_FreeSurface(background);

            background = NULL;
        }

        if (font_garamond)
        {
            TTF_CloseFont(font_garamond);

            font_garamond = NULL;
        }

        if (font_caption)
        {
            TTF_CloseFont(font_caption);

            font_caption = NULL;
        }

        if (font_mason)
        {
            TTF_CloseFont(font_mason);

            font_mason = NULL;
        }

        if (font_mason2)
        {
            TTF_CloseFont(font_mason2);

            font_mason2 = NULL;
        }

        if (font_dark11)
        {
            TTF_CloseFont(font_dark11);

            font_mason = NULL;
        }

        TTF_Quit();
    }

    return quit;
}

bool storyScreen(SDL_Window *window, SDL_Renderer *renderer, Party::Base &party, Engine::Destination destination)
{
    auto story = findStory(destination);

    return processStory(window, renderer, party, story->BookID, story);
}

std::vector<Button> topicsList(SDL_Window *window, SDL_Renderer *renderer, std::vector<Topics::Base> &topics, int start, int last, int limit, int offsetx, int offsety, bool compact)
{
    auto controls = std::vector<Button>();

    if (topics.size() > 0)
    {
        for (auto i = 0; i < last - start; i++)
        {
            auto index = start + i;

            auto topic = topics[index];

            auto y = (i > 0 ? controls[i - 1].Y + controls[i - 1].H + 3 * text_space : offsety + 2 * text_space);

            controls.push_back(Button(i, createHeaderButton(window, FONT_GARAMOND, 22, topic.Title.c_str(), clrBK, intBE, splashw - 3 * button_space / 2, list_buttonh, text_space), i, i, (i > 0 ? i - 1 : i), i + 1, offsetx + 2 * text_space, y, Control::Type::ACTION));

            controls[i].W = controls[i].Surface->w;

            controls[i].H = controls[i].Surface->h;
        }
    }

    auto idx = (int)controls.size();

    if (topics.size() > limit)
    {
        auto marginx = (int)(SCREEN_WIDTH * Margin);

        auto scroll_space = (marginx - arrow_size) / 2;

        if (start > 0)
        {
            controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, startx + splashw + scroll_space, texty + border_space, Control::Type::TOPICS_UP));

            idx += 1;
        }

        if (topics.size() - last > 0)
        {
            controls.push_back(Button(idx, "icons/down-arrow.png", idx, idx, start > 0 ? idx - 1 : idx, idx + 1, startx + splashw + scroll_space, scrolly, Control::Type::TOPICS_DOWN));

            idx += 1;
        }
    }

    if (!compact)
    {
        idx = controls.size();

        auto topic_scrollx = (int)((1.0 - Margin) * SCREEN_WIDTH - arrow_size);

        controls.push_back(Button(idx, "icons/up-arrow.png", idx, idx, idx, idx + 1, topic_scrollx, texty + border_space, Control::Type::SCROLL_UP));
        controls.push_back(Button(idx + 1, "icons/down-arrow.png", idx + 1, idx + 1, idx, idx + 2, topic_scrollx, texty + text_bounds - arrow_size - border_space, Control::Type::SCROLL_DOWN));
    }

    idx = controls.size();

    controls.push_back(Button(idx, "icons/previous.png", idx, idx + 1, topics.size() > 0 ? (last - start) - 1 : idx, idx, textx, buttony, Control::Type::PREVIOUS_TOPIC));
    controls.push_back(Button(idx + 1, "icons/next.png", idx, idx + 2, topics.size() > 0 ? (last - start) - 1 : idx + 1, idx + 1, textx + gridsize, buttony, Control::Type::NEXT_TOPIC));
    controls.push_back(Button(idx + 2, "icons/back-button.png", idx + 1, idx + 2, topics.size() > 0 ? (last - start) - 1 : idx + 2, idx + 2, lastx, buttony, Control::Type::BACK));

    return controls;
}

bool encyclopediaScreen(SDL_Window *window, SDL_Renderer *renderer, Book::Type bookID)
{
    static int topic = 0;

    static int topic_offset = 0;

    if (window && renderer)
    {
        if (Topics::ALL.size() <= 0)
        {
            Topics::LoadTopics(bookID);
        }

        if (Topics::ALL.size() > 0)
        {
            auto font_size = 28;

            TTF_Init();

            if (topic < 0)
            {
                topic = 0;
            }

            if (topic >= (Topics::ALL.size() - 1))
            {
                topic = Topics::ALL.size();
            }

            if (topic_offset < 0)
            {
                topic_offset = 0;
            }

            auto topic_speed = 1;

            auto topic_limit = (text_bounds - 2 * text_space - infoh) / (96);

            if (topic_offset > (Topics::ALL.size() - topic_limit))
            {
                topic_offset = Topics::ALL.size() - topic_limit;
            }

            auto topic_last = topic_offset + topic_limit;

            if (topic_last > Topics::ALL.size())
            {
                topic_last = Topics::ALL.size();
            }

            SDL_Surface *text = NULL;

            auto font_garamond = TTF_OpenFont(FONT_GARAMOND, font_size);

            auto font_mason = TTF_OpenFont(FONT_MASON, 32);

            auto font_caption = TTF_OpenFont(FONT_GARAMOND, 22);

            if (Topics::ALL[topic].Text.length() > 0 && Topics::ALL[topic].Image.length() > 0)
            {
                text = createTextAndImage(Topics::ALL[topic].Text.c_str(), Topics::ALL[topic].Image.c_str(), FONT_GARAMOND, font_size, clrDB, intBE, listwidth, TTF_STYLE_NORMAL);
            }
            else if (Topics::ALL[topic].Image.length() > 0)
            {
                text = createImage(Topics::ALL[topic].Image.c_str(), listwidth, intBE);
            }
            else if (Topics::ALL[topic].Text.length() > 0)
            {
                text = createText(Topics::ALL[topic].Text.c_str(), FONT_GARAMOND, font_size, clrDB, listwidth, TTF_STYLE_NORMAL);
            }

            auto compact = (text && text->h <= (text_bounds - 2 * text_space - infoh)) || !text;

            auto controls = topicsList(window, renderer, Topics::ALL, topic_offset, topic_last, topic_limit, startx, starty + infoh, compact);

            auto scrollSpeed = 20;

            auto hold = false;

            auto scrollUp = false;

            auto scrollDown = false;

            auto selected = false;

            auto current = -1;

            auto offset = 0;

            auto scroll_topics = false;

            auto quit = false;

            SDL_Surface *splash = NULL;

            SDL_Texture *splashTexture = NULL;

            auto splash_h = splashw;

            if (Topics::ALL[topic].Image.length() > 0)
            {
                splash = createImage(Topics::ALL[topic].Image.c_str());
            }

            if (splash)
            {
                if (splash->w > listwidth)
                {
                    splash_h = (int)((double)listwidth / splash->w * splash->h);
                }
                else
                {
                    splash_h = splash->h;
                }

                splashTexture = SDL_CreateTextureFromSurface(renderer, splash);
            }

            auto fg = Color::HEADER(bookID);

            while (!quit)
            {
                if (Topics::ALL[topic].Title.length() > 0)
                {
                    SDL_SetWindowTitle(window, Topics::ALL[topic].Title.c_str());
                }

                fillWindow(renderer, intWH);

                putHeader(renderer, "Topics", font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, splashw, infoh, startx, starty);

                fillRect(renderer, splashw, text_bounds - infoh, startx, texty + infoh, BE_80);

                putHeader(renderer, Topics::ALL[topic].Title.c_str(), font_mason, text_space, clrWH, fg, TTF_STYLE_NORMAL, textwidth, infoh, textx, texty);

                fillRect(renderer, textwidth, text_bounds - infoh, textx, texty + infoh, BE_80);

                if (Topics::ALL[topic].Image.length() > 0 && text)
                {
                    renderImage(renderer, text, textx + text_space, texty + text_space + infoh, text_bounds - 2 * text_space - infoh, offset);
                }
                else if (Topics::ALL[topic].Text.length() > 0 && text)
                {
                    renderText(renderer, text, 0, textx + text_space, texty + text_space + infoh, text_bounds - 2 * text_space - infoh, offset);
                }

                for (auto i = topic_offset; i < topic_last; i++)
                {
                    auto index = i - topic_offset;

                    if (index >= 0 && index < controls.size())
                    {
                        if (topic != i)
                        {
                            drawRect(renderer, controls[index].W + (2 * text_space), controls[index].H + (2 * text_space), controls[index].X - text_space, controls[index].Y - text_space, intBK);
                        }
                        else
                        {
                            thickRect(renderer, controls[index].W + (text_space - 2), controls[index].H + (text_space - 2), controls[index].X - border_pts, controls[index].Y - (border_pts - 1), intLB, (border_pts - 1));
                        }
                    }
                }

                renderButtons(renderer, controls, current, intLB, border_space, border_pts, (!compact && offset > 0), !compact && text && offset < (text->h - text_bounds + 2 * text_space + infoh));

                if (current >= 0 && current < controls.size())
                {
                    renderCaption(renderer, font_caption, controls[current]);
                }

                if (splash && splash->w > listwidth)
                {
                    auto mousex = 0;
                    auto mousey = 0;

                    SDL_GetMouseState(&mousex, &mousey);

                    auto zoomw = textx - startx;
                    auto zoomh = splashw;

                    clipValue(zoomw, 0, splash->w);
                    clipValue(zoomh, 0, splash->h);

                    auto offsetx = 0;
                    auto offsety = splash_h;

                    if (splash->w < listwidth)
                    {
                        offsetx = (listwidth - splash->w) / 2;

                        offsety = splash->h;
                    }

                    if (mousex >= (textx + text_space + offsetx) && mousex <= (textx + textwidth - text_space - offsetx) && mousey >= (texty + infoh + text_space) && mousey <= (texty + text_bounds - text_space) && offset >= 0 && offset <= offsety && ((mousey - (texty + infoh + text_space)) <= (offsety - offset)))
                    {
                        auto scalex = (double)(mousex - (textx + text_space)) / listwidth;
                        auto scaley = (double)((mousey - (texty + text_space + infoh)) + offset) / offsety;

                        auto centerx = (int)(scalex * (double)splash->w);
                        auto centery = (int)(scaley * (double)splash->h);

                        clipValue(centerx, zoomw / 2, splash->w - zoomw / 2);
                        clipValue(centery, zoomh / 2, splash->h - zoomh / 2);

                        if (splashTexture)
                        {
                            SDL_Rect src;

                            src.w = zoomw;
                            src.h = zoomh;
                            src.x = centerx - zoomw / 2;
                            src.y = centery - zoomh / 2;

                            SDL_Rect dst;

                            dst.w = zoomw;
                            dst.h = zoomh;
                            dst.x = startx / 2;
                            dst.y = (starty + (text_bounds - zoomh) / 2);

                            fillRect(renderer, dst.w, dst.h, dst.x, dst.y, intWH);
                            SDL_RenderCopy(renderer, splashTexture, &src, &dst);
                            drawRect(renderer, dst.w + 2, dst.h + 2, dst.x - 1, dst.y - 1, intBK);
                        }
                    }
                }

                Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

                if (scrollUp || scrollDown)
                {
                    auto mousex = 0;
                    auto mousey = 0;

                    SDL_GetMouseState(&mousex, &mousey);

                    if (mousex >= startx && mousex <= (startx + splashw) && mousey >= starty && mousey <= (starty + text_bounds))
                    {
                        scroll_topics = true;
                    }
                    else
                    {
                        scroll_topics = false;
                    }
                }

                if (((selected && current >= 0 && current < controls.size()) || scrollUp || scrollDown || hold))
                {
                    if (controls[current].Type == Control::Type::SCROLL_UP || (controls[current].Type == Control::Type::SCROLL_UP && hold) || (scrollUp && !scroll_topics))
                    {
                        if (text)
                        {
                            if (offset > 0)
                            {
                                offset -= scrollSpeed;
                            }

                            if (offset < 0)
                            {
                                offset = 0;
                            }
                        }
                    }
                    else if (controls[current].Type == Control::Type::SCROLL_DOWN || (controls[current].Type == Control::Type::SCROLL_DOWN && hold) || (scrollDown && !scroll_topics))
                    {
                        if (text)
                        {
                            if (text->h >= text_bounds - 2 * text_space - infoh)
                            {
                                if (offset < text->h - text_bounds + 2 * text_space + infoh)
                                {
                                    offset += scrollSpeed;
                                }

                                if (offset > text->h - text_bounds + 2 * text_space + infoh)
                                {
                                    offset = text->h - text_bounds + 2 * text_space + infoh;
                                }
                            }
                        }
                    }
                    else if (controls[current].Type == Control::Type::ACTION && !hold)
                    {
                        if ((topic_offset + current) >= 0 && (topic_offset + current) < Topics::ALL.size())
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            topic = topic_offset + current;

                            if (text)
                            {
                                SDL_FreeSurface(text);
                            }

                            offset = 0;

                            if (Topics::ALL[topic].Text.length() > 0 && Topics::ALL[topic].Image.length() > 0)
                            {
                                text = createTextAndImage(Topics::ALL[topic].Text.c_str(), Topics::ALL[topic].Image.c_str(), FONT_GARAMOND, font_size, clrDB, intBE, listwidth, TTF_STYLE_NORMAL);
                            }
                            else if (Topics::ALL[topic].Image.length() > 0)
                            {
                                text = createImage(Topics::ALL[topic].Image.c_str(), listwidth, intBE);
                            }
                            else if (Topics::ALL[topic].Text.length() > 0)
                            {
                                text = createText(Topics::ALL[topic].Text.c_str(), FONT_GARAMOND, font_size, clrDB, listwidth, TTF_STYLE_NORMAL);
                            }

                            if (splash)
                            {
                                SDL_FreeSurface(splash);

                                splash = NULL;
                            }

                            if (splashTexture)
                            {
                                SDL_DestroyTexture(splashTexture);

                                splashTexture = NULL;
                            }

                            if (Topics::ALL[topic].Image.length() > 0)
                            {
                                splash = createImage(Topics::ALL[topic].Image.c_str());
                            }

                            splash_h = splashw;

                            if (splash)
                            {
                                if (splash->w > listwidth)
                                {
                                    splash_h = (int)((double)listwidth / splash->w * splash->h);
                                }
                                else
                                {
                                    splash_h = splash->h;
                                }

                                splashTexture = SDL_CreateTextureFromSurface(renderer, splash);
                            }

                            compact = (text && text->h <= (text_bounds - 2 * text_space - infoh)) || !text;

                            controls = topicsList(window, renderer, Topics::ALL, topic_offset, topic_last, topic_limit, startx, starty + infoh, compact);
                        }

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::PREVIOUS_TOPIC && !hold)
                    {
                        if (topic > 0)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            topic -= 1;

                            if (text)
                            {
                                SDL_FreeSurface(text);
                            }

                            offset = 0;

                            if (Topics::ALL[topic].Text.length() > 0 && Topics::ALL[topic].Image.length() > 0)
                            {
                                text = createTextAndImage(Topics::ALL[topic].Text.c_str(), Topics::ALL[topic].Image.c_str(), FONT_GARAMOND, font_size, clrDB, intBE, listwidth, TTF_STYLE_NORMAL);
                            }
                            else if (Topics::ALL[topic].Image.length() > 0)
                            {
                                text = createImage(Topics::ALL[topic].Image.c_str(), listwidth, intBE);
                            }
                            else if (Topics::ALL[topic].Text.length() > 0)
                            {
                                text = createText(Topics::ALL[topic].Text.c_str(), FONT_GARAMOND, font_size, clrDB, listwidth, TTF_STYLE_NORMAL);
                            }

                            if (splash)
                            {
                                SDL_FreeSurface(splash);

                                splash = NULL;
                            }

                            if (splashTexture)
                            {
                                SDL_DestroyTexture(splashTexture);

                                splashTexture = NULL;
                            }

                            if (Topics::ALL[topic].Image.length() > 0)
                            {
                                splash = createImage(Topics::ALL[topic].Image.c_str());
                            }

                            splash_h = splashw;

                            if (splash)
                            {
                                if (splash->w > listwidth)
                                {
                                    splash_h = (int)((double)listwidth / splash->w * splash->h);
                                }
                                else
                                {
                                    splash_h = splash->h;
                                }

                                splashTexture = SDL_CreateTextureFromSurface(renderer, splash);
                            }

                            compact = (text && text->h <= (text_bounds - 2 * text_space - infoh)) || !text;

                            controls = topicsList(window, renderer, Topics::ALL, topic_offset, topic_last, topic_limit, startx, starty + infoh, compact);

                            current = FIND_CONTROL(controls, Control::Type::PREVIOUS_TOPIC);
                        }

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::NEXT_TOPIC && !hold)
                    {
                        if (topic < Topics::ALL.size() - 1)
                        {
                            Sound::Play(Sound::Type::BUTTON_CLICK);

                            topic += 1;

                            if (text)
                            {
                                SDL_FreeSurface(text);
                            }

                            offset = 0;

                            if (Topics::ALL[topic].Text.length() > 0 && Topics::ALL[topic].Image.length() > 0)
                            {
                                text = createTextAndImage(Topics::ALL[topic].Text.c_str(), Topics::ALL[topic].Image.c_str(), FONT_GARAMOND, font_size, clrDB, intBE, listwidth, TTF_STYLE_NORMAL);
                            }
                            else if (Topics::ALL[topic].Image.length() > 0)
                            {
                                text = createImage(Topics::ALL[topic].Image.c_str(), listwidth, intBE);
                            }
                            else if (Topics::ALL[topic].Text.length() > 0)
                            {
                                text = createText(Topics::ALL[topic].Text.c_str(), FONT_GARAMOND, font_size, clrDB, listwidth, TTF_STYLE_NORMAL);
                            }

                            if (splash)
                            {
                                SDL_FreeSurface(splash);

                                splash = NULL;
                            }

                            if (splashTexture)
                            {
                                SDL_DestroyTexture(splashTexture);

                                splashTexture = NULL;
                            }

                            if (Topics::ALL[topic].Image.length() > 0)
                            {
                                splash = createImage(Topics::ALL[topic].Image.c_str());
                            }

                            splash_h = splashw;

                            if (splash)
                            {
                                if (splash->w > listwidth)
                                {
                                    splash_h = (int)((double)listwidth / splash->w * splash->h);
                                }
                                else
                                {
                                    splash_h = splash->h;
                                }

                                splashTexture = SDL_CreateTextureFromSurface(renderer, splash);
                            }

                            compact = (text && text->h <= (text_bounds - 2 * text_space - infoh)) || !text;

                            controls = topicsList(window, renderer, Topics::ALL, topic_offset, topic_last, topic_limit, startx, starty + infoh, compact);

                            current = FIND_CONTROL(controls, Control::Type::NEXT_TOPIC);
                        }

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::TOPICS_UP || (controls[current].Type == Control::Type::TOPICS_UP && hold) || (scrollUp && scroll_topics))
                    {
                        if (topic_offset > 0)
                        {
                            topic_offset -= topic_speed;

                            if (topic_offset < 0)
                            {
                                topic_offset = 0;
                            }

                            topic_last = topic_offset + topic_limit;

                            if (topic_last > Topics::ALL.size())
                            {
                                topic_last = Topics::ALL.size();
                            }

                            compact = (text && text->h <= (text_bounds - 2 * text_space - infoh)) || !text;

                            controls = topicsList(window, renderer, Topics::ALL, topic_offset, topic_last, topic_limit, startx, starty + infoh, compact);
                        }

                        current = FIND_CONTROL(controls, Control::Type::TOPICS_UP);

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::TOPICS_DOWN || (controls[current].Type == Control::Type::TOPICS_DOWN && hold) || (scrollDown && scroll_topics))
                    {
                        if (Topics::ALL.size() - topic_last > 0)
                        {
                            if (topic_offset < Topics::ALL.size() - topic_limit)
                            {
                                topic_offset += topic_speed;
                            }

                            if (topic_offset > Topics::ALL.size() - topic_limit)
                            {
                                topic_offset = Topics::ALL.size() - topic_limit;
                            }

                            topic_last = topic_offset + topic_limit;

                            if (topic_last > Topics::ALL.size())
                            {
                                topic_last = Topics::ALL.size();
                            }

                            compact = (text && text->h <= (text_bounds - 2 * text_space - infoh)) || !text;

                            controls = topicsList(window, renderer, Topics::ALL, topic_offset, topic_last, topic_limit, startx, starty + infoh, compact);
                        }

                        current = FIND_CONTROL(controls, Control::Type::TOPICS_DOWN);

                        selected = false;
                    }
                    else if (controls[current].Type == Control::Type::BACK && !hold)
                    {
                        Sound::Play(Sound::Type::BUTTON_CLICK);

                        quit = true;
                    }
                }
            }

            if (splash)
            {
                SDL_FreeSurface(splash);

                splash = NULL;
            }

            if (splashTexture)
            {
                SDL_DestroyTexture(splashTexture);

                splashTexture = NULL;
            }

            if (text)
            {
                SDL_FreeSurface(text);

                text = NULL;
            }

            if (font_garamond)
            {
                TTF_CloseFont(font_garamond);

                font_garamond = NULL;
            }

            if (font_caption)
            {
                TTF_CloseFont(font_caption);

                font_caption = NULL;
            }

            if (font_mason)
            {
                TTF_CloseFont(font_mason);

                font_mason = NULL;
            }

            TTF_Quit();
        }
    }

    return false;
}

bool mainScreen(SDL_Window *window, SDL_Renderer *renderer, Book::Type bookID, int storyID)
{
    SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_NONE);

    auto font_size = 20;

    auto *introduction = "Prepare for adventure in this huge open-world gamebook series. Legendary Kingdoms is a gamebook campaign, where you lead a party of adventurers in a world that adapts to your actions. Venture into ancient ruins, pick a side and lead an army into battle, sail the high seas on your own warship, defeat tyrants or bring them to power. Along the way your party will increase in skill, wealth and renown, allowing them to take on more challenging adventures. Reach the heights of power and you may uncover a dreadful threat to the world itself and go on a mission that spans all six gamebooks in the series.\n\nBook 1: The Valley of Bones takes place in a desert wilderness where tyrant kings oppress the teeming masses in a land strewn with ancient artefacts and ruins. But their grip on power is fragile... and the citizenry are ripe for revolution. It is a land of blood and sand, where civilisation is rare and terrible beasts roam freely.";

    auto splash = createImage("images/book1/valley-of-bones-cover.png");

    auto text = createText(introduction, FONT_GARAMOND, 28, clrDB, (int)(SCREEN_WIDTH * (1.0 - 3.0 * Margin) - splashw), TTF_STYLE_NORMAL);

    Book1::InitializeStories();

    if (window && renderer && splash && text)
    {
        const char *choices[4] = {"NEW GAME", "LOAD GAME", "ABOUT", "EXIT"};

        auto current = -1;

        auto selected = false;

        auto controls = createHTextButtons(choices, 4, text_buttonh, startx, text_buttony);

        controls[0].Type = Control::Type::NEW;
        controls[1].Type = Control::Type::LOAD;
        controls[2].Type = Control::Type::ABOUT;
        controls[3].Type = Control::Type::QUIT;

        auto done = false;

        while (!done)
        {
            SDL_SetWindowTitle(window, "Legendary Kingdoms");

            auto Party = Party::Base();

            fillWindow(renderer, intWH);

            fitImage(renderer, splash, startx, starty, splashw, text_bounds);

            fillRect(renderer, text->w + 2 * text_space, text->h + 2 * text_space, startx * 2 + splashw, texty, intWH);

            renderText(renderer, text, intBK, startx * 2 + splashw + text_space, starty + text_space, (int)(SCREEN_HEIGHT * (1.0 - 2 * Margin) - 2 * text_space), 0);

            renderTextButtons(renderer, controls, FONT_DARK11, current, clrWH, intDB, intLB, font_size + 2, TTF_STYLE_NORMAL);

            auto scrollUp = false;
            auto scrollDown = false;
            auto hold = false;

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            if (selected && current >= 0 && current < controls.size())
            {
                Sound::Play(Sound::Type::BUTTON_CLICK);

                if (controls[current].Type == Control::Type::NEW && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    selectParty(window, renderer, bookID, Party);

                    if (Party.Members.size() == 4)
                    {
                        storyScreen(window, renderer, Party, {bookID, storyID});
                    }

                    current = -1;

                    selected = false;

                    storyID = 1;
                }
                else if (controls[current].Type == Control::Type::ABOUT && !hold)
                {
                    Sound::Play(Sound::Type::BUTTON_CLICK);

                    encyclopediaScreen(window, renderer, bookID);

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::LOAD && !hold)
                {
                    auto result = gameScreen(window, renderer, Party, false);

                    if (result == Control::Type::LOAD)
                    {
                        if (Party.Book != Book::Type::NONE && Party.StoryID != -1)
                        {
                            Sound::Play(Sound::Type::SUCCESS);

                            storyScreen(window, renderer, Party, {Party.Book, Party.StoryID});
                        }
                    }

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::QUIT && !hold)
                {
                    done = true;
                }
            }
        }

        SDL_FreeSurface(splash);

        SDL_FreeSurface(text);

        splash = NULL;

        text = NULL;
    }

    return false;
}

bool testScreen(SDL_Window *window, SDL_Renderer *renderer, Book::Type bookID, int storyID)
{
    auto font_size = 20;

    auto *introduction = "This is the DEBUG screen. Testing facilities for various gamebook functions such as COMBAT, SKILL CHECKS, MAGIC, etc, can be accessed here. While the game is still in the ALPHA stage, this is the default screen.\n\nTests:\n1 - Combat\n2 - Map\n3 - Team Skill check\n4 - Individual Skill check\n5 - Mass Combat\n6 - Sea Combat";

    auto text = createText(introduction, FONT_GARAMOND, 28, clrDB, listwidth, TTF_STYLE_NORMAL);

    auto splash = createImage("images/legendary-kingdoms-logo.png");

    if (window && renderer && text && splash)
    {
        auto current = -1;

        auto selected = false;

        const char *choices[7] = {"1", "2", "3", "4", "5", "6", "Exit"};

        auto controls = createHTextButtons(choices, 7, text_buttonh, startx, text_buttony);

        controls[0].Type = Control::Type::COMBAT;
        controls[1].Type = Control::Type::MAP;
        controls[2].Type = Control::Type::TEAM_SKILL;
        controls[3].Type = Control::Type::SKILL;
        controls[4].Type = Control::Type::MASS_COMBAT;
        controls[5].Type = Control::Type::SEA_COMBAT;
        controls[6].Type = Control::Type::QUIT;

        auto done = false;

        auto Party = Party::Base();

        while (!done)
        {
            SDL_SetWindowTitle(window, "Legendary Kingdoms: Debug");

            fillWindow(renderer, intWH);

            fitImage(renderer, splash, startx, starty, splashw, text_bounds);

            fillRect(renderer, textwidth, text_bounds, textx, texty, intBE);

            renderText(renderer, text, intBK, startx * 2 + splashw + text_space, starty + text_space, (int)(SCREEN_HEIGHT * (1.0 - 2 * Margin) - 2 * text_space), 0);

            renderTextButtons(renderer, controls, FONT_MASON, current, clrWH, intDB, intLB, font_size + 2, TTF_STYLE_NORMAL);

            auto scrollUp = false;
            auto scrollDown = false;
            auto hold = false;

            Input::GetInput(renderer, controls, current, selected, scrollUp, scrollDown, hold);

            auto combat = Engine::Combat::NONE;

            if (selected && current >= 0 && current < controls.size())
            {
                Sound::Play(Sound::Type::BUTTON_CLICK);

                if (controls[current].Type == Control::Type::COMBAT && !hold)
                {
                    selectParty(window, renderer, Book::Type::BOOK1, Party);

                    std::vector<Monster::Base> monsters = {
                        Monster::Base("Goblin", 4, 5, 4, 6, 0),
                        Monster::Base("Orc Bodyguard", 6, 4, 4, 10, 0)};

                    std::vector<Allies::Type> allies = {};

                    combat = combatScreen(window, renderer, Party, Team::Type::NONE, monsters, allies, true, -1, -1, false);

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::MAP && !hold)
                {
                    mapScreen(window, renderer, Book::Type::BOOK1);

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::TEAM_SKILL && !hold)
                {
                    selectParty(window, renderer, Book::Type::BOOK1, Party);

                    auto selection = std::vector<int>();

                    skillCheck(window, renderer, Party, Team::Type::NONE, 2, Attribute::Type::STEALTH, 4, 4, selection, true);

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::SKILL && !hold)
                {
                    selectParty(window, renderer, Book::Type::BOOK1, Party);

                    auto selection = std::vector<int>();

                    skillCheck(window, renderer, Party, Team::Type::NONE, 1, Attribute::Type::LORE, 4, 3, selection, true);

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::MASS_COMBAT && !hold)
                {
                    Party.Members.clear();
                    Party.Members.push_back(Character::AMELIA_PASS_DAYNE);
                    Party.Members.push_back(Character::TASHA);
                    Party.Members.push_back(Character::AKIHIRO_OF_CHALICE);
                    Party.Members.push_back(Character::BRASH);

                    std::vector<Engine::BattlefieldSpells> EnemySpells = {
                        {Spells::MassCombat::ENFEEBLEMENT_CENTER_FRONT, 0},
                        {Spells::MassCombat::CLINGING_DREAD_LEFT_FRONT, 1},
                        {Spells::MassCombat::ROUT_LEFT_FRONT, 2}};

                    std::vector<Engine::ArmyStatus> EnemyArmyStatus = {
                        {Army::Status::STRENGTH1, 2, 0, 1}};

                    std::vector<Army::Base> EnemyArmy = {
                        Army::Base("Curzite Zealots", Army::Type::CURSITE_ZEALOTS, Location::Type::SALTDAD, Location::BattleField::LEFT_FLANK_FRONT, 4, 5, false),
                        Army::Base("Cursite Infantry", Army::Type::CURSITE_INFANTRY, Location::Type::SALTDAD, Location::BattleField::LEFT_FLANK_SUPPORT, 4, 4, false),
                        Army::Base("Mercenary Knights", Army::Type::MERCENARY_KNIGHTS, Location::Type::SALTDAD, Location::BattleField::CENTER_FRONT, 5, 3, false),
                        Army::Base("Citizen Archers", Army::Type::CITIZEN_ARCHERS, Location::Type::SALTDAD, Location::BattleField::CENTER_SUPPORT, 2, 4, false),
                        Army::Base("Cursite Riders", Army::Type::CURSITE_RIDERS, Location::Type::SALTDAD, Location::BattleField::RIGHT_FLANK_FRONT, 5, 4, false),
                        Army::Base("Mercenary Spears", Army::Type::MERCENARY_SPEARS, Location::Type::SALTDAD, Location::BattleField::RIGHT_FLANK_SUPPORT, 3, 2, false)};

                    Party.Army = {
                        Army::Base("Curzite Zealots", Army::Type::CURSITE_ZEALOTS, Location::Type::SALTDAD, Location::BattleField::LEFT_FLANK_FRONT, 4, 5, false),
                        Army::Base("Cursite Infantry", Army::Type::CURSITE_INFANTRY, Location::Type::SALTDAD, Location::BattleField::LEFT_FLANK_SUPPORT, 4, 4, false),
                        Army::Base("Bronzeguard", Army::Type::BRONZEGUARD, Location::Type::SALTDAD, Location::BattleField::CENTER_FRONT, 5, 5, true),
                        Army::Base("Lhasbreath Berserkers", Army::Type::LHASBREATH_BERSERKERS, Location::Type::SALTDAD, Location::BattleField::CENTER_SUPPORT, 5, 2, false),
                        Army::Base("Cursite Riders", Army::Type::CURSITE_RIDERS, Location::Type::SALTDAD, Location::BattleField::RIGHT_FLANK_FRONT, 5, 4, false),
                        Army::Base("Lhasbreath Berserkers", Army::Type::LHASBREATH_BERSERKERS, Location::Type::SALTDAD, Location::BattleField::RIGHT_FLANK_SUPPORT, 5, 2, false)};

                    deploymentScreen(window, renderer, Location::Type::SALTDAD, Party, EnemyArmy, EnemySpells, EnemyArmyStatus);

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::SEA_COMBAT && !hold)
                {
                    selectParty(window, renderer, Book::Type::BOOK1, Party);

                    Party.Fleet.clear();

                    Party.Fleet.push_back(Ship::Base("CURSITE WAR GALLEY", Ship::Type::CURSITE_WAR_GALLEY, Location::Type::NONE, 6, 9, 1));

                    Party.CurrentShip = 0;

                    std::vector<Ship::Base> enemyFleet = {
                        Ship::Base("HULK", Ship::Type::HULK, Location::Type::NONE, 3, 5, 3),
                        Ship::Base("COG", Ship::Type::COG, Location::Type::NONE, 4, 7, 2)};

                    std::vector<Allies::Type> allies = {};

                    combat = seaCombatScreen(window, renderer, Party, enemyFleet, true, 0, -1);

                    current = -1;

                    selected = false;
                }
                else if (controls[current].Type == Control::Type::QUIT)
                {
                    done = true;
                }
            }
        }

        SDL_FreeSurface(splash);

        SDL_FreeSurface(text);

        splash = NULL;

        text = NULL;
    }

    return false;
}

int main(int argc, char **argv)
{
    SDL_Window *window = NULL;

    SDL_Renderer *renderer = NULL;

    createWindow(SDL_INIT_VIDEO | SDL_INIT_AUDIO, &window, &renderer, "Legendary Kingdoms", "icons/spidermindgames-48.png");

    Input::InitializeGamePads();

    Sound::Initialize();

    auto storyID = 1;

    auto bookID = Book::Type::BOOK1;

    if (argc > 1)
    {
        storyID = std::atoi(argv[1]);
    }

    if (window && renderer)
    {
#if defined(DEBUG)
        testScreen(window, renderer, bookID, storyID);
#else
        if (storyID == 1 || storyID == 0)
        {
            introScreen(window, renderer);
        }

        mainScreen(window, renderer, bookID, storyID);
#endif

        if (renderer)
        {
            SDL_DestroyRenderer(renderer);

            renderer = NULL;
        }

        if (window)
        {
            SDL_DestroyWindow(window);

            window = NULL;
        }
    }

    Sound::Free();

    // Quit SDL Subsystems
    Mix_Quit();

    IMG_Quit();

    SDL_Quit();

    return 0;
}
